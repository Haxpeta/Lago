<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lago</title>
  
  
  <link href="/Lago/atom.xml" rel="self"/>
  
  <link href="https://memorytoco.github.io/Lago/"/>
  <updated>2019-02-15T14:00:50.281Z</updated>
  <id>https://memorytoco.github.io/Lago/</id>
  
  <author>
    <name>Memorytoco</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shell 工具集</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/16/shell-tools/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/16/shell-tools/</id>
    <published>2019-02-15T21:54:50.000Z</published>
    <updated>2019-02-15T14:00:50.281Z</updated>
    
    <content type="html"><![CDATA[<p>最后编辑时间: <code>2019-2-15</code> , 持续更新补充</p><p>linux shell 最常用工具介绍. 这些在你编写linux shell脚本的时候拥有非常大的用处. 你的shell脚本水平也与你对这些工具的熟练度直接挂钩.</p><a id="more"></a><h3 id="wc-工具"><a href="#wc-工具" class="headerlink" title="wc 工具"></a><code>wc</code> 工具</h3><p>用作字符统计.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc file</span><br></pre></td></tr></table></figure><p><code>wc</code> 命令会显示三个数字和文件名.<br>实例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wc .vimrc</span><br><span class="line">273  865 8549 .vimrc</span><br></pre></td></tr></table></figure><p>可以看到这里由三个数字, 第一个数字表示文件行数, 第二个数字表示单词数, 第三个表示字符数.最后一个是文件名. 所以这个例子显示了 <em>.vimrc</em> 这个文件共有 273 行, 865 个单词, 8549 个字符. 统计结果来自 <em>.vimrc</em>这个文件.</p><h3 id="使用-cat-显示文件内容"><a href="#使用-cat-显示文件内容" class="headerlink" title="使用 cat 显示文件内容"></a>使用 <code>cat</code> 显示文件内容</h3><p>显示文件内容. 是<em>concatenate</em>的缩写, 如果给了多个文件, 那么<code>cat</code>会将两个文件的内容合并起来在输出到标准输出中去.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat files</span><br></pre></td></tr></table></figure><h3 id="使用-cut-提取半结构化文件内容"><a href="#使用-cut-提取半结构化文件内容" class="headerlink" title="使用 cut 提取半结构化文件内容"></a>使用 <code>cut</code> 提取半结构化文件内容</h3><p>用于从数据文件或者命令输出中提取(切出)各种字段.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -cchars file</span><br></pre></td></tr></table></figure><p>其中<code>-cchars</code>可以是</p><table><thead><tr><th>符号</th><th>含义</th><th>总结</th></tr></thead><tbody><tr><td><code>-c1</code></td><td>提取每行的第一个字符</td><td><code>-cnum</code></td></tr><tr><td><code>-c1,3,5</code></td><td>提取每行的第一,三,五个字符</td><td><code>-cnum1,num2,num3...</code></td></tr><tr><td><code>-c1-4</code></td><td>提取每行的第一到四个字符</td><td><code>-cnum1-num2</code></td></tr><tr><td></td><td>提取从<code>num1</code>到行尾的所有字符</td><td><code>-cnum1-</code></td></tr></tbody></table><p>上面的足以应对一般需求了,但是如果一个文件不是那么规则的话或许需要一些额外的支持才行.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -ddchar -ffield file</span><br></pre></td></tr></table></figure><p>其中, <code>dchar</code>是分隔字符, <code>field</code>是由分隔字符分隔出来的一个个段, 其格式和<code>-c</code>选项一样.</p><blockquote><p>如果在没有指定<code>-d</code>选项的情况下使用<code>-f</code>, 那么分隔符就是<strong>制表符</strong>.</p></blockquote><h3 id="paste-与-cut-搭配使用"><a href="#paste-与-cut-搭配使用" class="headerlink" title="paste 与 cut 搭配使用"></a><code>paste</code> 与 cut 搭配使用</h3><p>用于合并行, 与<code>cut</code>相反.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste files</span><br></pre></td></tr></table></figure><p><code>paste</code>后面可以跟随多个文件名, 结果就是将每个文件中的对应行合并起来. 默认分隔符是<strong>制表符</strong>.如果想要更改分隔符可以使用<code>-d</code>选项. 命令格式为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste -dchars file1 file2 file3 ...</span><br></pre></td></tr></table></figure><p>其中, <code>chars</code>是多个字符, 每个字符分别分隔依次序的文件. 就是第一个字符分隔<code>file1</code>和<code>file2</code>, 第二个字符分隔<code>file2</code>和<code>file3</code>, 其余以此类推.</p><p>同时使用<code>-s</code>选项,将一个文件中的所有行合并.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste -s file</span><br></pre></td></tr></table></figure><h3 id="流编辑器-sed"><a href="#流编辑器-sed" class="headerlink" title="流编辑器 sed"></a>流编辑器 <code>sed</code></h3><p>是<strong>stream editor</strong>(流编辑器)的简称.一般用法如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed command file</span><br></pre></td></tr></table></figure><p><code>sed</code> 不会修改原始的文件, 只会把结果输出到标准输出.</p><p>具体的用法另起一个笔记.</p><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a><code>tr</code></h3><p>用作于过滤器,转换标准输入中的字符.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr fromchars tochars</span><br></pre></td></tr></table></figure><p>同样的, <code>tr</code>不会修改原始文件. 其中, 字符可以使用八进制来表示. <code>\xxx</code>.</p><table><thead><tr><th>tr 命令</th><th>含义</th></tr></thead><tbody><tr><td><code>tr &#39;[a-z]&#39; &#39; &#39;</code></td><td>将小写字母转换成空格</td></tr><tr><td><code>tr &#39;[a-z][A-Z]&#39; &#39;[A-Z][a-z]&#39;</code></td><td>将大写字母转换成小写字母, 将小写字母转换成大写字母</td></tr></tbody></table><p><code>-s</code>选项用来将连续出现的字符替换成一个单一的字符. <code>-d</code>选项用于删除输入流中的</p><h3 id="grep-文件搜索"><a href="#grep-文件搜索" class="headerlink" title="grep 文件搜索"></a><code>grep</code> 文件搜索</h3><p>神器,不解释.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep pattern files</span><br></pre></td></tr></table></figure><blockquote><p>待补充</p></blockquote><h3 id="使用-sort-对内容进行排序"><a href="#使用-sort-对内容进行排序" class="headerlink" title="使用 sort 对内容进行排序"></a>使用 <code>sort</code> 对内容进行排序</h3><p>用于给输入的内容排序.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort file</span><br></pre></td></tr></table></figure><p><code>-u</code>选项,消除重复的行. <code>-r</code>选项逆序排列. <code>-o</code>选项指定输出文件. <code>-n</code>将行中的第一个字段视为数字进行排序. <code>-knumn</code> 选项表示从第<code>num</code>个字段开始排序. <code>-t</code>选项制定各个字段的分隔符.</p><h3 id="uniq-过滤器"><a href="#uniq-过滤器" class="headerlink" title="uniq 过滤器"></a><code>uniq</code> 过滤器</h3><p>用于查找或者删除文件中的重复行.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq inputfile outputfile</span><br></pre></td></tr></table></figure><p><code>-d</code>选项用于找出重复的行. <code>-c</code>选项统计出现的次数.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后编辑时间: &lt;code&gt;2019-2-15&lt;/code&gt; , 持续更新补充&lt;/p&gt;
&lt;p&gt;linux shell 最常用工具介绍. 这些在你编写linux shell脚本的时候拥有非常大的用处. 你的shell脚本水平也与你对这些工具的熟练度直接挂钩.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="linux shell" scheme="https://memorytoco.github.io/Lago/tags/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title>vim寄存器简明介绍</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/15/vim-register/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/15/vim-register/</id>
    <published>2019-02-14T21:34:12.000Z</published>
    <updated>2019-02-14T13:56:26.828Z</updated>
    
    <content type="html"><![CDATA[<p>最后编辑时间: <code>2019-2-14</code> , 之后会添加具体的例子.</p><p>最近再次深入一下<code>vim</code>, 这次复习了一下<code>vim</code>的寄存器.</p><p><code>vim</code>寄存器属于那种没用过几乎不用但一用过就再也离不开的角色, 在<code>vim</code>里面, 寄存器不仅与插件有无限的可能, 而且就算不借助任何插件, 只是使用好这些寄存器也会使你在<code>vim</code>的编辑效率提高一个档次.</p><p>物超所值, 值的学习!</p><p>这次就将我复习的内容分享出来啦!</p><a id="more"></a><p>概览</p><p>使用<code>:dis</code>或者不带参数的<code>:reg</code>命令显示所有的寄存器以及储存的值. 使用<code>:reg</code>后跟复数个寄存器的名字来显示寄存器中的内容.</p><table><thead><tr><th>寄存器名</th><th>作用</th></tr></thead><tbody><tr><td><code>&quot;&quot;</code></td><td>无名寄存器</td></tr><tr><td><code>&quot;0 - &quot;9</code></td><td>10个数字寄存器</td></tr><tr><td><code>&quot;-</code></td><td>小型删除寄存器</td></tr><tr><td><code>&quot;a - &quot;z</code>, <code>&quot;A -&quot;Z</code></td><td>26个字母寄存器</td></tr><tr><td><code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code></td><td>三个只读寄存器</td></tr><tr><td><code>&quot;#</code></td><td>备用文件寄存器</td></tr><tr><td><code>&quot;=</code></td><td>表达式寄存器</td></tr><tr><td><code>&quot;*</code>, <code>&quot;+</code>, <code>&quot;~</code></td><td>选中丢弃寄存器</td></tr><tr><td><code>&quot;_</code></td><td>黑洞寄存器</td></tr><tr><td><code>&quot;/</code></td><td>最后的搜索的pattern</td></tr></tbody></table><h3 id="t-与-m-文本命令"><a href="#t-与-m-文本命令" class="headerlink" title=":t 与 :m 文本命令"></a><code>:t</code> 与 <code>:m</code> 文本命令</h3><p><code>:co</code>, <code>:copy</code> 命令<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[<span class="built_in">range</span>]<span class="keyword">co</span>[<span class="keyword">py</span>] &#123;address&#125;</span><br></pre></td></tr></table></figure></p><p>将<code>[range]</code>内的内容复制到<code>{address}</code>行下. <code>:t</code>与这两个同义.</p><blockquote><p><code>[range]</code>可以是<code>num1,num2</code>,表示从<code>num1</code>到<code>num2</code>的行. 也可以是特殊的表示行号的字符, 由<code>,</code>分隔. <code>{address}</code>表示一个行的地址, 初步使用可以指定一个行号. 更多的内容请看之后的<code>vim</code>系列的<strong>特殊记号</strong>说明吧. :)</p></blockquote><hr><p><code>:m</code>, <code>mo</code>, <code>move</code>命令<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[<span class="built_in">range</span>]<span class="keyword">m</span>[ove] &#123;address&#125;</span><br></pre></td></tr></table></figure></p><p>将<code>[range]</code>内的内容移动到<code>{address}</code>行下.</p><h3 id="无名寄存器-quot-quot"><a href="#无名寄存器-quot-quot" class="headerlink" title="无名寄存器 &quot;&quot;"></a>无名寄存器 <code>&quot;&quot;</code></h3><p>vim将<code>d</code>,<code>c</code>,<code>s</code>,<code>x</code>这些动作或者<code>y</code>指令操作的内容存放到无名寄存器中, 且无论在进行这些操作的时候是否指定特殊的寄存器, 无名寄存器中的内容总会这这些指令操作的内容. </p><blockquote><p>实际上, 无名寄存器总是指向一个有名寄存器, 且它的内容和这个有名寄存器中的一样.</p></blockquote><p>唯一的特例就是黑洞寄存器<code>&quot;_</code>, 如果进行动作的时候指定了黑洞寄存器, 那么操作的内容不会存到任何寄存器中.</p><p>无名寄存器中的内容用于任何的<strong>粘贴</strong>命令如<code>p</code>. 还有一个就是, 如果我们特别指定<code>&quot;&quot;</code>无名寄存器的话, 写入无名寄存器中的内容也会同时写入<code>&quot;0</code>寄存器中.</p><h3 id="数字寄存器-quot-0-quot-9"><a href="#数字寄存器-quot-0-quot-9" class="headerlink" title="数字寄存器 &quot;0 - &quot;9"></a>数字寄存器 <code>&quot;0 - &quot;9</code></h3><p><code>&quot;0</code>寄存器存储最后的<code>y</code>命令yank的内容, 如果在yank的时候指定了其他的寄存器, 那么<code>&quot;0</code>寄存器中的内容不更新.</p><p><code>&quot;1</code>寄存器存储绝大多数最后删除的内容, 除非指定了其他的寄存器. 如果删除的内容小于一行的话, 使用小型删除寄存器<code>&quot;-</code>. 一个例外就是, 如果删除的命令使用了这些<code>%</code>,<code>(</code>,<code>)</code>,<code>`</code>,<code>/</code>,<code>?</code>,<code>n</code>,<code>N</code>,<code>{</code>,<code>}</code>动作指令, 那么<code>&quot;1</code>寄存器的内容总会被更新为这些新的内容. 同时,如果删除的内容在一行之内的话, <code>&quot;-</code>也会被使用到.<br>每次的删除都会使数字寄存器的内容向后推移.  vim会将原来<code>&quot;1</code>的内容传给<code>&quot;2</code>, 再将原来<code>&quot;2</code>的内容传给<code>&quot;3</code>, 如此下去, 并且丢弃原来<code>&quot;9</code>中的内容.</p><h3 id="小型删除寄存器-small-delete-register-quot"><a href="#小型删除寄存器-small-delete-register-quot" class="headerlink" title="小型删除寄存器(small delete register) &quot;-"></a>小型删除寄存器(small delete register) <code>&quot;-</code></h3><p>这个寄存器存储所有小于一行的删除操作, 除非在删除的时候指定了寄存器.</p><h3 id="有名字母寄存器-quot-a-quot-z-quot-A-quot-Z"><a href="#有名字母寄存器-quot-a-quot-z-quot-A-quot-Z" class="headerlink" title="有名字母寄存器 &quot;a - &quot;z , &quot;A - &quot;Z"></a>有名字母寄存器 <code>&quot;a - &quot;z</code> , <code>&quot;A - &quot;Z</code></h3><p>这些寄存器只有在被指定的时候才会被用到. 小写字母寄存器<code>&quot;a - &quot;z</code>会替换原先的内容, 大写字母寄存器<code>&quot;A - &quot;Z</code>会将内容附加到原先的寄存器中. 当 <code>&gt;</code> 标志被放到 <code>cpoptions</code>时, 在附加内容之前总会插入一个换行符.</p><h3 id="只读寄存器-quot-quot-quot"><a href="#只读寄存器-quot-quot-quot" class="headerlink" title="只读寄存器 &quot;:, &quot;., &quot;%"></a>只读寄存器 <code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code></h3><p>这些寄存器只能只能通过<code>p</code>,<code>P</code>,<code>:put</code>和<code>CTRL-R</code>使用.</p><p><code>&quot;.</code>寄存器包含最后在插入模式下插入的内容.</p><p><code>&quot;%</code>寄存器包含这当前打开的文件名.</p><p><code>&quot;:</code>寄存器包含着最后输入的命令行命令. 可以使用<code>@:</code>来执行最后执行过的命令. 注意, 只有在命令行中执行的命令才会被记录, 也就是说如果是通过按键映射执行的命令将不会被记录.</p><h3 id="备用文件寄存器-quot"><a href="#备用文件寄存器-quot" class="headerlink" title="备用文件寄存器 &quot;#"></a>备用文件寄存器 <code>&quot;#</code></h3><p><code>&quot;#</code>寄存器保存当前窗口备用文件的名字, 它会影响<code>CTRL-^</code>的工作方式. 一个备用文件往往是之前编辑过的文件, 所以可以用这个<code>:e #</code>再两个文件之间快速跳转, 与之有相同功能的是<code>CTRL-^</code>组合键. 比如, 你先打开了<code>file1</code>文件, 然后发现更改了<code>file1</code>的内容后需要更改<code>file2</code>文件, 于是又通过<code>:e file2</code>来打开<code>file2</code>. 在更改的过程中突然发现原来的<code>file1</code>文件有错误, 于是此时就可以<code>CTRL-^</code>切回<code>file1</code>继续编辑. 编辑完了后再次<code>CTRL-^</code>切回<code>file2</code>继续更改.</p><blockquote><p>这个寄存器是可写的. 所以通过一些插件的支持, 或许可以维系一个特别高效的编辑模式.</p></blockquote><h3 id="表达式寄存器-quot"><a href="#表达式寄存器-quot" class="headerlink" title="表达式寄存器 &quot;="></a>表达式寄存器 <code>&quot;=</code></h3><p>当键入<code>&quot;=</code>或者<code>CTRL-R</code>时, 光标会跑到命令行中去. 在那里, 你可以键入任意的表达式, 使用<code>&lt;CR&gt;</code>键结束输入, 使用<code>&lt;ESC&gt;</code>键放弃输入, 如果留空, 那么执行上一次的命令. 然后结果会被转换成字串储存起来. 如果<code>&quot;=</code>被用到<code>p</code>命令上去, 那么其内容会被自动加上一个换行符.</p><h3 id="选中丢弃寄存器-selection-and-drop-register-quot-quot-quot"><a href="#选中丢弃寄存器-selection-and-drop-register-quot-quot-quot" class="headerlink" title="选中丢弃寄存器(selection and drop register) &quot;*,&quot;+,&quot;~"></a>选中丢弃寄存器(selection and drop register) <code>&quot;*</code>,<code>&quot;+</code>,<code>&quot;~</code></h3><p>这些寄存器是否可用还请亲自实验, 后续补全使用条件.</p><p><code>&quot;+</code>寄存器与系统剪贴板相通, 需要编译支持. 而<code>&quot;*</code>会存储选中的内容. 比如存储通过<code>v</code>选中后又<code>&lt;ESC&gt;</code>取消丢弃掉的内容. 这两个非常好用, 可以自己尝试. 剪贴板的我就不说了, <code>&quot;*</code>这个寄存器只要选中就可以将内容存储到里面去了. <code>&quot;~</code> 暂时不知晓, 有机会后续补充.</p><h3 id="黑洞寄存器-quot"><a href="#黑洞寄存器-quot" class="headerlink" title="黑洞寄存器 &quot;_"></a>黑洞寄存器 <code>&quot;_</code></h3><p>如其名, 它就像一个黑洞一样, 只进不出. 使用它不会对其它寄存器作出影响, 从这个寄存器中也取不出任何内容, 总之, 无事发生.</p><h3 id="搜索模式寄存器-quot"><a href="#搜索模式寄存器-quot" class="headerlink" title="搜索模式寄存器 &quot;/"></a>搜索模式寄存器 <code>&quot;/</code></h3><p><code>&quot;/</code>寄存器保存最后一次搜索的搜索模式(pattern). 这会影响命令<code>n</code>,<code>N</code>和选项<code>hlsearch</code>的工作方式. 它是可写的, 可以使用 <code>:let</code>来赋值, 但是无法通过删除或者yank内容到这个寄存器中.</p><blockquote><p>一个用处就是可以通过改变这个寄存器里的内容来高亮不同的内容.</p></blockquote><h3 id="let-形式"><a href="#let-形式" class="headerlink" title="let-@ 形式"></a><code>let-@</code> 形式</h3><p>使用<code>let @</code>后跟寄存器的名字来对寄存器赋值. 比如<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> @<span class="number">1</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> @/ = <span class="string">"good"</span></span><br><span class="line"><span class="keyword">let</span> @<span class="string">" = "</span><span class="keyword">next</span> value <span class="keyword">to</span> paste<span class="comment">"</span></span><br></pre></td></tr></table></figure></p><p>到此, 寄存器这一方面就差不多啦. 再花些时间琢磨出自己的一套使用方法吧.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后编辑时间: &lt;code&gt;2019-2-14&lt;/code&gt; , 之后会添加具体的例子.&lt;/p&gt;
&lt;p&gt;最近再次深入一下&lt;code&gt;vim&lt;/code&gt;, 这次复习了一下&lt;code&gt;vim&lt;/code&gt;的寄存器.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim&lt;/code&gt;寄存器属于那种没用过几乎不用但一用过就再也离不开的角色, 在&lt;code&gt;vim&lt;/code&gt;里面, 寄存器不仅与插件有无限的可能, 而且就算不借助任何插件, 只是使用好这些寄存器也会使你在&lt;code&gt;vim&lt;/code&gt;的编辑效率提高一个档次.&lt;/p&gt;
&lt;p&gt;物超所值, 值的学习!&lt;/p&gt;
&lt;p&gt;这次就将我复习的内容分享出来啦!&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="vim" scheme="https://memorytoco.github.io/Lago/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>linux 命令行</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/14/shell/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/14/shell/</id>
    <published>2019-02-13T22:50:56.000Z</published>
    <updated>2019-02-15T14:05:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>最后编辑时间: <code>2019-2-15</code>, 更改结构, 继续补充完善例子</p><p>所学习的 shell 语法是<strong>bash</strong>语法. 具体的命令需要查看具体的实现.</p><p>命令行的语法罗列. 快速上手shell.</p><a id="more"></a><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>在一个 shell 脚本文件中的每一行都可以作为单独命令来执行. 换句话说就是在 shell 脚本中的每一行都可以直接在 shell 中输入. shell 就是一个解释器, 类似与 python 解释器.</p><p>shell 使用<code>#</code>来进行行注释, 所有在<code>#</code>之后的内容都会被 shell 忽视.</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>变量名可以以字母或下划线<code>_</code>开头,后面跟上零个或者多个字母数字下划线.</p><p>变量的使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable=value</span><br></pre></td></tr></table></figure><p>即变量名后直接跟<code>=</code>. 注意一点, <code>=</code>两边没有空格, 变量名和值之间直接用<code>=</code>连接. 并且, shell 变量里没有类型的概念, 其所存储的都是字符串.</p><p>要使用变量, 使用<code>$variable</code>的形式, shell 在解释时会将<code>$variable</code>替换成它的值. 然后再执行命令. 如果使用一个没有赋过值的变量, 那它的值为空. 在 shell 解析命令时, 会将为空的值从命令行中删除.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> echo :$emptyvariable:</span><br><span class="line">::</span><br></pre></td></tr></table></figure><p>显示的将一个变量赋空值可以用这些方法:</p><ul><li><code>variable=</code> 直接留空</li><li><code>variable=&#39;&#39;</code> 显示的赋一个空的字串</li><li><code>variable=&quot;&quot;</code> 这样也行</li></ul><p>注意, <code>varialbe=&quot; &quot;</code>这种与上面的不同, 它不是一个空值, 而是将一个空格赋值给了变量.</p><h4 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h4><p>考虑下面一个情景:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> x=*</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">file1 file2 file3</span><br><span class="line"><span class="meta">$</span> echo $x</span><br><span class="line">file1 file2 file3</span><br></pre></td></tr></table></figure><p>通过这里看到的结果, 那肯定是 shell 将<code>*</code>替换成了当前工作目录的内容, 那问题是, 这个替换过程是在什么时候发生的呢? 换句话就是,<code>$x</code>变量的内容是什么?</p><p>在这个例子里, 解释一下<code>echo $x</code>这行. shell 先将<code>*</code>赋值给<code>x</code>. 第一次扫描, 将<code>$x</code>替换成<code>*</code>, 得到<code>echo *</code>, 然后第二次扫描将<code>*</code>替换成当前目录中的内容, 即是<code>echo file1 file2 file3</code>.</p><p>通过我的说明, 应该就知道, shell 在给变量赋值时, 给<code>x</code>的是<code>*</code>, 也就是不会作任何的替换. 作替换的时候发生在对<code>echo $x</code>这句的解释执行上.</p><blockquote><p>shell 在给变量赋值时, 不会作出任何变化, 但是最好将赋值的内容用单引号或者双引号包起来, 因为它的内容会在求值的时候被替换. 上面的例子里, shell 就做了两次替换.</p></blockquote><h4 id="variable-结构"><a href="#variable-结构" class="headerlink" title="${variable} 结构"></a><code>${variable}</code> 结构</h4><p>如果, 只是如果. 你想将<code>file</code>重命名为<code>filex</code>, 并且在学了变量之后, 你想出了一个办法.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> name='file'</span><br><span class="line"><span class="meta">$</span> mv $name $namex</span><br></pre></td></tr></table></figure><p>因为变量的值就是一个字串麻, 这么做应该行的通, 但是这里会出现一个问题. <code>$namex</code>并不会被解释为<code>$name</code>的值再加上一个字符<code>x</code>, 而是作为一个全新的变量解释. 想要避免这种情况, 就需要<code>${variable}</code>结构.</p><p>如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> name='file'</span><br><span class="line"><span class="meta">$</span> mv $name $&#123;name&#125;x</span><br></pre></td></tr></table></figure><p>这样, 结果就对了.</p><h4 id="expr-算术表达式"><a href="#expr-算术表达式" class="headerlink" title="$((expr)) 算术表达式"></a><code>$((expr))</code> 算术表达式</h4><p>在<code>$(())</code>这个操作符中, 可以进行额外的算术操作, 包括赋值.</p><p>可用操作符:</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td><code>-</code></td><td>减号</td></tr><tr><td><code>~</code></td><td>按位取反</td></tr><tr><td><code>!</code></td><td>逻辑反</td></tr><tr><td><code>*</code>, <code>/</code>, <code>%</code></td><td>乘, 除, 取余</td></tr><tr><td><code>+</code>, <code>-</code></td><td>加, 减</td></tr><tr><td><code>&lt;&lt;</code> , <code>&gt;&gt;</code></td><td>左移, 右移</td></tr><tr><td><code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code></td><td>小于等于,大于等于,小于,大于</td></tr><tr><td><code>==</code>, <code>!=</code></td><td>等于, 不等于</td></tr><tr><td><code>&amp;</code></td><td>按位与</td></tr><tr><td><code>^</code></td><td>按位异或</td></tr><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td></tr><tr><td><code>expr1 ? expr2 : expr3</code></td><td>条件运算符</td></tr><tr><td><code>=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code></td><td></td></tr><tr><td><code>+=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code></td><td></td></tr><tr><td><code>&amp;=</code>, <code>^=</code></td></tr></tbody></table><p>还有 <code>|</code> 按位或, 和 <code>||</code> 逻辑或, 以及 <code>|=</code>.</p><p>其中, <code>++</code>,<code>--</code>与<code>sizeof</code>跟具体的 shell 实现有关. 这里面的操作可以用变量, 变量必须可以解析成数字, 两边可以有空格. 同时, 如果变量未定义, 它被解释成<code>0</code>, 变量不一定要使用<code>$</code>来修饰.</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>shell 中有四种不同的引用字符: <code>&#39;</code>, <code>&quot;</code>, <code>\</code>, <code>`</code>.</p><p>由于这些都是和字串有关的, 所以这里说明一下. 基本上, shell 里面的东西都是字符串, 即使你不加这些引用, 你所输入的依然是字符串. 如果你加入了这些引用, 那么 shell 也会进行处理, 从而保证传给程序的是一个不带引用的字符串.那么, 如何传入一个带引用的字符串呢. 问得好, 这就是这一节的作用.</p><p>一个思想, 这些引用都是为了构建某个比较特殊的字符串. 比如一个<code>&#39;Hello World&#39;</code>, 这样一个带有<code>&#39;</code>的字符串.</p><p>shell 是以空白字符作为分隔符的. 这么说的意思是要明白 shell 在进行字符替换的时候并不会因为命令的不同而不同的对待字符串的替换. 同时, shell 的执行模式依旧是<code>command args</code>, 命令名作为第一个字符串, 参数通过空白字符分隔, 分别传入命令中. 以上引用的最大作用就是, 让一个<strong>特殊字串</strong>作为一个单个参数传入命令中去.</p><p>很多的奇怪问题都是因为将字串展开后误作为多个参数传给了命令. 而这些引用的难点也就是在这里.</p><h4 id="使用-39-防止字符串展开"><a href="#使用-39-防止字符串展开" class="headerlink" title="使用 &#39; 防止字符串展开"></a>使用 <code>&#39;</code> 防止字符串展开</h4><p>所有在<code>&#39;</code>里面的东西都不会被 shell 展开, 甚至是<code>Enter</code>键.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> x='Hello World'</span><br><span class="line"><span class="meta">$</span> echo '$x'</span><br><span class="line"><span class="meta">$</span>x</span><br></pre></td></tr></table></figure><h4 id="使用-quot-对字符串展开进行部分限制"><a href="#使用-quot-对字符串展开进行部分限制" class="headerlink" title="使用 &quot; 对字符串展开进行部分限制"></a>使用 <code>&quot;</code> 对字符串展开进行部分限制</h4><p>有三个特殊字符不会在<code>&quot;</code>被忽视: <code>$</code>, <code>`</code>, <code>\</code>.</p><p>在<code>&quot;</code>里面使用<code>$</code>能够完成变量名的替换, <code>\</code>来完成对特殊字符的转义.</p><h4 id="使用-来完成命令替换"><a href="#使用-来完成命令替换" class="headerlink" title="使用 ` 来完成命令替换"></a>使用 <code>`</code> 来完成命令替换</h4><p>在<code>`</code>中, 里面的字串会被识别为一个新的命令, 执行它之后将其的值代替这个字符串. 此方法不建议使用. 只做兼容性考虑.</p><h4 id="结构"><a href="#结构" class="headerlink" title="$() 结构"></a><code>$()</code> 结构</h4><p>和<code>`</code>一样, 这个是作为它的替代品出现. <code>$()</code>不仅比<code>`</code>更加容易识别, 也更加容易进行命令的嵌套. 同时在其中可以完整的使用命令行的力量. 比如管道.</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><h4 id="特殊变量-0-9"><a href="#特殊变量-0-9" class="headerlink" title="特殊变量$0-9"></a>特殊变量<code>$0-9</code></h4><p>如果有一个独立的 shell 脚本, 那么这个脚本可以通过一个叫做位置参数的特殊变量来接受命令行参数. 这些变量记为<code>$num</code>, <code>num</code>为<code>0-9</code>的数字. <code>$0</code> 默认为执行的脚本名称. 而<code>$1-9</code>为第一个, 第二个等等一直到第九个参数.</p><p>可以通过如下来验证:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> echo $1</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> echo $0</span><br><span class="line">bash</span><br></pre></td></tr></table></figure><h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量$#"></a>特殊变量<code>$#</code></h4><p><code>$#</code> 包含了命令行中输入的参数的个数.</p><h4 id="特殊变量-与"><a href="#特殊变量-与" class="headerlink" title="特殊变量$*与$@"></a>特殊变量<code>$*</code>与<code>$@</code></h4><p><code>$*</code> 包含了命令行中所有的参数. <code>$@</code> 与 <code>$*</code>类似, 但是在替换时, 对于<code>$*</code>, 直接用<code>$1 $2 ..</code>替换, 如果是<code>&quot;$*&quot;</code>的形式, 则会替换成 <code>&quot;$1 $2 $3 ...&quot;</code>这样. 但是对于<code>&quot;$@&quot;</code>来说, 会变成<code>&quot;$1&quot; &quot;$2&quot; ...</code>.</p><h4 id="n-特殊技法"><a href="#n-特殊技法" class="headerlink" title="${n} 特殊技法"></a><code>${n}</code> 特殊技法</h4><p>如果你传入的参数超过了 9 个, 那么可以使用上面的<code>${n}</code>技法来访问第<code>10</code>个及之后的参数.</p><h4 id="shift-命令"><a href="#shift-命令" class="headerlink" title="shift 命令"></a><code>shift</code> 命令</h4><p>如果执行<code>shift</code>, 那么位置变量的内容会左移. 同时<code>$1</code>中的内容被丢弃, <code>$#</code>减一.</p><p><code>shift n</code> 可以<code>shift</code> <code>n</code>次, 等价于执行<code>n</code>次<code>shift</code>命令.</p><hr><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p>一般格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if command_t</span><br><span class="line">then</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">else</span><br><span class="line">  command3</span><br><span class="line">  command4</span><br><span class="line">  ...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其中<code>else</code>可以省去. <code>command_t</code> 是测试条件命令, 返回一个状态码. 如果状态码为<code>0</code>, 那么执行<code>command1</code>等语句, 若<code>else</code>没有省去, 那么执行<code>command3</code>等语句, 若省去了, 则跳过. 状态码是命令执行后返回的一个整数数字, 如果非零则为异常状态, 具体是错误还是警告由程序自己决定. 如果是<code>0</code>, 则总是表示执行成功, 正常退出. 在管道中, 最后一个命令返回的状态码作为整个管道的状态码. 可以使用<code>$?</code>来获得最后一条命令退出的状态.</p><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if command_t1</span><br><span class="line">then</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">elif command_t2</span><br><span class="line">then</span><br><span class="line">  command3</span><br><span class="line">  command4</span><br><span class="line">  ...</span><br><span class="line">else</span><br><span class="line">  command5</span><br><span class="line">  command6</span><br><span class="line">  ...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>这里多出了<code>elif ... then ...</code>语句. 可以有任意个<code>elif then</code>. 如果<code>command_t1</code>结果为假, 继续求值<code>command_t2</code>, 结果为真则执行<code>command3</code>等语句, 如果为假且还有<code>elif then</code>语句, 重复上面的操作, 如果没有了, 则执行<code>else</code>后面的语句.</p><hr><p><code>/dev/null</code> 是一个特殊的设备, 在脚本中通常用于管道消除不想要的结果. 比如消去<code>grep</code>命令的显示结果, 只需要它的返回状态, 就使用<code>grep pattern file &gt; /dev/null</code>.</p><hr><p><code>test expression</code> , <code>test</code>命令会对<code>expression</code>求值, 如果结果为真, 返回<code>0</code>, 如果结果为假, 返回非零的退出状态码.</p><table><thead><tr><th>字符串操作符</th><th>含义</th></tr></thead><tbody><tr><td>string1 <code>=</code> string2</td><td>string1 等于 string2</td></tr><tr><td>string1 <code>!=</code> string2</td><td>string1 不等于 string2</td></tr><tr><td>string</td><td>string 不为空</td></tr><tr><td><code>-n</code> string</td><td>string 不为空</td></tr><tr><td><code>-z</code> string</td><td>string 为空</td></tr></tbody></table><blockquote><p>最好将测试的字符串用双引号来引用, 避免空字串被命令行删除的情况.</p></blockquote><p>在 shell 脚本中, 常常使用它的简写 <code>[ expression ]</code>, 这样就会使脚本更加明朗.</p><hr><p><code>test</code>也能对数字进行比较操作.</p><table><thead><tr><th>数字操作符</th><th>含义</th></tr></thead><tbody><tr><td>int1 <code>-eq</code> int2</td><td>int1 等于 int2</td></tr><tr><td>int1 <code>-ne</code> int2</td><td>int1 不等于 int2</td></tr><tr><td>int1 <code>-gt</code> int2</td><td>int1 大于 int2</td></tr><tr><td>int1 <code>-lt</code> int2</td><td>int1 小于 int2</td></tr><tr><td>int1 <code>-ge</code> int2</td><td>int1 大于等于 int2</td></tr><tr><td>int1 <code>-le</code> int2</td><td>int1 小于等于 int2</td></tr></tbody></table><hr><p><code>test</code>也能对文件进行判断操作.</p><table><thead><tr><th>文件操作符</th><th>含义</th></tr></thead><tbody><tr><td><code>-d</code> file</td><td>file 是一个目录</td></tr><tr><td><code>-e</code> file</td><td>file 存在</td></tr><tr><td><code>-f</code> file</td><td>file 是一个普通文件</td></tr><tr><td><code>-r</code> file</td><td>file 可读取</td></tr><tr><td><code>-s</code> file</td><td>file 不是空文件</td></tr><tr><td><code>-w</code> file</td><td>file 可写</td></tr><tr><td><code>-x</code> file</td><td>file 可执行</td></tr><tr><td><code>-L</code> file</td><td>file 是一个符号链接</td></tr></tbody></table><hr><p><code>test</code> 逻辑操作符.</p><table><thead><tr><th>操作符</th><th>作用</th></tr></thead><tbody><tr><td><code>!</code></td><td>逻辑否定操作符, 可以放在任意的表达式之前, 否定该表达式的结果</td></tr><tr><td><code>-a</code></td><td>逻辑与, 放在两个表达式之间, 执行逻辑与</td></tr><tr><td><code>-o</code></td><td>逻辑或, 放在两个表达式之间, 执行逻辑或</td></tr></tbody></table><p><code>test</code> 可以使用<code>()</code>来改变求值顺序, 不过需要用<code>\</code>来转义, 避免被shell解释. 括号可以放在表达式两边并且括号需要作为一个独立的参数传给<code>test</code>, 这就意味着每个括号两边需要使用空格与其它参数分离.</p><h4 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a><code>case</code> 语句</h4><p>一般格式如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">case value in</span><br><span class="line">pattern1 )</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandn;;</span><br><span class="line">pattern2 )</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandn;;</span><br><span class="line">...</span><br><span class="line">patternn )</span><br><span class="line">    ...</span><br><span class="line">    commandn;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><p>不必多说, <code>case</code>将<code>value</code>与每个<code>pattern</code>进行匹配, 如果匹配成功, 那么执行其下面的一系列命令. 如果什么都不匹配, 不做任何事情. <code>pattern</code>与<code>)</code>之间可以没有空格.</p><p>同时, <code>pattern</code>也可以使用<strong>通配符</strong>. <code>?</code>匹配任意一个字符, <code>*</code>匹配零个或多个任意字符, <code>[ ... ]</code>则匹配其中出现的字符. 这个在命令行中的一样. 同时可以使用<code>|</code>. <code>pattern1 | pattern2 )</code>, 这个表示满足<code>pattern1</code>或者满足<code>pattern2</code>都会执行这里的命令. <code>|</code>效果等同于逻辑<strong>或</strong>.</p><h4 id="空语句"><a href="#空语句" class="headerlink" title="空语句:"></a>空语句<code>:</code></h4><p>正如你所想的那样, 这是一个空语句, 相当于<code>c</code>中的单个<code>;</code>. 它可以被认为是命令的占位符, 在某些要求必须有命令的地方而你又不希望执行什么操作的时候, 可以使用<code>:</code>. 最好在<code>:</code>附近加上注释.</p><h4 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp; 和 ||"></a><code>&amp;&amp;</code> 和 <code>||</code></h4><p>这两个操作符可以通过判断之前执行命令的退出状态来决定是否执行接下来的命令, 如此往复.</p><p><code>command1 &amp;&amp; command2 &amp;&amp; ... &amp;&amp; commandn</code> 这种形式会先执行<code>command1</code>. 如果其退出的状态码为<code>0</code>, 那么执行<code>command2</code>, 如果不是<code>0</code>, 那么跳过接下来所有的命令. 对于接下来的命令, 重复之前的判断操作.</p><p><code>||</code>的效果与<code>&amp;&amp;</code>正好相反. 如果前一个命令正常退出的话, 结束. 否则执行后面的命令.</p><h4 id="exit-n-语句"><a href="#exit-n-语句" class="headerlink" title="exit n 语句"></a><code>exit n</code> 语句</h4><p>使用 <code>exit n</code>来从任意的地方退出脚本. 返回<code>n</code>状态码. 如果<code>n</code>被省去了, <code>exit</code> 相当于 <code>exit $?</code>.</p><hr><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>循环可以按照特定的次数或者终止条件执行一组命令. 有<code>for</code>, <code>while</code>, <code>until</code> 这三个命令.</p><h4 id="for命令"><a href="#for命令" class="headerlink" title="for命令"></a><code>for</code>命令</h4><p>一般形式:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for var in word1 word2 ... wordn</span><br><span class="line">do</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p><code>do</code>和<code>done</code>之间的称作<strong>循环体</strong>, 在执行时, 首先把<code>word1</code>赋值给<code>var</code>, 执行循环体, 再把<code>word2</code>赋值给<code>var</code>, 执行循环体, 如此往复一直到<code>wordn</code>.</p><p><code>for</code>也可以不带字符列表.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for var</span><br><span class="line">do</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>那么<code>for</code>会自动遍历命令行中的参数.</p><h4 id="while命令"><a href="#while命令" class="headerlink" title="while命令"></a><code>while</code>命令</h4><p>一般形式:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while command_t</span><br><span class="line">do</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>如果<code>command_t</code>返回<code>0</code>, 那么执行循环体中的内容. 执行后再次执行<code>command_t</code>, 执行循环体. 如此循环, 直到<code>command_t</code>返回了一个非<code>0</code>状态码. 如果一开始<code>command_t</code>返回非零状态码, 循环体一次都不会执行.</p><h4 id="until命令"><a href="#until命令" class="headerlink" title="until命令"></a><code>until</code>命令</h4><p>一般形式:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">until command_t</span><br><span class="line">do</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>和<code>while</code>类似, 但是相反.  当<code>command_t</code>返回<code>0</code>时, 循环体不执行, 否则执行循环体, 执行逻辑与<code>while</code>一致.</p><h4 id="循环的后台执行-done-amp"><a href="#循环的后台执行-done-amp" class="headerlink" title="循环的后台执行 done &amp;"></a>循环的后台执行 <code>done &amp;</code></h4><p>只要在<code>done</code>后边添加一个<code>&amp;</code>就可以是循环后台运行.</p><h4 id="闭合语句fi-done-esac的管道重定向"><a href="#闭合语句fi-done-esac的管道重定向" class="headerlink" title="闭合语句fi,done,esac的管道重定向"></a>闭合语句<code>fi</code>,<code>done</code>,<code>esac</code>的管道重定向</h4><p>在闭合语句后边可以使用管道与重定向. 重定向会改变代码块中所有命令的输入输出.</p><h4 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a><code>break</code> 与 <code>continue</code></h4><p><code>break</code> 用于退出循环, <code>break n</code>用于退出<code>n</code>层循环.<br><code>continue</code>用于跳过循环, <code>continue n</code>用于跳过<code>n</code>次循环.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后编辑时间: &lt;code&gt;2019-2-15&lt;/code&gt;, 更改结构, 继续补充完善例子&lt;/p&gt;
&lt;p&gt;所学习的 shell 语法是&lt;strong&gt;bash&lt;/strong&gt;语法. 具体的命令需要查看具体的实现.&lt;/p&gt;
&lt;p&gt;命令行的语法罗列. 快速上手shell.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="linux shell" scheme="https://memorytoco.github.io/Lago/tags/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title>博客功能说明</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/12/blogIntro/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/12/blogIntro/</id>
    <published>2019-02-11T23:36:26.000Z</published>
    <updated>2019-02-14T13:52:01.600Z</updated>
    
    <content type="html"><![CDATA[<p>简要的说明一下辅助博客的文章类别以及其作用吧.<br>如果使用结果不错的话, 就将它搬到<code>Lasga</code>中去.<br>最主要的也是方便阅读这个博客的人.</p><a id="more"></a><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>这篇博客的所有由文章暂分三类, 分别是<strong>笔记</strong>, <strong>漫谈</strong>, <strong>教程</strong>.</p><p>所有的笔记都是跟随一本书随阅读进度进行更新的, 内容主要是针对一些我觉得比较关键的点的罗列, 可能会附加一些个人的思考. 笔记自有一套自己的更新规则, 一般不会跟随书的目录章节更新, 而是受到自己的学习进程影响, 有时可能会针对某一个点额外的发布文章, 届时会在笔记中加入链接.</p><blockquote><p><code>笔记不一定十分准确</code>, 但会一直更新. 已发布的也会更新. 毕竟个人知识总会有差错, 随着个人经验的积累也会有进步嘛. 这个笔记是跟着我本地的笔记更新的, 一旦我有了比之前更加深刻的认识, 就会去更新笔记.</p></blockquote><blockquote><p>现在会在笔记开头部分写下更新时间. 以供参考.</p></blockquote><p>漫谈则如其名, 主题不明, 谈谈对于一些技术, 对于计算机科学理论的理解等等…</p><blockquote><p>已发布的漫谈一般不会再更新, 如有错误, 会另起一篇来说明.</p></blockquote><p>教程往往是有关一个主题的, 拥有一个唯一的<em>tag</em>, 可以在<em>tags</em>一栏中选择来进行阅读.具体的信息会在教程中进行发布.</p><blockquote><p>教程会随时间动态更新.</p></blockquote><h3 id="关于更新"><a href="#关于更新" class="headerlink" title="关于更新"></a>关于更新</h3><p>会有更新的文章或者会持续更新的文章会有一个 <strong>最后编辑时间</strong> 的标签, 一般在预览界面就能看到, 后面跟着最后的更新时间和一些简短的关于这篇文章的信息.</p><p>有的文章可能不会有这种标签但仍在更新中, 这类一般是博客的规则类内容, 比如你正在阅读的一篇.</p><p>以上…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简要的说明一下辅助博客的文章类别以及其作用吧.&lt;br&gt;如果使用结果不错的话, 就将它搬到&lt;code&gt;Lasga&lt;/code&gt;中去.&lt;br&gt;最主要的也是方便阅读这个博客的人.&lt;/p&gt;
    
    </summary>
    
    
      <category term="MISC" scheme="https://memorytoco.github.io/Lago/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>真象还原之零</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/10/truthaboutSys_0/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/10/truthaboutSys_0/</id>
    <published>2019-02-09T22:13:01.000Z</published>
    <updated>2019-02-14T13:52:18.303Z</updated>
    
    <content type="html"><![CDATA[<p>最后编辑时间: <code>2019-2-12</code></p><p>这个是阅读<strong>操作系统真象还原</strong>的笔记. 记录学习系统一些知识点.<br>同时和<strong>深入理解计算机操作系统</strong>一起. 希望学完系统能让我更加方便的学习汇编与二进制.</p><a id="more"></a><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>常见 cpu 字节序:</p><ul><li>大端字节序: <code>IBM, Sun, PowerPC</code></li><li>小端字节序: <code>x86, DEC</code><blockquote><p><code>ARM</code> 系的大小通吃<br>网络字节序是大端字节序</p></blockquote></li></ul><hr><p>指令集与微架构:</p><p>对于指令集来说有两种指令体系, 分别是<code>CISC</code>和<code>RISC</code>两个.指令集则是类似于协议的存在.AMD 和 Intel使用同一种指令集,但是他们各自对于cpu的硬件实现不同,而这个<em>硬件实现</em>就称之为<em>微架构</em>.</p><p>目前存在的指令集共有5种, 分别是 <code>x86(Intel), ARM, MIPS, Power, C6000</code>.其中只有<code>x86</code>是是属于CISC体系的.</p><hr><p>整个系统的启动过程简述(个人理解):</p><p>电源通电后, 硬件开机自检. 硬件是如何知道这时候需要自检的呢? 是<strong>BIOS</strong>通知它们的.<strong>BIOS</strong> 如上所述, 是基本的输入输出系统. 没有太多的功能, 它的目的就是为了在整个开机接力赛中传递这第一棒. 在通知个硬件自检后, 它就会将接力棒传给<strong>MBR</strong>. <strong>MBR</strong>就是主引导程序. 如果折腾过linux, 那么可以把这个<strong>GRUB</strong>想象成<strong>MBR</strong>. 这么说或许就清楚点了.随后<strong>MBR</strong>会寻找<strong>OBR</strong>, 将主导权交给对应系统的引导程序. 可以把grup上的一些系统选项想象成系统引导程序. 最后, 主导权再由<strong>OBR</strong>交接给系统内核. 至此, 系统就正常启动啦.</p><blockquote><p>如果你不仅折腾过linux, 还想过把它和windows一起装在机器里, 那么你一定会使用双启动这方案. 折腾过双系统的人一定会碰到过这种情况:</p></blockquote><blockquote><p>在把linux安装完成后, 开机就是grub, windows则消失不见了. 如果需要再次引导windows则需要配置一下grbu才行. 反之, 如果在存在linux系统的情况下安装或者重装windows系统, 则会发现开机直接进入windows了. 出现这种情况是因为windows系统在安装的时候会把自己的引导程序放到<strong>MBR</strong>中去, 这就会造成机器启动的时候直接执行此时<strong>MBR</strong>上的内容. 这时候<strong>MBR</strong>上存放的是windows的引导器, 所以windows就会直接启动, linux就被撂在一旁,可怜兮兮,无人搭理.</p></blockquote><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ul><li><code>elf</code> : <code>executable and linking format</code></li><li><code>readelf -e elf</code> 用来查询程序中段的类型. (其中 <code>elf</code> 是文件名)</li><li><code>GDT</code> : <code>Global Descriptor Table</code> 全局描述符表, 表中的每一项被称为段描述符.</li><li>描述符 : 描述某种数据的数据结构, 是元信息.</li><li>堆 : 程序运行过程中用于动态内存分配的内存空间, 由操作系统分配划分.</li><li>堆栈,栈 : 同指栈, 硬件必须.</li><li>大端字节序和小端字节序<blockquote><p>小端字节序是数值的低字节存放在内存的低地址出,高字节存放在高地址处.<br>大端字节序与小端字节序相反.</p></blockquote></li><li><code>IVT</code> : <code>Interrupt Vector Table</code> 中断向量表.</li><li><code>CISC</code> : <code>Complex Instruction Set Computer</code> 复杂指令集计算机</li><li><code>RISC</code> : <code>Reduced Instruction Set Computer</code> 精简指令集计算机</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>我原本对<strong>位,比特,字节</strong>这些东西一直记不住,现在搞清了赶紧记下来.</p><blockquote><p>一个位即是一个 bit(比特),是最最小的数据单位,没有比它更小的了.</p></blockquote><blockquote><p>一个字节是 8 位,写作 byte, 换算关系为 <em>1 byte</em> = <em>8 bits</em> .<br>而内存的分布是以 byte 为基本单位的,也就是那些内存地址的单位都是 byte.</p></blockquote><p>另外一点容易弄混的是对于数据大小的判别. 首先分清这个十六进制数是一个存在内存里的数还是一个地址. 如果是数那么计算的单位是<code>bit</code>即位. 将这个数字换成一<code>二进制</code>串,其长度就是其大小,当然单位为<code>bit</code>. </p><blockquote><p>比如 <code>0xac2</code> 这个十六进制数所占的内存大小为12位,由于字节是8位,这里采用向上取整的方法为2字节. 二进制数为 <code>b101011000010</code>.</p></blockquote><p>如果是要看这个数本身的大小,则通过进制转换成十进制数即可.</p><blockquote><p>那么还是上面的例子, <code>0xac2</code> 这个数的大小可以通过十六进制转换为十进制即可.</p></blockquote><p>于是在具体的计算一个数字的”大小”的时候最好分清这个”大小”的意义所在.</p><hr><p>另外再提一句, 计算机内存是以<code>0</code>开始计算的. 同时, 对于一个地址从 <code>0x001</code> 到<code>0x003</code> 这样的一个地址段, 它的容量是<code>3</code>. 即末地址减去起始地址再加一.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后编辑时间: &lt;code&gt;2019-2-12&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个是阅读&lt;strong&gt;操作系统真象还原&lt;/strong&gt;的笔记. 记录学习系统一些知识点.&lt;br&gt;同时和&lt;strong&gt;深入理解计算机操作系统&lt;/strong&gt;一起. 希望学完系统能让我更加方便的学习汇编与二进制.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="ComputerSystem Asm" scheme="https://memorytoco.github.io/Lago/tags/ComputerSystem-Asm/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/10/Hello-World/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/10/Hello-World/</id>
    <published>2019-02-09T21:18:39.000Z</published>
    <updated>2019-02-12T07:57:08.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不-我没有放弃flax"><a href="#不-我没有放弃flax" class="headerlink" title="不, 我没有放弃flax!"></a>不, 我没有放弃flax!</h2><p>这里做一些说明吧.<br>基于现在的情况, 暂时使用<code>hexo</code>.</p><a id="more"></a><h3 id="现在你用了hexo建了博客-原来的flax呢"><a href="#现在你用了hexo建了博客-原来的flax呢" class="headerlink" title="现在你用了hexo建了博客,原来的flax呢?"></a>现在你用了<code>hexo</code>建了博客,原来的<code>flax</code>呢?</h3><p>emmm, 首先这两者不冲突. <code>flax</code> 的开发还在继续,并没有弃坑.</p><blockquote><p>我这个寒假一半的时间都耗在上面了,怎么可能弃坑呢! 并且我相信最终的它会给你们带来惊喜!</p></blockquote><p>然后主要现在在开发<code>flax</code>上遇挫, 遭遇了一个瓶颈.<br>一来迟迟不能让整个工作流程建立起来,<br>二来我也等不及了,<br>三来看到的一些东西让我对<code>flax</code>的期望(或者说是野心)增加了,结果让这个成型日期更加的延后.</p><h3 id="这个-Lago-是干什么的"><a href="#这个-Lago-是干什么的" class="headerlink" title="这个 Lago 是干什么的?"></a>这个 <code>Lago</code> 是干什么的?</h3><p>这个博客用于</p><ul><li>记笔记, 把一些想要分享的东西及时的贴出来</li><li>学习 <code>hexo</code>, 给 <code>flax</code> 铺路</li><li>进行知识输出</li><li>摸索自己的需求</li><li>作为一个辅助博客出现, 同时兼顾 <code>flax</code>的动态信息</li></ul><p>由于 <code>flax</code> 还在开发中, 我就没法着手关于博客页面相关的研究.<br>这就让整个进度异常缓慢, 非常摧残我的小心灵!! 所以这个博客就是一个试探.</p><blockquote><p>我在写<code>flax</code>的时候也对网站没什么概念, 用上这个来学习学习.</p></blockquote><blockquote><p>我最近一直在尝试建立起个人的学习体系, 其中的一环就是博客.<br>现在这个比重还在持续上升中.</p></blockquote><h3 id="那-flax-有什么动作吗"><a href="#那-flax-有什么动作吗" class="headerlink" title="那 flax 有什么动作吗?"></a>那 <code>flax</code> 有什么动作吗?</h3><p>有, 现在 <code>flax</code> 已经有了一个伪 <strong>hook</strong> 系统. 受到 <code>chez-scheme</code> 的逼迫,我不得不改变原先的工作机理, 摆脱对 <code>guile</code> 实现的依赖, 于是绞尽脑汁捉摸出了一个基于<strong>链表</strong> 这个数据结构的的系统, 终于可以在 <strong>新的</strong> 的实现上跑起来了.</p><blockquote><p>我也深刻的意识到了基本功的重要性. (转来转去, 我依然是在用我之前接触到的东西)</p></blockquote><p>出乎意料的是我发现这个改变得到的收益比我想象中的还要多. 于是我又想在这个基础上看看能不能琢磨出一个 <code>trigger</code> 系统出来, 再给它加上一些额外的支持.</p><p>由于原来的 <code>flax</code> 是我基于 <a href="https://dthompson.us/projects/haunt.html" target="_blank" rel="noopener">guile haunt</a> 一点一点<code>抄</code> 过来的, 所以有很多的思路都受到限制( 还是我自己脑补的思路… ), 现在正在努力的一点一点突破限制.</p><p>我现在还在继续扩展<code>flax</code>, 并且边用 <code>hexo</code> 边观察它的运作方式. 希望获得启发吧.</p><h2 id="所谓的-Flax-动态在哪里"><a href="#所谓的-Flax-动态在哪里" class="headerlink" title="所谓的 Flax 动态在哪里?"></a>所谓的 <code>Flax</code> 动态在哪里?</h2><p>在这个博客的页面可以看到一栏 <code>Flax</code>, 那里有一些关于 <code>Flax</code> 的信息.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不-我没有放弃flax&quot;&gt;&lt;a href=&quot;#不-我没有放弃flax&quot; class=&quot;headerlink&quot; title=&quot;不, 我没有放弃flax!&quot;&gt;&lt;/a&gt;不, 我没有放弃flax!&lt;/h2&gt;&lt;p&gt;这里做一些说明吧.&lt;br&gt;基于现在的情况, 暂时使用&lt;code&gt;hexo&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Misc Flax Hexo" scheme="https://memorytoco.github.io/Lago/tags/Misc-Flax-Hexo/"/>
    
  </entry>
  
</feed>
