<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lago</title>
  
  
  <link href="/Lago/atom.xml" rel="self"/>
  
  <link href="https://memorytoco.github.io/Lago/"/>
  <updated>2019-02-25T14:33:18.663Z</updated>
  <id>https://memorytoco.github.io/Lago/</id>
  
  <author>
    <name>Memorytoco</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>x86 汇编之一</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/26/wangshuang_1/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/26/wangshuang_1/</id>
    <published>2019-02-25T21:30:13.000Z</published>
    <updated>2019-02-25T14:33:18.663Z</updated>
    
    <content type="html"><![CDATA[<p>王爽汇编第三版, 包括课后习题答案(部分解读).</p><p>主要是每一章的知识点罗列.</p><p>王爽这一本书还是相当基础详细的, 用作汇编入门最好. 主要是我有方法模拟 8086 的机器了哈哈. 虽然老了很多, 但是还是觉得可以. 第一个微型系统就在 8086 上了. 于是这里就将这个作为<em>操作系统真象还原</em>的前导课程来学一下.</p><p>里面的实验就放在之后的bochs中进行. 使用bochs的自带调试功能.</p><a id="more"></a><h2 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h2><ul><li>cpu 的存储是以<strong>B</strong>为基本单位来进行计算的, 一个存储单元就是一个字节, 如果一个存储器有 128 个存储单元, 就可以说这个存储器 128 字节大小.</li><li>cpu 需要三种信息, 才能正确的执行一条指令<ul><li>地址信息</li><li>控制信息</li><li>数据信息</li></ul></li></ul><p>而且, cpu 是通过<strong>总线</strong>来和外部器件(芯片)交流的. 根据它所要的信息不同, 从逻辑上将总线划分成 3 个类别, 分别是</p><ul><li>地址总线</li><li>控制总线</li><li>数据总线</li></ul><p>这几个.</p><h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h3><p>一根导线只能传输高电平或者低电平, 也即<code>1</code>和<code>0</code>. 那么地址总线若有<code>10</code>根的话, 它的状态就有 2 的 10 次方个, 最大数为<code>1023</code>最小为<code>0</code>. 因此可以说, 其寻址能力是<code>1KB</code>. 这里是数字大小, 以 byte 为单位. 一根线数字上最大表示 1, 那最大一 byte, 两根最大 4, 6 根最大 64byte. 数字意义上. 这里需要和数据总线的”大小”区分开来, 依然是和之前的一样, 数字意义上和物理逻辑上.</p><h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h3><p>和地址总线一样, 总线的宽度(构成总线的线的个数)决定了一次可以传送的二进制数据量. <code>8</code>根数据线一次传送一个字节,<code>16</code>根一次<code>2</code>个字节. 这里一次所传大小的要以在内存中的计算. 8 个 bit 就是一个 byte. 几根几个 bit, 合起来 8 个算一个 byte.</p><h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h3><p>控制总线是一个总称, 但是其宽度依然能决定 cpu 对外部器件控制的能力.</p><h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><p>这里可以理解计算机内部由一个巨大的逻辑内存空间. 它在逻辑上是一整块儿的, 并且从<code>0</code>到<code>FFF..H</code>地址上分布. 而实际上, 这个巨大的内存空间是由若干个零碎的物理空间拼凑起来的. 同时, 这样我们也可以就把这个空间当作真实的物理空间, 而且不同的区段有不同的特殊功能.</p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>同时, 这里使用<code>H</code>后缀表示十六进制数字, 用<code>B</code>后缀表示二进制, 什么都不带的表示十进制.</p><p>一个十六进制位的数字可以使用 4 个二进制的<code>0</code>和<code>1</code>来替代.</p><p>比如<code>23H</code>就是<code>0010</code> <code>0011</code> <code>B</code>. <code>2</code>对应<code>0010</code>,<code>3</code>对应<code>0011</code>. 有趣的是这里面的位置意义也正好对应. 这两个数字转换成十进制的数是相同的.</p><h1 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h1><h2 id="检测点-1-1"><a href="#检测点-1-1" class="headerlink" title="检测点 1.1"></a>检测点 1.1</h2><ol><li>一颗 cpu 的寻址能力为 8KB,那么它的地址总线宽度是<code>13</code>.</li><li>1KB 的存储器有<code>1024</code>个存储单元, 编号从<code>0</code>到<code>1023</code>.</li><li>1KB 的存储器, 可以存储<code>8 * 1024</code>个 bit, <code>1024</code>个 byte.</li><li>1GB = <code>1024*1024*1024B</code>, 1MB = <code>1024*1024B</code>, 1KB = <code>1024B</code>.</li><li>8080 地址总线宽度是 16 根,寻址能力是<code>64KB</code>. 8088 宽 20 根,寻址能力是<code>1MB</code>, 80286 宽 24 根, 寻址能力是<code>16</code>MB, 80386 宽 32 根, 寻址能力是<code>4GB</code>.</li><li>数据总线</li></ol><table><thead><tr><th>处理器名称</th><th>数据总线宽度(根)</th><th>一次所传数据大小</th></tr></thead><tbody><tr><td>8080</td><td>8</td><td>1B</td></tr><tr><td>8088</td><td>8</td><td>1B</td></tr><tr><td>8086</td><td>16</td><td>2B</td></tr><tr><td>80286</td><td>16</td><td>2B</td></tr><tr><td>80386</td><td>32</td><td>4B</td></tr></tbody></table><ol start="7"><li><p>从内存中读取 1024 字节的数据, 8086 至少读<code>512</code>次, 80386 至少读<code>256</code>次.</p><blockquote><p>这个有关于数据总线. 注意物理意义上的大小和数字意义上的大小.</p></blockquote></li><li><p>在存储器中, 数据和程序以<code>二进制</code>的形式存放.</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;王爽汇编第三版, 包括课后习题答案(部分解读).&lt;/p&gt;
&lt;p&gt;主要是每一章的知识点罗列.&lt;/p&gt;
&lt;p&gt;王爽这一本书还是相当基础详细的, 用作汇编入门最好. 主要是我有方法模拟 8086 的机器了哈哈. 虽然老了很多, 但是还是觉得可以. 第一个微型系统就在 8086 上了. 于是这里就将这个作为&lt;em&gt;操作系统真象还原&lt;/em&gt;的前导课程来学一下.&lt;/p&gt;
&lt;p&gt;里面的实验就放在之后的bochs中进行. 使用bochs的自带调试功能.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="asm" scheme="https://memorytoco.github.io/Lago/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>特殊 shell 转义字符</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/20/shell-code-sequence/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/20/shell-code-sequence/</id>
    <published>2019-02-19T22:37:18.000Z</published>
    <updated>2019-02-24T10:07:36.564Z</updated>
    
    <content type="html"><![CDATA[<p>我不知道是不是这里的过程就是这样, 还是我自己的情况. 在一些情况下, 我总是会钻进某个”知识的荒原”里去.</p><p>无论我现在获得信息的能力水平如何, 这种情况总是会发生. 然后随着一夜一夜的亢奋, 也总算是能够触碰到我想要的那个 (唯一感到幸运的地方).</p><p>或许是该考虑一下信息的获取渠道了…</p><p>emmm, 说了一堆废话, 稍稍感慨了一下(主要是又钻进去了…), 还没讲主题.</p><p>主题就是题目, linux shell 里用于操作字符显示, 操作光标位置的特殊字符序列.</p><p>这篇依然是笔记里的内容, 只是记录了最粗浅的用法. 不是用法粗浅, 而是怎么用只是对此认知的最最底层, 所以粗浅.</p><p>另外, 这篇并不会完善所谓的基础知识, 只是用作对这个特殊转义字符的简要介绍. 里面会引用别人博客的内容(链接).</p><a id="more"></a><p>话不多说, 直接上.</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>继续之前, 确保先读完这篇post <a href="http://www.lihaoyi.com/post/BuildyourownCommandLinewithANSIescapecodes.html" target="_blank" rel="noopener">Build your own Command Line with ANSI escape codes</a>. 不理解也没关系, 大致有个概念就行.</p><p>然后打开这个<a href="https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_sequences" target="_blank" rel="noopener">wiki</a>网页随时查询.</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>看完上面的文章, 人家演示了具体的用法和具体在python中的做法. 如果你只是想在python中使用的话, 那么那里面的内容和wiki就足够了. 如果看了之后还想继续在shell中使用或者在其它语言中使用, 但是没有从那篇文章中得到启发, 仍然一头雾水, 那么继续阅读吧. (其实关于如何使用上面两个资料完全够了…)</p><p>ANSI转义字符, 说白了就和c里面的转义字符一样. 只不过c里面的转义字符是由<code>printf</code>负责解释, 而这个ANSI转义字符是由字符终端或者终端模拟器(terminal emulator)负责解释的.</p><p>所有包含这些特殊字符的字符序列都会被当成命令由terminal解释, 不会输出显示出来. 所以不用担心输出里面会包含什么奇怪的东西.</p><p>先上个bash的例子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env sh</span></span><br><span class="line"></span><br><span class="line">(( number=0 ))</span><br><span class="line">arg=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>  [ <span class="variable">$number</span> != $(( arg ? arg : 100)) ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  (( number = number + 1 ))</span><br><span class="line">  <span class="built_in">echo</span> -e -n <span class="string">"\x1b[0K\x1b[100D\x1b[38;5;106m<span class="variable">$number</span>\x1b[0m%"</span> &amp;&amp; sleep 0.1s</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e -n <span class="string">"\x1b[2K"</span></span><br><span class="line"><span class="built_in">echo</span> -e -n <span class="string">"\x1b[100D"</span></span><br></pre></td></tr></table></figure></p><p>可以将其复制运行看看. 它接受一个数字参数, 试试传入<code>10</code>和<code>50</code>看看效果. 我想这个应该能勾起学习兴趣了…</p><p>这个脚本最复杂的地方就是这几个<code>echo</code>命令的参数了. 是的, 那些就是所谓的转义序列.</p><p>就像c里换行符用<code>\</code>转义一样, ANSI转义序列也有这个要求. 这个一般是<code>ESC[</code>. 然后组成上就再加上以<code>;</code>分隔的参数. <code>ESC</code>代表了键盘左上角<code>ESC</code>键的特殊不可见字符. 这个<code>ESC</code>字符是关键. 如果程序原样打印出了这些字符序列, 那么要么程序有某些设定限制( 如不加<code>-e</code>参数的<code>echo</code>), 要么就是<code>ESC</code>没被识别出来. 其实总结就是<code>ESC</code>没识别出来.</p><p>划个重点:</p><blockquote><p>基本结构是<code>ESC[arg1;arg2;...</code>, 一般来说是一到三个参数. 此外, 之后使用<code>CSI</code>代替<code>ESC[</code>. 所以直接写成 <code>CSI arg1;arg2;</code> 这个只是我作说明使用, 实际使用还是要完整的输入<code>ESC[</code>的. 具体的可以阅读下<a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Escape_sequences" target="_blank" rel="noopener">wiki</a>开头这一部分, 没看明白也没关系, 继续阅读就行.</p></blockquote><p>就是这个:<br><img src="CSI_intro.png" alt="CSI_intro"></p><h3 id="命令-动作-CSI-参数"><a href="#命令-动作-CSI-参数" class="headerlink" title="命令? 动作? CSI? 参数?"></a>命令? 动作? <code>CSI</code>? 参数?</h3><p>继续上面的例子.</p><p><code>echo</code>的<code>-e</code>选项是<code>Enable interpretation of backslash escapes</code>, 即允许<code>echo</code>对转义字符进行处理. 而<code>-n</code>选项是<code>Do not output a newline</code>, 不输出换行符, 让我们完全接管控制. 剩下的就是<code>\x1b</code>这个东西, 不用想也知道这是个转义字符, 但是这个转成了什么呢? 是<code>ESC</code>字符. 它是不可见<code>ESC</code>字符的十六进制表示, 同样的八进制表示是<code>\033</code>. 也就是说这两个你可以任意选用. 只要能将<code>ESC</code>表示出来就行. 要保证程序最终输出的是一个<code>ESC</code>字符而不是<code>\x1b</code>这个4个字符. 所以我们的<code>CSI</code>表示出来就是<code>\x1b[</code>. 那么我们开始解释上面那个例子了. 坐稳了.</p><p>第一行是一个<code>shebang</code>符号, 不多说. 第3,4行初始化变量, 将<code>number</code>赋值0,将第一个参数赋值给<code>arg</code>. 然后6到10行是一个while循环, 持续的打印出<code>number%</code>, 并且对输出进行控制. <code>number</code>周围就是一些ANSI转义序列了. 最后两行重置命令行, 执行完命令后好像什么都没发生一样, 装作没事人.</p><p>接下来解释转义序列了.<br>以防万一你们不想去翻wiki, 上个图.<br><img src="CSI_table.png" alt="CSI-table"></p><p>列表的第一列就是转义序列, 除了<code>CSI</code>要换成<code>\x1b[</code>外, 其它原样输入. 其中<code>n</code>和<code>m</code>里面都有解释, 是一个整数数字, 具体含义参看解释. 而未解释的都是要原样输入的, 是序列的一部分.</p><p>那么这里就可以解释最后两行了.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 擦除整行的内容</span></span><br><span class="line"><span class="built_in">echo</span> -e -n <span class="string">"\x1b[2K"</span></span><br><span class="line"><span class="comment"># 左移光标100个单位, 这里依据上下文可理解为将光标移动到最左边, 这也是我的目的</span></span><br><span class="line"><span class="built_in">echo</span> -e -n <span class="string">"\x1b[100D"</span></span><br></pre></td></tr></table></figure></p><p>如何实验呢, 可以命令行输入<code>echo -e -n &quot;Hello World\x1b[2K&quot;</code>看看什么反应. 是不是输出了个空行? 根据shell的不同, 新起的<code>prompt</code>可能会在同一行(默认期望行为)也可能另起了一行而且在后头可能有什么符号表示”你这没有换行符, 为了美观我先给你换了”这样. 同样的, 序列<code>CSI n D</code>会将光标左移100个单位. </p><p>多个ANSI转义序列可以同时存在, 并且同时生效. 如果两个有冲突, 那么遵循从左到右的顺序, 依次生效. 同时, 转义序列是按行生效的, 在哪一行就以哪一行为基准进行行动. (其实是和光标位置有关啦) 试试加上个<code>\n</code>会有什么效果<code>echo -e -n &quot;Hello World\n\x1b[2K&quot;</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e -n <span class="string">"Hello World\n\x1b[2K"</span></span></span><br><span class="line">Hello World</span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>好像什么效果都没有. 这是因为<code>\n</code>的缘故, 使得在输出<code>Hell World</code>后另起了一行, 然后<code>擦除行</code>的效果作用在一个什么都没有的行上面. 随后, 程序结束, shell打印提示符. 这里注意这两个序列命令不是维持一个状态, 而是执行一个动作, 所以动作执行后发生什么就和它无关了. 新出来的shell提示符<code>prompt</code>看样子是出现在了<code>擦除行</code>作用的行上, 但是因为那个动作已经先执行了, 我一个后出来的提示符和它没啥关系, 所以自然什么事都没有. 想要验证的话可以这样试试. 把<code>\n</code>放到<code>Hello World</code>的中间去怎么样.<br><img src="shell-1.png" alt="shell"></p><p>我用的是<code>fish</code>, 效果如上. 基本可以验证我的想法了. 注意到我用了另外一个序列, 起到了同样的效果, 可以自行在上边的表里查找, 当作一个小的练习. </p><h3 id="作用在行-不-是光标"><a href="#作用在行-不-是光标" class="headerlink" title="作用在行? 不, 是光标!"></a>作用在行? 不, 是光标!</h3><p>其实我提到过这个啦, 小括号里面. 我说过了, 转义序列是按行生效的, 这个从我们之前的测试结果来看似乎是对的, 但是其实不是. 如果你做了上面的小练习, 那么你应该对此有所察觉了. </p><p>“这个序列我看了, 可它不是换行啊! 为啥它的效果和换行一样啊! 这啥玩意儿啊!”</p><p>哈哈, 别急. 虽然只是我的猜测, 但是你有没有想过, 这些换行符是怎么运作的呢? 为什么这个换行符就能起到换行的作用呢? 而且我们也知道, 换行符在linux和windows上还是不一样的, 为什么会有这种差别呢?</p><p>“可这和我今天学ANSI转义序列有什么关系呢?”</p><p>额, 确实, 继续在这方面深入的话就有点偏题了, 但是这里也包含了一点点的关系, 涉及到字符解释与表示的问题. </p><p>前面提到过, ANSI转义字符是由<code>terminal</code>解释的, 就像<code>\n</code>可以由printf进行解释一样. 那么有没有可能<code>\n</code>的作用不是换行, 而是</p><ol><li>将光标下移</li><li>然后将光标左移至顶</li></ol><p>这样呢. 它实际操纵的是光标而给我们一种换了行的表面现象呢? 是不是? 这么想一下是不是开始有点意思了. 当然, 具体的我现在还没深入了解, 也只是一个猜测. 我也提到过, 这些转义都会由一个东西进行解释与执行, 就像我们的代码一样. 所以我认为这个猜测很有可能是真的. 不过, 口说无凭, 我后续也会继续求证. 所以, 目前, 我们暂时将其当作一个假设事实. 我们得到了</p><blockquote><p>ANSI转义字符操作的是光标</p></blockquote><p>这么一个重要的假设. 不管是不是真的, 先看看它是不是按照我们的预期行动就行了.</p><h3 id="颜色控制-–-给我来个RGB-带闪光的那种"><a href="#颜色控制-–-给我来个RGB-带闪光的那种" class="headerlink" title="颜色控制 – 给我来个RGB, 带闪光的那种!"></a>颜色控制 – 给我来个RGB, 带闪光的那种!</h3><p>我们稍稍探讨了ANSI序列真正操纵的东西是什么, 有点跑远了. 现在我们继续来看看上面的代码. </p><p>不过好像有点远了, 没事, 我把它拿下来了. 还对它做了点改变, 方便探讨.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(( number=0 ))</span><br><span class="line"><span class="keyword">while</span>  [ <span class="variable">$number</span> != 100 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  (( number = number + 1 ))</span><br><span class="line">  <span class="built_in">echo</span> -e -n <span class="string">"\x1b[0K\x1b[100D\x1b[37m<span class="variable">$number</span>\x1b[0m%"</span> &amp;&amp; sleep 0.1s</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这个循环将会执行100次, 并且输出<code>1%</code>到<code>100%</code>. 有了上面的经验, 我们再看这个<code>echo</code>行是不是好多了. 来, 我们依次解释</p><ul><li><code>\x1b[0K</code> 查询上边的表, 得到是擦除从光标到行尾内容的效果</li></ul><blockquote><p>看来猜测确实是对的, wiki都这么说了是不. 不过好像还是会依赖行. 嗯? 什么, 你不信wiki, 那你就任重道远了, 继续深入吧探索吧, 求证之后也一定要让我知道.</p></blockquote><p>那么, 再次看看那个表, 上面的东西都已经开放了. 在得知其作用于光标这个结论后.</p><p>表里面提到什么滚动, 上移下移. 这些都可以探索了.</p><ul><li><code>\x1b[100D</code> 左移光标100个单位</li></ul><p>然后碰到了一个<code>\x1b[37m</code> 这个东西还有<code>\x1b[0m</code>.</p><p>查询表得到几个相似的东西. 就是<code>CSI n m</code>这个. wiki让我们去找<code>SGR parameters</code>. 为了方便, 我也将它准备好了.</p><p>我们得到这个表述:<br><img src="SGR-Intro.png" alt="SGR-intro"></p><p>从中, 知道了这个序列码会一直生效, 可以接受多个参数, 以<code>;</code>分离. 而且关键的一点是除非有另外的代码生效, 否则前一个的效果会一直持续下去.</p><p>然后就是一个列表, 为了方便, 我把它分成了两个.<br><img src="SGR-table1.png" alt="SGR-table1"><br><img src="SGR-table2.png" alt="SGR-table2"></p><p>继续在表里查找<code>CSI 37 m</code>这个序列, 然而并没有得到直接的说明, 它让我们继续向下找<code>color table</code>.</p><p>不过这里我就不继续贴图了, 有了上面的经验, 要看懂应该也不是难事了. 直接解释.</p><p><code>CSI 0 m</code>或者<code>CSI m</code>会重置所有的设置和状态. 这个在你实验的时候非常重要. 然后其它的可以参考上面的引用博客. 那里面说的非常详细了, 阅读完应该就有了大致了解, 其它的继续参照wiki吧.</p><p>这里有个总结:</p><ul><li><code>CSI 30m</code> 到 <code>CSI 37m</code>是八个字体颜色, 也是8bit字符表示的颜色.</li><li><code>CSI 30;1m</code> 到 <code>CSI 37;1m</code>又是八个, 不过带了粗体.</li><li><code>CSI 38;5;nm</code> 有点厉害了, 提供256个颜色, 其中的<code>n</code>是<code>1-256</code>的范围.</li></ul><p>同时, 除了设置字体颜色, 还支持设置背景颜色. 还有额外的字体装饰等等功能. 这些就让你去自行探索吧. wiki上可以参考, 那个post也值的一读.</p><h2 id="将它应用到其它程序语言中去"><a href="#将它应用到其它程序语言中去" class="headerlink" title="将它应用到其它程序语言中去"></a>将它应用到其它程序语言中去</h2><p>以上都是使用<code>echo</code>, 也就是所谓的<code>shell</code>脚本来说明的. 那么如何在其它语言中使用呢? 答案就是该怎么用就怎么用. 只要<code>terminal</code>支持, 这些字符序列就都会起作用, 这些字符不是由shell解释的, 而是由<code>terminal</code>解释的, 所以<code>terminal</code>对它有最终解释权.</p><p>“恩, 说的不错, 但要怎么呢?”</p><p>我觉得我说的挺明白了… 好吧, 再拿shell举例, <code>echo &quot;\x1b[37mHello World\x1b[m&quot;</code>这里面发生了什么呢. </p><p>先是<code>echo</code>解释转义字符<code>\</code>, 于是得到<code>ESC[37mHello WorldESC[m</code>, 这里的<code>ESC</code>代表不可见字符<code>ESC</code>, 是计算机内存中的表示. 然后<code>echo</code>再将其输出到标准输出端口, <code>terminal</code>接收到了这个字串, 遇见<code>ESC[37m</code>将其视为命令执行, 然后输出白色的<code>Hello World</code>, 再次遇到命令, 重置. 输出结束.</p><p>就像我开头强调的那样, 重要的是不可见字符<code>ESC</code>字符的识别. 如果使用c的话, 那就是<code>printf(&quot;\x1b[37mHello World\n\x1b[m&quot;);</code>, 最最重要的依然是<code>ESC</code>的输出和对它的识别. 得要让<code>terminal</code>识别出命令. 这样就行了.</p><p>看完引用post后你应该直到了如何使用python来操作了, 这里你又会了shell和c的表示. 那么, 将这些经验带到其它的语言中去吧.</p><p>比如我在scheme中就是<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">display</span> (<span class="name">string-append</span> (<span class="name">string</span> #\<span class="number">033</span>) </span><br><span class="line">                        <span class="string">"[37mHello World\n"</span></span><br><span class="line">                        (<span class="name">string</span> #\<span class="number">033</span>)</span><br><span class="line">                        <span class="string">"[m"</span>))</span><br></pre></td></tr></table></figure></p><p>好了, 以上就是基本的介绍了. 这里面也还有东西, 比如<code>terminal</code>和我们运行的程序的关系这类以及<code>terminal</code>如何处理字符的打印这些问题. 留待后续探讨吧.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我不知道是不是这里的过程就是这样, 还是我自己的情况. 在一些情况下, 我总是会钻进某个”知识的荒原”里去.&lt;/p&gt;
&lt;p&gt;无论我现在获得信息的能力水平如何, 这种情况总是会发生. 然后随着一夜一夜的亢奋, 也总算是能够触碰到我想要的那个 (唯一感到幸运的地方).&lt;/p&gt;
&lt;p&gt;或许是该考虑一下信息的获取渠道了…&lt;/p&gt;
&lt;p&gt;emmm, 说了一堆废话, 稍稍感慨了一下(主要是又钻进去了…), 还没讲主题.&lt;/p&gt;
&lt;p&gt;主题就是题目, linux shell 里用于操作字符显示, 操作光标位置的特殊字符序列.&lt;/p&gt;
&lt;p&gt;这篇依然是笔记里的内容, 只是记录了最粗浅的用法. 不是用法粗浅, 而是怎么用只是对此认知的最最底层, 所以粗浅.&lt;/p&gt;
&lt;p&gt;另外, 这篇并不会完善所谓的基础知识, 只是用作对这个特殊转义字符的简要介绍. 里面会引用别人博客的内容(链接).&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://memorytoco.github.io/Lago/categories/Tech/"/>
    
    
      <category term="shell script" scheme="https://memorytoco.github.io/Lago/tags/shell-script/"/>
    
  </entry>
  
  <entry>
    <title>shell 工具集</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/16/shell-tools/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/16/shell-tools/</id>
    <published>2019-02-15T21:54:50.000Z</published>
    <updated>2019-02-15T14:00:50.281Z</updated>
    
    <content type="html"><![CDATA[<p>最后编辑时间: <code>2019-2-15</code> , 持续更新补充</p><p>linux shell 最常用工具介绍. 这些在你编写linux shell脚本的时候拥有非常大的用处. 你的shell脚本水平也与你对这些工具的熟练度直接挂钩.</p><a id="more"></a><h3 id="wc-工具"><a href="#wc-工具" class="headerlink" title="wc 工具"></a><code>wc</code> 工具</h3><p>用作字符统计.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc file</span><br></pre></td></tr></table></figure><p><code>wc</code> 命令会显示三个数字和文件名.<br>实例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wc .vimrc</span><br><span class="line">273  865 8549 .vimrc</span><br></pre></td></tr></table></figure><p>可以看到这里由三个数字, 第一个数字表示文件行数, 第二个数字表示单词数, 第三个表示字符数.最后一个是文件名. 所以这个例子显示了 <em>.vimrc</em> 这个文件共有 273 行, 865 个单词, 8549 个字符. 统计结果来自 <em>.vimrc</em>这个文件.</p><h3 id="使用-cat-显示文件内容"><a href="#使用-cat-显示文件内容" class="headerlink" title="使用 cat 显示文件内容"></a>使用 <code>cat</code> 显示文件内容</h3><p>显示文件内容. 是<em>concatenate</em>的缩写, 如果给了多个文件, 那么<code>cat</code>会将两个文件的内容合并起来在输出到标准输出中去.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat files</span><br></pre></td></tr></table></figure><h3 id="使用-cut-提取半结构化文件内容"><a href="#使用-cut-提取半结构化文件内容" class="headerlink" title="使用 cut 提取半结构化文件内容"></a>使用 <code>cut</code> 提取半结构化文件内容</h3><p>用于从数据文件或者命令输出中提取(切出)各种字段.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -cchars file</span><br></pre></td></tr></table></figure><p>其中<code>-cchars</code>可以是</p><table><thead><tr><th>符号</th><th>含义</th><th>总结</th></tr></thead><tbody><tr><td><code>-c1</code></td><td>提取每行的第一个字符</td><td><code>-cnum</code></td></tr><tr><td><code>-c1,3,5</code></td><td>提取每行的第一,三,五个字符</td><td><code>-cnum1,num2,num3...</code></td></tr><tr><td><code>-c1-4</code></td><td>提取每行的第一到四个字符</td><td><code>-cnum1-num2</code></td></tr><tr><td></td><td>提取从<code>num1</code>到行尾的所有字符</td><td><code>-cnum1-</code></td></tr></tbody></table><p>上面的足以应对一般需求了,但是如果一个文件不是那么规则的话或许需要一些额外的支持才行.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -ddchar -ffield file</span><br></pre></td></tr></table></figure><p>其中, <code>dchar</code>是分隔字符, <code>field</code>是由分隔字符分隔出来的一个个段, 其格式和<code>-c</code>选项一样.</p><blockquote><p>如果在没有指定<code>-d</code>选项的情况下使用<code>-f</code>, 那么分隔符就是<strong>制表符</strong>.</p></blockquote><h3 id="paste-与-cut-搭配使用"><a href="#paste-与-cut-搭配使用" class="headerlink" title="paste 与 cut 搭配使用"></a><code>paste</code> 与 cut 搭配使用</h3><p>用于合并行, 与<code>cut</code>相反.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste files</span><br></pre></td></tr></table></figure><p><code>paste</code>后面可以跟随多个文件名, 结果就是将每个文件中的对应行合并起来. 默认分隔符是<strong>制表符</strong>.如果想要更改分隔符可以使用<code>-d</code>选项. 命令格式为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste -dchars file1 file2 file3 ...</span><br></pre></td></tr></table></figure><p>其中, <code>chars</code>是多个字符, 每个字符分别分隔依次序的文件. 就是第一个字符分隔<code>file1</code>和<code>file2</code>, 第二个字符分隔<code>file2</code>和<code>file3</code>, 其余以此类推.</p><p>同时使用<code>-s</code>选项,将一个文件中的所有行合并.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste -s file</span><br></pre></td></tr></table></figure><h3 id="流编辑器-sed"><a href="#流编辑器-sed" class="headerlink" title="流编辑器 sed"></a>流编辑器 <code>sed</code></h3><p>是<strong>stream editor</strong>(流编辑器)的简称.一般用法如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed command file</span><br></pre></td></tr></table></figure><p><code>sed</code> 不会修改原始的文件, 只会把结果输出到标准输出.</p><p>具体的用法另起一个笔记.</p><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a><code>tr</code></h3><p>用作于过滤器,转换标准输入中的字符.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr fromchars tochars</span><br></pre></td></tr></table></figure><p>同样的, <code>tr</code>不会修改原始文件. 其中, 字符可以使用八进制来表示. <code>\xxx</code>.</p><table><thead><tr><th>tr 命令</th><th>含义</th></tr></thead><tbody><tr><td><code>tr &#39;[a-z]&#39; &#39; &#39;</code></td><td>将小写字母转换成空格</td></tr><tr><td><code>tr &#39;[a-z][A-Z]&#39; &#39;[A-Z][a-z]&#39;</code></td><td>将大写字母转换成小写字母, 将小写字母转换成大写字母</td></tr></tbody></table><p><code>-s</code>选项用来将连续出现的字符替换成一个单一的字符. <code>-d</code>选项用于删除输入流中的</p><h3 id="grep-文件搜索"><a href="#grep-文件搜索" class="headerlink" title="grep 文件搜索"></a><code>grep</code> 文件搜索</h3><p>神器,不解释.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep pattern files</span><br></pre></td></tr></table></figure><blockquote><p>待补充</p></blockquote><h3 id="使用-sort-对内容进行排序"><a href="#使用-sort-对内容进行排序" class="headerlink" title="使用 sort 对内容进行排序"></a>使用 <code>sort</code> 对内容进行排序</h3><p>用于给输入的内容排序.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort file</span><br></pre></td></tr></table></figure><p><code>-u</code>选项,消除重复的行. <code>-r</code>选项逆序排列. <code>-o</code>选项指定输出文件. <code>-n</code>将行中的第一个字段视为数字进行排序. <code>-knumn</code> 选项表示从第<code>num</code>个字段开始排序. <code>-t</code>选项制定各个字段的分隔符.</p><h3 id="uniq-过滤器"><a href="#uniq-过滤器" class="headerlink" title="uniq 过滤器"></a><code>uniq</code> 过滤器</h3><p>用于查找或者删除文件中的重复行.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq inputfile outputfile</span><br></pre></td></tr></table></figure><p><code>-d</code>选项用于找出重复的行. <code>-c</code>选项统计出现的次数.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后编辑时间: &lt;code&gt;2019-2-15&lt;/code&gt; , 持续更新补充&lt;/p&gt;
&lt;p&gt;linux shell 最常用工具介绍. 这些在你编写linux shell脚本的时候拥有非常大的用处. 你的shell脚本水平也与你对这些工具的熟练度直接挂钩.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="linux shell" scheme="https://memorytoco.github.io/Lago/tags/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title>vim寄存器简明介绍</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/15/vim-register/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/15/vim-register/</id>
    <published>2019-02-14T21:34:12.000Z</published>
    <updated>2019-02-14T13:56:26.828Z</updated>
    
    <content type="html"><![CDATA[<p>最后编辑时间: <code>2019-2-14</code> , 之后会添加具体的例子.</p><p>最近再次深入一下<code>vim</code>, 这次复习了一下<code>vim</code>的寄存器.</p><p><code>vim</code>寄存器属于那种没用过几乎不用但一用过就再也离不开的角色, 在<code>vim</code>里面, 寄存器不仅与插件有无限的可能, 而且就算不借助任何插件, 只是使用好这些寄存器也会使你在<code>vim</code>的编辑效率提高一个档次.</p><p>物超所值, 值的学习!</p><p>这次就将我复习的内容分享出来啦!</p><a id="more"></a><p>概览</p><p>使用<code>:dis</code>或者不带参数的<code>:reg</code>命令显示所有的寄存器以及储存的值. 使用<code>:reg</code>后跟复数个寄存器的名字来显示寄存器中的内容.</p><table><thead><tr><th>寄存器名</th><th>作用</th></tr></thead><tbody><tr><td><code>&quot;&quot;</code></td><td>无名寄存器</td></tr><tr><td><code>&quot;0 - &quot;9</code></td><td>10个数字寄存器</td></tr><tr><td><code>&quot;-</code></td><td>小型删除寄存器</td></tr><tr><td><code>&quot;a - &quot;z</code>, <code>&quot;A -&quot;Z</code></td><td>26个字母寄存器</td></tr><tr><td><code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code></td><td>三个只读寄存器</td></tr><tr><td><code>&quot;#</code></td><td>备用文件寄存器</td></tr><tr><td><code>&quot;=</code></td><td>表达式寄存器</td></tr><tr><td><code>&quot;*</code>, <code>&quot;+</code>, <code>&quot;~</code></td><td>选中丢弃寄存器</td></tr><tr><td><code>&quot;_</code></td><td>黑洞寄存器</td></tr><tr><td><code>&quot;/</code></td><td>最后的搜索的pattern</td></tr></tbody></table><h3 id="t-与-m-文本命令"><a href="#t-与-m-文本命令" class="headerlink" title=":t 与 :m 文本命令"></a><code>:t</code> 与 <code>:m</code> 文本命令</h3><p><code>:co</code>, <code>:copy</code> 命令<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[<span class="built_in">range</span>]<span class="keyword">co</span>[<span class="keyword">py</span>] &#123;address&#125;</span><br></pre></td></tr></table></figure></p><p>将<code>[range]</code>内的内容复制到<code>{address}</code>行下. <code>:t</code>与这两个同义.</p><blockquote><p><code>[range]</code>可以是<code>num1,num2</code>,表示从<code>num1</code>到<code>num2</code>的行. 也可以是特殊的表示行号的字符, 由<code>,</code>分隔. <code>{address}</code>表示一个行的地址, 初步使用可以指定一个行号. 更多的内容请看之后的<code>vim</code>系列的<strong>特殊记号</strong>说明吧. :)</p></blockquote><hr><p><code>:m</code>, <code>mo</code>, <code>move</code>命令<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[<span class="built_in">range</span>]<span class="keyword">m</span>[ove] &#123;address&#125;</span><br></pre></td></tr></table></figure></p><p>将<code>[range]</code>内的内容移动到<code>{address}</code>行下.</p><h3 id="无名寄存器-quot-quot"><a href="#无名寄存器-quot-quot" class="headerlink" title="无名寄存器 &quot;&quot;"></a>无名寄存器 <code>&quot;&quot;</code></h3><p>vim将<code>d</code>,<code>c</code>,<code>s</code>,<code>x</code>这些动作或者<code>y</code>指令操作的内容存放到无名寄存器中, 且无论在进行这些操作的时候是否指定特殊的寄存器, 无名寄存器中的内容总会这这些指令操作的内容. </p><blockquote><p>实际上, 无名寄存器总是指向一个有名寄存器, 且它的内容和这个有名寄存器中的一样.</p></blockquote><p>唯一的特例就是黑洞寄存器<code>&quot;_</code>, 如果进行动作的时候指定了黑洞寄存器, 那么操作的内容不会存到任何寄存器中.</p><p>无名寄存器中的内容用于任何的<strong>粘贴</strong>命令如<code>p</code>. 还有一个就是, 如果我们特别指定<code>&quot;&quot;</code>无名寄存器的话, 写入无名寄存器中的内容也会同时写入<code>&quot;0</code>寄存器中.</p><h3 id="数字寄存器-quot-0-quot-9"><a href="#数字寄存器-quot-0-quot-9" class="headerlink" title="数字寄存器 &quot;0 - &quot;9"></a>数字寄存器 <code>&quot;0 - &quot;9</code></h3><p><code>&quot;0</code>寄存器存储最后的<code>y</code>命令yank的内容, 如果在yank的时候指定了其他的寄存器, 那么<code>&quot;0</code>寄存器中的内容不更新.</p><p><code>&quot;1</code>寄存器存储绝大多数最后删除的内容, 除非指定了其他的寄存器. 如果删除的内容小于一行的话, 使用小型删除寄存器<code>&quot;-</code>. 一个例外就是, 如果删除的命令使用了这些<code>%</code>,<code>(</code>,<code>)</code>,<code>`</code>,<code>/</code>,<code>?</code>,<code>n</code>,<code>N</code>,<code>{</code>,<code>}</code>动作指令, 那么<code>&quot;1</code>寄存器的内容总会被更新为这些新的内容. 同时,如果删除的内容在一行之内的话, <code>&quot;-</code>也会被使用到.<br>每次的删除都会使数字寄存器的内容向后推移.  vim会将原来<code>&quot;1</code>的内容传给<code>&quot;2</code>, 再将原来<code>&quot;2</code>的内容传给<code>&quot;3</code>, 如此下去, 并且丢弃原来<code>&quot;9</code>中的内容.</p><h3 id="小型删除寄存器-small-delete-register-quot"><a href="#小型删除寄存器-small-delete-register-quot" class="headerlink" title="小型删除寄存器(small delete register) &quot;-"></a>小型删除寄存器(small delete register) <code>&quot;-</code></h3><p>这个寄存器存储所有小于一行的删除操作, 除非在删除的时候指定了寄存器.</p><h3 id="有名字母寄存器-quot-a-quot-z-quot-A-quot-Z"><a href="#有名字母寄存器-quot-a-quot-z-quot-A-quot-Z" class="headerlink" title="有名字母寄存器 &quot;a - &quot;z , &quot;A - &quot;Z"></a>有名字母寄存器 <code>&quot;a - &quot;z</code> , <code>&quot;A - &quot;Z</code></h3><p>这些寄存器只有在被指定的时候才会被用到. 小写字母寄存器<code>&quot;a - &quot;z</code>会替换原先的内容, 大写字母寄存器<code>&quot;A - &quot;Z</code>会将内容附加到原先的寄存器中. 当 <code>&gt;</code> 标志被放到 <code>cpoptions</code>时, 在附加内容之前总会插入一个换行符.</p><h3 id="只读寄存器-quot-quot-quot"><a href="#只读寄存器-quot-quot-quot" class="headerlink" title="只读寄存器 &quot;:, &quot;., &quot;%"></a>只读寄存器 <code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code></h3><p>这些寄存器只能只能通过<code>p</code>,<code>P</code>,<code>:put</code>和<code>CTRL-R</code>使用.</p><p><code>&quot;.</code>寄存器包含最后在插入模式下插入的内容.</p><p><code>&quot;%</code>寄存器包含这当前打开的文件名.</p><p><code>&quot;:</code>寄存器包含着最后输入的命令行命令. 可以使用<code>@:</code>来执行最后执行过的命令. 注意, 只有在命令行中执行的命令才会被记录, 也就是说如果是通过按键映射执行的命令将不会被记录.</p><h3 id="备用文件寄存器-quot"><a href="#备用文件寄存器-quot" class="headerlink" title="备用文件寄存器 &quot;#"></a>备用文件寄存器 <code>&quot;#</code></h3><p><code>&quot;#</code>寄存器保存当前窗口备用文件的名字, 它会影响<code>CTRL-^</code>的工作方式. 一个备用文件往往是之前编辑过的文件, 所以可以用这个<code>:e #</code>再两个文件之间快速跳转, 与之有相同功能的是<code>CTRL-^</code>组合键. 比如, 你先打开了<code>file1</code>文件, 然后发现更改了<code>file1</code>的内容后需要更改<code>file2</code>文件, 于是又通过<code>:e file2</code>来打开<code>file2</code>. 在更改的过程中突然发现原来的<code>file1</code>文件有错误, 于是此时就可以<code>CTRL-^</code>切回<code>file1</code>继续编辑. 编辑完了后再次<code>CTRL-^</code>切回<code>file2</code>继续更改.</p><blockquote><p>这个寄存器是可写的. 所以通过一些插件的支持, 或许可以维系一个特别高效的编辑模式.</p></blockquote><h3 id="表达式寄存器-quot"><a href="#表达式寄存器-quot" class="headerlink" title="表达式寄存器 &quot;="></a>表达式寄存器 <code>&quot;=</code></h3><p>当键入<code>&quot;=</code>或者<code>CTRL-R</code>时, 光标会跑到命令行中去. 在那里, 你可以键入任意的表达式, 使用<code>&lt;CR&gt;</code>键结束输入, 使用<code>&lt;ESC&gt;</code>键放弃输入, 如果留空, 那么执行上一次的命令. 然后结果会被转换成字串储存起来. 如果<code>&quot;=</code>被用到<code>p</code>命令上去, 那么其内容会被自动加上一个换行符.</p><h3 id="选中丢弃寄存器-selection-and-drop-register-quot-quot-quot"><a href="#选中丢弃寄存器-selection-and-drop-register-quot-quot-quot" class="headerlink" title="选中丢弃寄存器(selection and drop register) &quot;*,&quot;+,&quot;~"></a>选中丢弃寄存器(selection and drop register) <code>&quot;*</code>,<code>&quot;+</code>,<code>&quot;~</code></h3><p>这些寄存器是否可用还请亲自实验, 后续补全使用条件.</p><p><code>&quot;+</code>寄存器与系统剪贴板相通, 需要编译支持. 而<code>&quot;*</code>会存储选中的内容. 比如存储通过<code>v</code>选中后又<code>&lt;ESC&gt;</code>取消丢弃掉的内容. 这两个非常好用, 可以自己尝试. 剪贴板的我就不说了, <code>&quot;*</code>这个寄存器只要选中就可以将内容存储到里面去了. <code>&quot;~</code> 暂时不知晓, 有机会后续补充.</p><h3 id="黑洞寄存器-quot"><a href="#黑洞寄存器-quot" class="headerlink" title="黑洞寄存器 &quot;_"></a>黑洞寄存器 <code>&quot;_</code></h3><p>如其名, 它就像一个黑洞一样, 只进不出. 使用它不会对其它寄存器作出影响, 从这个寄存器中也取不出任何内容, 总之, 无事发生.</p><h3 id="搜索模式寄存器-quot"><a href="#搜索模式寄存器-quot" class="headerlink" title="搜索模式寄存器 &quot;/"></a>搜索模式寄存器 <code>&quot;/</code></h3><p><code>&quot;/</code>寄存器保存最后一次搜索的搜索模式(pattern). 这会影响命令<code>n</code>,<code>N</code>和选项<code>hlsearch</code>的工作方式. 它是可写的, 可以使用 <code>:let</code>来赋值, 但是无法通过删除或者yank内容到这个寄存器中.</p><blockquote><p>一个用处就是可以通过改变这个寄存器里的内容来高亮不同的内容.</p></blockquote><h3 id="let-形式"><a href="#let-形式" class="headerlink" title="let-@ 形式"></a><code>let-@</code> 形式</h3><p>使用<code>let @</code>后跟寄存器的名字来对寄存器赋值. 比如<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> @<span class="number">1</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> @/ = <span class="string">"good"</span></span><br><span class="line"><span class="keyword">let</span> @<span class="string">" = "</span><span class="keyword">next</span> value <span class="keyword">to</span> paste<span class="comment">"</span></span><br></pre></td></tr></table></figure></p><p>到此, 寄存器这一方面就差不多啦. 再花些时间琢磨出自己的一套使用方法吧.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后编辑时间: &lt;code&gt;2019-2-14&lt;/code&gt; , 之后会添加具体的例子.&lt;/p&gt;
&lt;p&gt;最近再次深入一下&lt;code&gt;vim&lt;/code&gt;, 这次复习了一下&lt;code&gt;vim&lt;/code&gt;的寄存器.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim&lt;/code&gt;寄存器属于那种没用过几乎不用但一用过就再也离不开的角色, 在&lt;code&gt;vim&lt;/code&gt;里面, 寄存器不仅与插件有无限的可能, 而且就算不借助任何插件, 只是使用好这些寄存器也会使你在&lt;code&gt;vim&lt;/code&gt;的编辑效率提高一个档次.&lt;/p&gt;
&lt;p&gt;物超所值, 值的学习!&lt;/p&gt;
&lt;p&gt;这次就将我复习的内容分享出来啦!&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="vim" scheme="https://memorytoco.github.io/Lago/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>linux 命令行</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/14/shell/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/14/shell/</id>
    <published>2019-02-13T22:50:56.000Z</published>
    <updated>2019-02-15T14:05:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>最后编辑时间: <code>2019-2-15</code>, 更改结构, 继续补充完善例子</p><p>所学习的 shell 语法是<strong>bash</strong>语法. 具体的命令需要查看具体的实现.</p><p>命令行的语法罗列. 快速上手shell.</p><a id="more"></a><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>在一个 shell 脚本文件中的每一行都可以作为单独命令来执行. 换句话说就是在 shell 脚本中的每一行都可以直接在 shell 中输入. shell 就是一个解释器, 类似与 python 解释器.</p><p>shell 使用<code>#</code>来进行行注释, 所有在<code>#</code>之后的内容都会被 shell 忽视.</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>变量名可以以字母或下划线<code>_</code>开头,后面跟上零个或者多个字母数字下划线.</p><p>变量的使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable=value</span><br></pre></td></tr></table></figure><p>即变量名后直接跟<code>=</code>. 注意一点, <code>=</code>两边没有空格, 变量名和值之间直接用<code>=</code>连接. 并且, shell 变量里没有类型的概念, 其所存储的都是字符串.</p><p>要使用变量, 使用<code>$variable</code>的形式, shell 在解释时会将<code>$variable</code>替换成它的值. 然后再执行命令. 如果使用一个没有赋过值的变量, 那它的值为空. 在 shell 解析命令时, 会将为空的值从命令行中删除.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> :<span class="variable">$emptyvariable</span>:</span></span><br><span class="line">::</span><br></pre></td></tr></table></figure><p>显示的将一个变量赋空值可以用这些方法:</p><ul><li><code>variable=</code> 直接留空</li><li><code>variable=&#39;&#39;</code> 显示的赋一个空的字串</li><li><code>variable=&quot;&quot;</code> 这样也行</li></ul><p>注意, <code>varialbe=&quot; &quot;</code>这种与上面的不同, 它不是一个空值, 而是将一个空格赋值给了变量.</p><h4 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h4><p>考虑下面一个情景:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> x=*</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">file1 file2 file3</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$x</span></span></span><br><span class="line">file1 file2 file3</span><br></pre></td></tr></table></figure><p>通过这里看到的结果, 那肯定是 shell 将<code>*</code>替换成了当前工作目录的内容, 那问题是, 这个替换过程是在什么时候发生的呢? 换句话就是,<code>$x</code>变量的内容是什么?</p><p>在这个例子里, 解释一下<code>echo $x</code>这行. shell 先将<code>*</code>赋值给<code>x</code>. 第一次扫描, 将<code>$x</code>替换成<code>*</code>, 得到<code>echo *</code>, 然后第二次扫描将<code>*</code>替换成当前目录中的内容, 即是<code>echo file1 file2 file3</code>.</p><p>通过我的说明, 应该就知道, shell 在给变量赋值时, 给<code>x</code>的是<code>*</code>, 也就是不会作任何的替换. 作替换的时候发生在对<code>echo $x</code>这句的解释执行上.</p><blockquote><p>shell 在给变量赋值时, 不会作出任何变化, 但是最好将赋值的内容用单引号或者双引号包起来, 因为它的内容会在求值的时候被替换. 上面的例子里, shell 就做了两次替换.</p></blockquote><h4 id="variable-结构"><a href="#variable-结构" class="headerlink" title="${variable} 结构"></a><code>${variable}</code> 结构</h4><p>如果, 只是如果. 你想将<code>file</code>重命名为<code>filex</code>, 并且在学了变量之后, 你想出了一个办法.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> name=<span class="string">'file'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv <span class="variable">$name</span> <span class="variable">$namex</span></span></span><br></pre></td></tr></table></figure><p>因为变量的值就是一个字串麻, 这么做应该行的通, 但是这里会出现一个问题. <code>$namex</code>并不会被解释为<code>$name</code>的值再加上一个字符<code>x</code>, 而是作为一个全新的变量解释. 想要避免这种情况, 就需要<code>${variable}</code>结构.</p><p>如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> name=<span class="string">'file'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv <span class="variable">$name</span> <span class="variable">$&#123;name&#125;</span>x</span></span><br></pre></td></tr></table></figure><p>这样, 结果就对了.</p><h4 id="expr-算术表达式"><a href="#expr-算术表达式" class="headerlink" title="$((expr)) 算术表达式"></a><code>$((expr))</code> 算术表达式</h4><p>在<code>$(())</code>这个操作符中, 可以进行额外的算术操作, 包括赋值.</p><p>可用操作符:</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td><code>-</code></td><td>减号</td></tr><tr><td><code>~</code></td><td>按位取反</td></tr><tr><td><code>!</code></td><td>逻辑反</td></tr><tr><td><code>*</code>, <code>/</code>, <code>%</code></td><td>乘, 除, 取余</td></tr><tr><td><code>+</code>, <code>-</code></td><td>加, 减</td></tr><tr><td><code>&lt;&lt;</code> , <code>&gt;&gt;</code></td><td>左移, 右移</td></tr><tr><td><code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code></td><td>小于等于,大于等于,小于,大于</td></tr><tr><td><code>==</code>, <code>!=</code></td><td>等于, 不等于</td></tr><tr><td><code>&amp;</code></td><td>按位与</td></tr><tr><td><code>^</code></td><td>按位异或</td></tr><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td></tr><tr><td><code>expr1 ? expr2 : expr3</code></td><td>条件运算符</td></tr><tr><td><code>=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code></td><td></td></tr><tr><td><code>+=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code></td><td></td></tr><tr><td><code>&amp;=</code>, <code>^=</code></td></tr></tbody></table><p>还有 <code>|</code> 按位或, 和 <code>||</code> 逻辑或, 以及 <code>|=</code>.</p><p>其中, <code>++</code>,<code>--</code>与<code>sizeof</code>跟具体的 shell 实现有关. 这里面的操作可以用变量, 变量必须可以解析成数字, 两边可以有空格. 同时, 如果变量未定义, 它被解释成<code>0</code>, 变量不一定要使用<code>$</code>来修饰.</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>shell 中有四种不同的引用字符: <code>&#39;</code>, <code>&quot;</code>, <code>\</code>, <code>`</code>.</p><p>由于这些都是和字串有关的, 所以这里说明一下. 基本上, shell 里面的东西都是字符串, 即使你不加这些引用, 你所输入的依然是字符串. 如果你加入了这些引用, 那么 shell 也会进行处理, 从而保证传给程序的是一个不带引用的字符串.那么, 如何传入一个带引用的字符串呢. 问得好, 这就是这一节的作用.</p><p>一个思想, 这些引用都是为了构建某个比较特殊的字符串. 比如一个<code>&#39;Hello World&#39;</code>, 这样一个带有<code>&#39;</code>的字符串.</p><p>shell 是以空白字符作为分隔符的. 这么说的意思是要明白 shell 在进行字符替换的时候并不会因为命令的不同而不同的对待字符串的替换. 同时, shell 的执行模式依旧是<code>command args</code>, 命令名作为第一个字符串, 参数通过空白字符分隔, 分别传入命令中. 以上引用的最大作用就是, 让一个<strong>特殊字串</strong>作为一个单个参数传入命令中去.</p><p>很多的奇怪问题都是因为将字串展开后误作为多个参数传给了命令. 而这些引用的难点也就是在这里.</p><h4 id="使用-39-防止字符串展开"><a href="#使用-39-防止字符串展开" class="headerlink" title="使用 &#39; 防止字符串展开"></a>使用 <code>&#39;</code> 防止字符串展开</h4><p>所有在<code>&#39;</code>里面的东西都不会被 shell 展开, 甚至是<code>Enter</code>键.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> x=<span class="string">'Hello World'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'$x'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">x</span></span><br></pre></td></tr></table></figure><h4 id="使用-quot-对字符串展开进行部分限制"><a href="#使用-quot-对字符串展开进行部分限制" class="headerlink" title="使用 &quot; 对字符串展开进行部分限制"></a>使用 <code>&quot;</code> 对字符串展开进行部分限制</h4><p>有三个特殊字符不会在<code>&quot;</code>被忽视: <code>$</code>, <code>`</code>, <code>\</code>.</p><p>在<code>&quot;</code>里面使用<code>$</code>能够完成变量名的替换, <code>\</code>来完成对特殊字符的转义.</p><h4 id="使用-来完成命令替换"><a href="#使用-来完成命令替换" class="headerlink" title="使用 ` 来完成命令替换"></a>使用 <code>`</code> 来完成命令替换</h4><p>在<code>`</code>中, 里面的字串会被识别为一个新的命令, 执行它之后将其的值代替这个字符串. 此方法不建议使用. 只做兼容性考虑.</p><h4 id="结构"><a href="#结构" class="headerlink" title="$() 结构"></a><code>$()</code> 结构</h4><p>和<code>`</code>一样, 这个是作为它的替代品出现. <code>$()</code>不仅比<code>`</code>更加容易识别, 也更加容易进行命令的嵌套. 同时在其中可以完整的使用命令行的力量. 比如管道.</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><h4 id="特殊变量-0-9"><a href="#特殊变量-0-9" class="headerlink" title="特殊变量$0-9"></a>特殊变量<code>$0-9</code></h4><p>如果有一个独立的 shell 脚本, 那么这个脚本可以通过一个叫做位置参数的特殊变量来接受命令行参数. 这些变量记为<code>$num</code>, <code>num</code>为<code>0-9</code>的数字. <code>$0</code> 默认为执行的脚本名称. 而<code>$1-9</code>为第一个, 第二个等等一直到第九个参数.</p><p>可以通过如下来验证:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$1</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$0</span></span></span><br><span class="line">bash</span><br></pre></td></tr></table></figure><h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量$#"></a>特殊变量<code>$#</code></h4><p><code>$#</code> 包含了命令行中输入的参数的个数.</p><h4 id="特殊变量-与"><a href="#特殊变量-与" class="headerlink" title="特殊变量$*与$@"></a>特殊变量<code>$*</code>与<code>$@</code></h4><p><code>$*</code> 包含了命令行中所有的参数. <code>$@</code> 与 <code>$*</code>类似, 但是在替换时, 对于<code>$*</code>, 直接用<code>$1 $2 ..</code>替换, 如果是<code>&quot;$*&quot;</code>的形式, 则会替换成 <code>&quot;$1 $2 $3 ...&quot;</code>这样. 但是对于<code>&quot;$@&quot;</code>来说, 会变成<code>&quot;$1&quot; &quot;$2&quot; ...</code>.</p><h4 id="n-特殊技法"><a href="#n-特殊技法" class="headerlink" title="${n} 特殊技法"></a><code>${n}</code> 特殊技法</h4><p>如果你传入的参数超过了 9 个, 那么可以使用上面的<code>${n}</code>技法来访问第<code>10</code>个及之后的参数.</p><h4 id="shift-命令"><a href="#shift-命令" class="headerlink" title="shift 命令"></a><code>shift</code> 命令</h4><p>如果执行<code>shift</code>, 那么位置变量的内容会左移. 同时<code>$1</code>中的内容被丢弃, <code>$#</code>减一.</p><p><code>shift n</code> 可以<code>shift</code> <code>n</code>次, 等价于执行<code>n</code>次<code>shift</code>命令.</p><hr><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p>一般格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if command_t</span><br><span class="line">then</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">else</span><br><span class="line">  command3</span><br><span class="line">  command4</span><br><span class="line">  ...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其中<code>else</code>可以省去. <code>command_t</code> 是测试条件命令, 返回一个状态码. 如果状态码为<code>0</code>, 那么执行<code>command1</code>等语句, 若<code>else</code>没有省去, 那么执行<code>command3</code>等语句, 若省去了, 则跳过. 状态码是命令执行后返回的一个整数数字, 如果非零则为异常状态, 具体是错误还是警告由程序自己决定. 如果是<code>0</code>, 则总是表示执行成功, 正常退出. 在管道中, 最后一个命令返回的状态码作为整个管道的状态码. 可以使用<code>$?</code>来获得最后一条命令退出的状态.</p><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if command_t1</span><br><span class="line">then</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">elif command_t2</span><br><span class="line">then</span><br><span class="line">  command3</span><br><span class="line">  command4</span><br><span class="line">  ...</span><br><span class="line">else</span><br><span class="line">  command5</span><br><span class="line">  command6</span><br><span class="line">  ...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>这里多出了<code>elif ... then ...</code>语句. 可以有任意个<code>elif then</code>. 如果<code>command_t1</code>结果为假, 继续求值<code>command_t2</code>, 结果为真则执行<code>command3</code>等语句, 如果为假且还有<code>elif then</code>语句, 重复上面的操作, 如果没有了, 则执行<code>else</code>后面的语句.</p><hr><p><code>/dev/null</code> 是一个特殊的设备, 在脚本中通常用于管道消除不想要的结果. 比如消去<code>grep</code>命令的显示结果, 只需要它的返回状态, 就使用<code>grep pattern file &gt; /dev/null</code>.</p><hr><p><code>test expression</code> , <code>test</code>命令会对<code>expression</code>求值, 如果结果为真, 返回<code>0</code>, 如果结果为假, 返回非零的退出状态码.</p><table><thead><tr><th>字符串操作符</th><th>含义</th></tr></thead><tbody><tr><td>string1 <code>=</code> string2</td><td>string1 等于 string2</td></tr><tr><td>string1 <code>!=</code> string2</td><td>string1 不等于 string2</td></tr><tr><td>string</td><td>string 不为空</td></tr><tr><td><code>-n</code> string</td><td>string 不为空</td></tr><tr><td><code>-z</code> string</td><td>string 为空</td></tr></tbody></table><blockquote><p>最好将测试的字符串用双引号来引用, 避免空字串被命令行删除的情况.</p></blockquote><p>在 shell 脚本中, 常常使用它的简写 <code>[ expression ]</code>, 这样就会使脚本更加明朗.</p><hr><p><code>test</code>也能对数字进行比较操作.</p><table><thead><tr><th>数字操作符</th><th>含义</th></tr></thead><tbody><tr><td>int1 <code>-eq</code> int2</td><td>int1 等于 int2</td></tr><tr><td>int1 <code>-ne</code> int2</td><td>int1 不等于 int2</td></tr><tr><td>int1 <code>-gt</code> int2</td><td>int1 大于 int2</td></tr><tr><td>int1 <code>-lt</code> int2</td><td>int1 小于 int2</td></tr><tr><td>int1 <code>-ge</code> int2</td><td>int1 大于等于 int2</td></tr><tr><td>int1 <code>-le</code> int2</td><td>int1 小于等于 int2</td></tr></tbody></table><hr><p><code>test</code>也能对文件进行判断操作.</p><table><thead><tr><th>文件操作符</th><th>含义</th></tr></thead><tbody><tr><td><code>-d</code> file</td><td>file 是一个目录</td></tr><tr><td><code>-e</code> file</td><td>file 存在</td></tr><tr><td><code>-f</code> file</td><td>file 是一个普通文件</td></tr><tr><td><code>-r</code> file</td><td>file 可读取</td></tr><tr><td><code>-s</code> file</td><td>file 不是空文件</td></tr><tr><td><code>-w</code> file</td><td>file 可写</td></tr><tr><td><code>-x</code> file</td><td>file 可执行</td></tr><tr><td><code>-L</code> file</td><td>file 是一个符号链接</td></tr></tbody></table><hr><p><code>test</code> 逻辑操作符.</p><table><thead><tr><th>操作符</th><th>作用</th></tr></thead><tbody><tr><td><code>!</code></td><td>逻辑否定操作符, 可以放在任意的表达式之前, 否定该表达式的结果</td></tr><tr><td><code>-a</code></td><td>逻辑与, 放在两个表达式之间, 执行逻辑与</td></tr><tr><td><code>-o</code></td><td>逻辑或, 放在两个表达式之间, 执行逻辑或</td></tr></tbody></table><p><code>test</code> 可以使用<code>()</code>来改变求值顺序, 不过需要用<code>\</code>来转义, 避免被shell解释. 括号可以放在表达式两边并且括号需要作为一个独立的参数传给<code>test</code>, 这就意味着每个括号两边需要使用空格与其它参数分离.</p><h4 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a><code>case</code> 语句</h4><p>一般格式如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">case value in</span><br><span class="line">pattern1 )</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandn;;</span><br><span class="line">pattern2 )</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandn;;</span><br><span class="line">...</span><br><span class="line">patternn )</span><br><span class="line">    ...</span><br><span class="line">    commandn;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><p>不必多说, <code>case</code>将<code>value</code>与每个<code>pattern</code>进行匹配, 如果匹配成功, 那么执行其下面的一系列命令. 如果什么都不匹配, 不做任何事情. <code>pattern</code>与<code>)</code>之间可以没有空格.</p><p>同时, <code>pattern</code>也可以使用<strong>通配符</strong>. <code>?</code>匹配任意一个字符, <code>*</code>匹配零个或多个任意字符, <code>[ ... ]</code>则匹配其中出现的字符. 这个在命令行中的一样. 同时可以使用<code>|</code>. <code>pattern1 | pattern2 )</code>, 这个表示满足<code>pattern1</code>或者满足<code>pattern2</code>都会执行这里的命令. <code>|</code>效果等同于逻辑<strong>或</strong>.</p><h4 id="空语句"><a href="#空语句" class="headerlink" title="空语句:"></a>空语句<code>:</code></h4><p>正如你所想的那样, 这是一个空语句, 相当于<code>c</code>中的单个<code>;</code>. 它可以被认为是命令的占位符, 在某些要求必须有命令的地方而你又不希望执行什么操作的时候, 可以使用<code>:</code>. 最好在<code>:</code>附近加上注释.</p><h4 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp; 和 ||"></a><code>&amp;&amp;</code> 和 <code>||</code></h4><p>这两个操作符可以通过判断之前执行命令的退出状态来决定是否执行接下来的命令, 如此往复.</p><p><code>command1 &amp;&amp; command2 &amp;&amp; ... &amp;&amp; commandn</code> 这种形式会先执行<code>command1</code>. 如果其退出的状态码为<code>0</code>, 那么执行<code>command2</code>, 如果不是<code>0</code>, 那么跳过接下来所有的命令. 对于接下来的命令, 重复之前的判断操作.</p><p><code>||</code>的效果与<code>&amp;&amp;</code>正好相反. 如果前一个命令正常退出的话, 结束. 否则执行后面的命令.</p><h4 id="exit-n-语句"><a href="#exit-n-语句" class="headerlink" title="exit n 语句"></a><code>exit n</code> 语句</h4><p>使用 <code>exit n</code>来从任意的地方退出脚本. 返回<code>n</code>状态码. 如果<code>n</code>被省去了, <code>exit</code> 相当于 <code>exit $?</code>.</p><hr><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>循环可以按照特定的次数或者终止条件执行一组命令. 有<code>for</code>, <code>while</code>, <code>until</code> 这三个命令.</p><h4 id="for命令"><a href="#for命令" class="headerlink" title="for命令"></a><code>for</code>命令</h4><p>一般形式:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for var in word1 word2 ... wordn</span><br><span class="line">do</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p><code>do</code>和<code>done</code>之间的称作<strong>循环体</strong>, 在执行时, 首先把<code>word1</code>赋值给<code>var</code>, 执行循环体, 再把<code>word2</code>赋值给<code>var</code>, 执行循环体, 如此往复一直到<code>wordn</code>.</p><p><code>for</code>也可以不带字符列表.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for var</span><br><span class="line">do</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>那么<code>for</code>会自动遍历命令行中的参数.</p><h4 id="while命令"><a href="#while命令" class="headerlink" title="while命令"></a><code>while</code>命令</h4><p>一般形式:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while command_t</span><br><span class="line">do</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>如果<code>command_t</code>返回<code>0</code>, 那么执行循环体中的内容. 执行后再次执行<code>command_t</code>, 执行循环体. 如此循环, 直到<code>command_t</code>返回了一个非<code>0</code>状态码. 如果一开始<code>command_t</code>返回非零状态码, 循环体一次都不会执行.</p><h4 id="until命令"><a href="#until命令" class="headerlink" title="until命令"></a><code>until</code>命令</h4><p>一般形式:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">until command_t</span><br><span class="line">do</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>和<code>while</code>类似, 但是相反.  当<code>command_t</code>返回<code>0</code>时, 循环体不执行, 否则执行循环体, 执行逻辑与<code>while</code>一致.</p><h4 id="循环的后台执行-done-amp"><a href="#循环的后台执行-done-amp" class="headerlink" title="循环的后台执行 done &amp;"></a>循环的后台执行 <code>done &amp;</code></h4><p>只要在<code>done</code>后边添加一个<code>&amp;</code>就可以是循环后台运行.</p><h4 id="闭合语句fi-done-esac的管道重定向"><a href="#闭合语句fi-done-esac的管道重定向" class="headerlink" title="闭合语句fi,done,esac的管道重定向"></a>闭合语句<code>fi</code>,<code>done</code>,<code>esac</code>的管道重定向</h4><p>在闭合语句后边可以使用管道与重定向. 重定向会改变代码块中所有命令的输入输出.</p><h4 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a><code>break</code> 与 <code>continue</code></h4><p><code>break</code> 用于退出循环, <code>break n</code>用于退出<code>n</code>层循环.<br><code>continue</code>用于跳过循环, <code>continue n</code>用于跳过<code>n</code>次循环.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后编辑时间: &lt;code&gt;2019-2-15&lt;/code&gt;, 更改结构, 继续补充完善例子&lt;/p&gt;
&lt;p&gt;所学习的 shell 语法是&lt;strong&gt;bash&lt;/strong&gt;语法. 具体的命令需要查看具体的实现.&lt;/p&gt;
&lt;p&gt;命令行的语法罗列. 快速上手shell.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="linux shell" scheme="https://memorytoco.github.io/Lago/tags/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title>博客功能说明</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/12/blogIntro/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/12/blogIntro/</id>
    <published>2019-02-11T23:36:26.000Z</published>
    <updated>2019-02-14T13:52:01.600Z</updated>
    
    <content type="html"><![CDATA[<p>简要的说明一下辅助博客的文章类别以及其作用吧.<br>如果使用结果不错的话, 就将它搬到<code>Lasga</code>中去.<br>最主要的也是方便阅读这个博客的人.</p><a id="more"></a><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>这篇博客的所有由文章暂分三类, 分别是<strong>笔记</strong>, <strong>漫谈</strong>, <strong>教程</strong>.</p><p>所有的笔记都是跟随一本书随阅读进度进行更新的, 内容主要是针对一些我觉得比较关键的点的罗列, 可能会附加一些个人的思考. 笔记自有一套自己的更新规则, 一般不会跟随书的目录章节更新, 而是受到自己的学习进程影响, 有时可能会针对某一个点额外的发布文章, 届时会在笔记中加入链接.</p><blockquote><p><code>笔记不一定十分准确</code>, 但会一直更新. 已发布的也会更新. 毕竟个人知识总会有差错, 随着个人经验的积累也会有进步嘛. 这个笔记是跟着我本地的笔记更新的, 一旦我有了比之前更加深刻的认识, 就会去更新笔记.</p></blockquote><blockquote><p>现在会在笔记开头部分写下更新时间. 以供参考.</p></blockquote><p>漫谈则如其名, 主题不明, 谈谈对于一些技术, 对于计算机科学理论的理解等等…</p><blockquote><p>已发布的漫谈一般不会再更新, 如有错误, 会另起一篇来说明.</p></blockquote><p>教程往往是有关一个主题的, 拥有一个唯一的<em>tag</em>, 可以在<em>tags</em>一栏中选择来进行阅读.具体的信息会在教程中进行发布.</p><blockquote><p>教程会随时间动态更新.</p></blockquote><h3 id="关于更新"><a href="#关于更新" class="headerlink" title="关于更新"></a>关于更新</h3><p>会有更新的文章或者会持续更新的文章会有一个 <strong>最后编辑时间</strong> 的标签, 一般在预览界面就能看到, 后面跟着最后的更新时间和一些简短的关于这篇文章的信息.</p><p>有的文章可能不会有这种标签但仍在更新中, 这类一般是博客的规则类内容, 比如你正在阅读的一篇.</p><p>以上…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简要的说明一下辅助博客的文章类别以及其作用吧.&lt;br&gt;如果使用结果不错的话, 就将它搬到&lt;code&gt;Lasga&lt;/code&gt;中去.&lt;br&gt;最主要的也是方便阅读这个博客的人.&lt;/p&gt;
    
    </summary>
    
    
      <category term="MISC" scheme="https://memorytoco.github.io/Lago/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>真象还原之零</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/10/truthaboutSys_0/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/10/truthaboutSys_0/</id>
    <published>2019-02-09T22:13:01.000Z</published>
    <updated>2019-02-14T13:52:18.303Z</updated>
    
    <content type="html"><![CDATA[<p>最后编辑时间: <code>2019-2-12</code></p><p>这个是阅读<strong>操作系统真象还原</strong>的笔记. 记录学习系统一些知识点.<br>同时和<strong>深入理解计算机操作系统</strong>一起. 希望学完系统能让我更加方便的学习汇编与二进制.</p><a id="more"></a><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>常见 cpu 字节序:</p><ul><li>大端字节序: <code>IBM, Sun, PowerPC</code></li><li>小端字节序: <code>x86, DEC</code><blockquote><p><code>ARM</code> 系的大小通吃<br>网络字节序是大端字节序</p></blockquote></li></ul><hr><p>指令集与微架构:</p><p>对于指令集来说有两种指令体系, 分别是<code>CISC</code>和<code>RISC</code>两个.指令集则是类似于协议的存在.AMD 和 Intel使用同一种指令集,但是他们各自对于cpu的硬件实现不同,而这个<em>硬件实现</em>就称之为<em>微架构</em>.</p><p>目前存在的指令集共有5种, 分别是 <code>x86(Intel), ARM, MIPS, Power, C6000</code>.其中只有<code>x86</code>是是属于CISC体系的.</p><hr><p>整个系统的启动过程简述(个人理解):</p><p>电源通电后, 硬件开机自检. 硬件是如何知道这时候需要自检的呢? 是<strong>BIOS</strong>通知它们的.<strong>BIOS</strong> 如上所述, 是基本的输入输出系统. 没有太多的功能, 它的目的就是为了在整个开机接力赛中传递这第一棒. 在通知个硬件自检后, 它就会将接力棒传给<strong>MBR</strong>. <strong>MBR</strong>就是主引导程序. 如果折腾过linux, 那么可以把这个<strong>GRUB</strong>想象成<strong>MBR</strong>. 这么说或许就清楚点了.随后<strong>MBR</strong>会寻找<strong>OBR</strong>, 将主导权交给对应系统的引导程序. 可以把grup上的一些系统选项想象成系统引导程序. 最后, 主导权再由<strong>OBR</strong>交接给系统内核. 至此, 系统就正常启动啦.</p><blockquote><p>如果你不仅折腾过linux, 还想过把它和windows一起装在机器里, 那么你一定会使用双启动这方案. 折腾过双系统的人一定会碰到过这种情况:</p></blockquote><blockquote><p>在把linux安装完成后, 开机就是grub, windows则消失不见了. 如果需要再次引导windows则需要配置一下grbu才行. 反之, 如果在存在linux系统的情况下安装或者重装windows系统, 则会发现开机直接进入windows了. 出现这种情况是因为windows系统在安装的时候会把自己的引导程序放到<strong>MBR</strong>中去, 这就会造成机器启动的时候直接执行此时<strong>MBR</strong>上的内容. 这时候<strong>MBR</strong>上存放的是windows的引导器, 所以windows就会直接启动, linux就被撂在一旁,可怜兮兮,无人搭理.</p></blockquote><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ul><li><code>elf</code> : <code>executable and linking format</code></li><li><code>readelf -e elf</code> 用来查询程序中段的类型. (其中 <code>elf</code> 是文件名)</li><li><code>GDT</code> : <code>Global Descriptor Table</code> 全局描述符表, 表中的每一项被称为段描述符.</li><li>描述符 : 描述某种数据的数据结构, 是元信息.</li><li>堆 : 程序运行过程中用于动态内存分配的内存空间, 由操作系统分配划分.</li><li>堆栈,栈 : 同指栈, 硬件必须.</li><li>大端字节序和小端字节序<blockquote><p>小端字节序是数值的低字节存放在内存的低地址出,高字节存放在高地址处.<br>大端字节序与小端字节序相反.</p></blockquote></li><li><code>IVT</code> : <code>Interrupt Vector Table</code> 中断向量表.</li><li><code>CISC</code> : <code>Complex Instruction Set Computer</code> 复杂指令集计算机</li><li><code>RISC</code> : <code>Reduced Instruction Set Computer</code> 精简指令集计算机</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>我原本对<strong>位,比特,字节</strong>这些东西一直记不住,现在搞清了赶紧记下来.</p><blockquote><p>一个位即是一个 bit(比特),是最最小的数据单位,没有比它更小的了.</p></blockquote><blockquote><p>一个字节是 8 位,写作 byte, 换算关系为 <em>1 byte</em> = <em>8 bits</em> .<br>而内存的分布是以 byte 为基本单位的,也就是那些内存地址的单位都是 byte.</p></blockquote><p>另外一点容易弄混的是对于数据大小的判别. 首先分清这个十六进制数是一个存在内存里的数还是一个地址. 如果是数那么计算的单位是<code>bit</code>即位. 将这个数字换成一<code>二进制</code>串,其长度就是其大小,当然单位为<code>bit</code>. </p><blockquote><p>比如 <code>0xac2</code> 这个十六进制数所占的内存大小为12位,由于字节是8位,这里采用向上取整的方法为2字节. 二进制数为 <code>b101011000010</code>.</p></blockquote><p>如果是要看这个数本身的大小,则通过进制转换成十进制数即可.</p><blockquote><p>那么还是上面的例子, <code>0xac2</code> 这个数的大小可以通过十六进制转换为十进制即可.</p></blockquote><p>于是在具体的计算一个数字的”大小”的时候最好分清这个”大小”的意义所在.</p><hr><p>另外再提一句, 计算机内存是以<code>0</code>开始计算的. 同时, 对于一个地址从 <code>0x001</code> 到<code>0x003</code> 这样的一个地址段, 它的容量是<code>3</code>. 即末地址减去起始地址再加一.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后编辑时间: &lt;code&gt;2019-2-12&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个是阅读&lt;strong&gt;操作系统真象还原&lt;/strong&gt;的笔记. 记录学习系统一些知识点.&lt;br&gt;同时和&lt;strong&gt;深入理解计算机操作系统&lt;/strong&gt;一起. 希望学完系统能让我更加方便的学习汇编与二进制.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="ComputerSystem Asm" scheme="https://memorytoco.github.io/Lago/tags/ComputerSystem-Asm/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/10/Hello-World/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/10/Hello-World/</id>
    <published>2019-02-09T21:18:39.000Z</published>
    <updated>2019-02-12T07:57:08.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不-我没有放弃flax"><a href="#不-我没有放弃flax" class="headerlink" title="不, 我没有放弃flax!"></a>不, 我没有放弃flax!</h2><p>这里做一些说明吧.<br>基于现在的情况, 暂时使用<code>hexo</code>.</p><a id="more"></a><h3 id="现在你用了hexo建了博客-原来的flax呢"><a href="#现在你用了hexo建了博客-原来的flax呢" class="headerlink" title="现在你用了hexo建了博客,原来的flax呢?"></a>现在你用了<code>hexo</code>建了博客,原来的<code>flax</code>呢?</h3><p>emmm, 首先这两者不冲突. <code>flax</code> 的开发还在继续,并没有弃坑.</p><blockquote><p>我这个寒假一半的时间都耗在上面了,怎么可能弃坑呢! 并且我相信最终的它会给你们带来惊喜!</p></blockquote><p>然后主要现在在开发<code>flax</code>上遇挫, 遭遇了一个瓶颈.<br>一来迟迟不能让整个工作流程建立起来,<br>二来我也等不及了,<br>三来看到的一些东西让我对<code>flax</code>的期望(或者说是野心)增加了,结果让这个成型日期更加的延后.</p><h3 id="这个-Lago-是干什么的"><a href="#这个-Lago-是干什么的" class="headerlink" title="这个 Lago 是干什么的?"></a>这个 <code>Lago</code> 是干什么的?</h3><p>这个博客用于</p><ul><li>记笔记, 把一些想要分享的东西及时的贴出来</li><li>学习 <code>hexo</code>, 给 <code>flax</code> 铺路</li><li>进行知识输出</li><li>摸索自己的需求</li><li>作为一个辅助博客出现, 同时兼顾 <code>flax</code>的动态信息</li></ul><p>由于 <code>flax</code> 还在开发中, 我就没法着手关于博客页面相关的研究.<br>这就让整个进度异常缓慢, 非常摧残我的小心灵!! 所以这个博客就是一个试探.</p><blockquote><p>我在写<code>flax</code>的时候也对网站没什么概念, 用上这个来学习学习.</p></blockquote><blockquote><p>我最近一直在尝试建立起个人的学习体系, 其中的一环就是博客.<br>现在这个比重还在持续上升中.</p></blockquote><h3 id="那-flax-有什么动作吗"><a href="#那-flax-有什么动作吗" class="headerlink" title="那 flax 有什么动作吗?"></a>那 <code>flax</code> 有什么动作吗?</h3><p>有, 现在 <code>flax</code> 已经有了一个伪 <strong>hook</strong> 系统. 受到 <code>chez-scheme</code> 的逼迫,我不得不改变原先的工作机理, 摆脱对 <code>guile</code> 实现的依赖, 于是绞尽脑汁捉摸出了一个基于<strong>链表</strong> 这个数据结构的的系统, 终于可以在 <strong>新的</strong> 的实现上跑起来了.</p><blockquote><p>我也深刻的意识到了基本功的重要性. (转来转去, 我依然是在用我之前接触到的东西)</p></blockquote><p>出乎意料的是我发现这个改变得到的收益比我想象中的还要多. 于是我又想在这个基础上看看能不能琢磨出一个 <code>trigger</code> 系统出来, 再给它加上一些额外的支持.</p><p>由于原来的 <code>flax</code> 是我基于 <a href="https://dthompson.us/projects/haunt.html" target="_blank" rel="noopener">guile haunt</a> 一点一点<code>抄</code> 过来的, 所以有很多的思路都受到限制( 还是我自己脑补的思路… ), 现在正在努力的一点一点突破限制.</p><p>我现在还在继续扩展<code>flax</code>, 并且边用 <code>hexo</code> 边观察它的运作方式. 希望获得启发吧.</p><h2 id="所谓的-Flax-动态在哪里"><a href="#所谓的-Flax-动态在哪里" class="headerlink" title="所谓的 Flax 动态在哪里?"></a>所谓的 <code>Flax</code> 动态在哪里?</h2><p>在这个博客的页面可以看到一栏 <code>Flax</code>, 那里有一些关于 <code>Flax</code> 的信息.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不-我没有放弃flax&quot;&gt;&lt;a href=&quot;#不-我没有放弃flax&quot; class=&quot;headerlink&quot; title=&quot;不, 我没有放弃flax!&quot;&gt;&lt;/a&gt;不, 我没有放弃flax!&lt;/h2&gt;&lt;p&gt;这里做一些说明吧.&lt;br&gt;基于现在的情况, 暂时使用&lt;code&gt;hexo&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Misc Flax Hexo" scheme="https://memorytoco.github.io/Lago/tags/Misc-Flax-Hexo/"/>
    
  </entry>
  
</feed>
