<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lago</title>
  
  
  <link href="/Lago/atom.xml" rel="self"/>
  
  <link href="https://memorytoco.github.io/Lago/"/>
  <updated>2019-03-04T03:38:24.124Z</updated>
  <id>https://memorytoco.github.io/Lago/</id>
  
  <author>
    <name>Memorytoco</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在linux上学习汇编的必备工具</title>
    <link href="https://memorytoco.github.io/Lago/2019/03/04/nasm_3/"/>
    <id>https://memorytoco.github.io/Lago/2019/03/04/nasm_3/</id>
    <published>2019-03-03T17:37:18.000Z</published>
    <updated>2019-03-04T03:38:24.124Z</updated>
    
    <content type="html"><![CDATA[<p>前面的王爽的书是给我对于汇编的基本的感性认识， 培养对汇编代码的”亲切度”.但是对 8086 的这么一点”感性认知”对于实际的汇编开发没有任何用处. 读完书后会有一种离了书依然什么都不会的感觉. 为了摆脱这个状态, 就要继续学习真实的汇编代码与应用. 之后依然会专注于硬件上的应用, 再之后才是<code>elf</code>格式学习.</p><p>不过在继续前行之前, 还要介绍一些辅助工具, 这样在学习的过程中能够更好的理解汇编代码和事物的运行方式.</p><p>以下的工具和命令都假设使用的系统平台是 64 位 linux, 发行版不限.</p><a id="more"></a><h2 id="nasm-汇编器合集"><a href="#nasm-汇编器合集" class="headerlink" title="nasm 汇编器合集"></a>nasm 汇编器合集</h2><p>关于<code>nasm</code>的语法知识在前两个<code>post</code>中解释说明了, 那里的东西已经基本够用. 如果在实验中需要引入新的点,那么会在实验中介绍.</p><p>现在继续介绍关于<code>nasm</code>工具的使用方法, 以及与<code>nasm</code>配套的一系列工具.</p><h3 id="nasm-基本使用"><a href="#nasm-基本使用" class="headerlink" title="nasm 基本使用"></a>nasm 基本使用</h3><p>在之后的学习中， 如果还是在 x86 实模式下进行的学习， 那么直接使用<code>nasm code.asm -o the_output_binary</code>这个格式就可以了. 潜在的选项是<code>-f bin</code>, 指定输出格式为<strong>纯二进制</strong>, 也就是可以直接将这个二进制数据块放入内存供 cpu 执行的格式. 相对的, 如果之后不是在实模式下继续学习, 而是想要在 linux 的 shell 里面进行调用执行(类似于一个由 c 编译的执行文件一样), 那么我们就要根据所选择的平台选择相应的输出格式. 在之前我已经限定了这个平台, 那么在 64 位的 linux 平台上, 需要指定格式为<code>elf64</code>, 同时在编码时需要遵循相应的调用规范, 没有实模式下那么随心所欲.</p><p>既然又所谓的<strong>纯二进制</strong>, 那么也相对的会有<strong>非纯二进制</strong>, 这里<strong>非纯二进制</strong>的意思是生成的二进制指令文件中存在不能由 cpu 识别的东西存在, 而这部分是供操作系统来使用的, 毕竟我们之前都是工作在实模式下(没有操作系统存在的情况, 直接和 cpu 进行交互), 意识到这两者的区别应该会比较容易. 那么, 系统使用这些二进制信息获取必要的条件设定, 此时这个二进制的执行就是作为用户态的一个进程,由操作系统进行监控和管理. 是的, 有了系统才有了进程这个概念. 同时, 不同的系统平台有不同的格式, 比如 windows 就有<code>PE</code>格式, 而 32 位 linux 有<code>elf32</code>格式, 同时还有其他我们很少接触的平台, 他们也各自有各自的格式. 这也意味着这些不同的格式将不能被这些平台共享, 需要针对特殊的平台进行编译.</p><p>关于 nasm 的就介绍这么多, 只要记着实模式下直接使用<code>bin</code>模式就行, 并且记得使用<code>-f</code>选项指定格式.</p><h3 id="ndisasm-反汇编工具"><a href="#ndisasm-反汇编工具" class="headerlink" title="ndisasm 反汇编工具"></a>ndisasm 反汇编工具</h3><p>这个反汇编工具在之后的探索中会起到很大的作用, 主力军之一. 不同于<code>objdump</code>, 它的功能很简单, 只是将所给的文件反汇编而已. 它不理解任何的<code>obj</code>,<code>elf</code>或者<code>pe</code>格式. 这个对于学习在硬件下的汇编很有帮助. 要使用它, 我们只是简单的<code>ndisasm file</code>调用<code>ndisasm</code>命令而已. 结果会写入标准输出中. 同时, 可以使用<code>-b</code>选项指定 cpu 的模式是<code>16</code>位,<code>32</code>位还是<code>64</code>位. 使用<code>-p</code>选项指定指令集. 比如 <code>intel</code>, <code>amd</code>, <code>cyrix</code>和 <code>idt</code>. 然后还有<code>-e</code>和<code>-o</code>选项, 这个到时碰到再说.</p><p>简单总结就是<code>ndisasm file</code> 这个基本格式. 它应该能够满足之后的大部分需求.</p><h2 id="Bochs-虚拟机调试工具"><a href="#Bochs-虚拟机调试工具" class="headerlink" title="Bochs 虚拟机调试工具"></a>Bochs 虚拟机调试工具</h2><p>这个相较与上面两个有点麻烦, 设计的概念有点多, 不过我也会将之后需要的提炼出来, 不要分散学习的注意力.</p><p>首先, 这是一个虚拟机, 因此不必担心你的汇编代码会破坏你的计算机, 不, 他只会破坏这个虚拟机而已. 由于虚拟机是一个软件, 最坏的情况也就是软件崩溃而已. 大可放心. 同时, 它也提供了一个类似硬件的模拟环境. 使用这个虚拟机,就相当于我们在一个真实的裸机上执行代码一样, 是一个真实的硬件. 在之后, 我们也会见到如何操纵它模拟的输入输出硬件.</p><p>同时, 如果想要运行它的话, 除了它本身的执行文件(<code>Bochs</code>命令), 还缺少一个<strong>配置文件</strong>和一个<strong>启动硬盘</strong>. 这里, 在不介绍具体的原理的时候, 我给出了具体的过程.</p><p>配置文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">cpu: model=core2_penryn_t9600, count=1, ips=50000000, reset_on_triple_fault=1, ignore_bad_msrs=1, msrs=&quot;msrs.def&quot;</span><br><span class="line">cpu: cpuid_limit_winnt=0</span><br><span class="line"></span><br><span class="line">memory: guest=512, host=256</span><br><span class="line"></span><br><span class="line">romimage: file=$BXSHARE/BIOS-bochs-latest, options=fastboot</span><br><span class="line"></span><br><span class="line">vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line">mouse: enabled=0</span><br><span class="line"></span><br><span class="line">pci: enabled=1, chipset=i440fx</span><br><span class="line"></span><br><span class="line">private_colormap: enabled=0</span><br><span class="line"></span><br><span class="line">floppya: 1_44=/dev/fd0, status=inserted</span><br><span class="line"></span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata1: enabled=0, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11</span><br><span class="line">ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9</span><br><span class="line"></span><br><span class="line">ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat</span><br><span class="line"></span><br><span class="line">boot: disk</span><br><span class="line"></span><br><span class="line">floppy_bootsig_check: disabled=0</span><br><span class="line"></span><br><span class="line">log: bochsout.txt</span><br><span class="line"></span><br><span class="line">panic: action=ask</span><br><span class="line">error: action=report</span><br><span class="line">info: action=report</span><br><span class="line">debug: action=ignore, pci=report # report BX_DEBUG from module &apos;pci&apos;</span><br><span class="line"></span><br><span class="line">debugger_log: -</span><br><span class="line"></span><br><span class="line">parport1: enabled=1, file=&quot;parport.out&quot;</span><br></pre></td></tr></table></figure><p>将其复制保存为<code>bochsrc.txt</code>即可.</p><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">times 1024*1024*60 db 0x00</span><br></pre></td></tr></table></figure><p>使用上面的汇编代码, 假设保存为<code>hd60M.asm</code>, 那么使用 <code>nasm hd60M.asm -o hd60M.img</code>这个命令. 这个就是之后的启动盘, <code>60M</code>大小. 根据计算机性能, 可能会”卡”一段时间.</p><p>我知道在其他的教程中, 可能会用<code>bximage</code>工具(随 bochs 一起发布)来”创建”一个”启动盘”, 这里我打上双引号就是因为这种描述和事实不尽相符, 比起实际的具体操作事实, 它更像一个目的的描述. 比起, 我使用这个工具执行一系列操作创建了一个”启动盘”, 倒不如说我是为了创建一个”启动盘”而执行这个操作. 之后需要关注的是这个”操作”而不是”创建了一个启动盘”这个”结果”. 也就是为什么这个工具能够”创建”一个”启动盘”, 我们自己可以使用其他的方法来达到同样的目的吗? 同样的, “启动盘”这个描述也不太妥当, 它也和事实不尽相符. 因为实际上, 如果没有”MBR”(主引导扇区)的话, 它并不能被称为一个”启动盘”, 因此它也更像一个目的的描述. 我创建了这个”启动盘”, 倒不如说成我创建了这个东西, 为了让它之后充当”启动盘”. 那么, 这个东西是什么呢? 继续看下去!</p><p>不过, 别急, 在继续之前, 你已经可以键入<code>bochs</code>来试着执行一下了. 不出意外的话, 你会进入一个选单界面, 不过, 我们只要<code>Enter</code>就行了. 继续执行后, 会报错, 它会抱怨这个”东西”不是一个可用的启动盘. 这也印证了我的说法. 点击<code>quit</code>退出, 然后命令行里面输入<code>q</code>退出<code>bochs</code>.</p><p>这里的我不使用这个附带的工具(以后会用到), 而是通过一行汇编代码来达成这个目的. 之后具体实践了之后, 你会意识到这一行的作用. 同时, 你也会意识到<code>nasm</code>为我们所做的事情到底是什么. 不过如果只是实模式下的”启动盘”的话, 还可以使用<code>dd</code>来创建. 我列举这些创建的方式就是想提醒你, 要意识到供给<code>bochs</code>启动盘的本质. 它只是一个数据块而已(不够似乎对大小有着限制). 如果在这个时候, 你使用<code>file</code>的话, 它就会告诉你, 这是一个数据文件(data). 由此, 我们知道, 这个东西是一个<strong>数据文件</strong>. 而有的启动盘则有一定的”格式”, 那么这个启动盘的制作可能就有点麻烦了, 还是老老实实的使用提供的<code>bximage</code>工具吧.</p><p>关于上面的讨论, 你可能会感到非常困惑, 可能会不相信. 那么同样的, 我们再使用<code>bximage</code>这个工具创建一个”启动盘”. 然后将这个”启动盘”和我们之前的相对比. 输入<code>bximage</code>, 选择<code>1</code>, 然后大小输入<code>60</code>,最后名字填入<code>test</code>, 其他的选择默认的选项即可. 所以最后的输入操作顺序应该是<code>1, Enter[hd], Enter[flat], 60, test</code>, 这里的<code>[]</code>表示默认提供的选项内容. 然后我们再次使用<code>file</code>来鉴别一下, 再次使用<code>diff</code>工具比较一下我们自己的数据文件和<code>bximage</code>创建的文件的区别. 那么, 得到结果后, 讨论结束.</p><p>最后还要加上一个<code>512</code>字节的<code>MBR</code>到这个<code>hd60M.img</code>数据文件中, 以让它成为”启动盘”.</p><p><code>MBR</code>的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">section main vstart=0x7c00</span><br><span class="line"></span><br><span class="line">mov ax, 0x07c0</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ax, 0xb800</span><br><span class="line">mov es, ax</span><br><span class="line"></span><br><span class="line">;; 清屏</span><br><span class="line">mov ax, 0x600</span><br><span class="line">mov bx, 0x700</span><br><span class="line">mov cx, 0</span><br><span class="line">mov dx, 0x184f</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">mov cx, 12</span><br><span class="line">mov di, 0</span><br><span class="line">mov si, 0</span><br><span class="line">mov bx, data-$$</span><br><span class="line"></span><br><span class="line">sendnow:</span><br><span class="line">mov byte al, [bx+di]</span><br><span class="line">mov byte ah, 0x07</span><br><span class="line">mov word [es:si], ax</span><br><span class="line">add di, 1</span><br><span class="line">add si, 2</span><br><span class="line">loop sendnow</span><br><span class="line"></span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">data:</span><br><span class="line">db &apos;Hello, World&apos;</span><br><span class="line"></span><br><span class="line">times 510-($-$$) db 0x00</span><br><span class="line">db 0x55, 0xaa</span><br></pre></td></tr></table></figure><p>假设将上面的代码保存为<code>mbr.asm</code>, 使用<code>nasm</code>命令将其编译为<code>mbr</code>文件, 然后使用<code>dd</code>命令, 将这个<code>mbr</code>文件写入到我们得到的<code>hd60M.img</code>数据文件中.</p><p>使用<code>dd if=mbr of=hd60M.img bs=512 count=1 conv=notrunc</code>.</p><p>最后最后, 键入<code>bochs -q</code>. 如果弹出了一个窗口, 并且命令行有了<code>bochs:n&gt;</code>提示, <code>n</code>是一个数字, 一开始是<code>1</code>. 那么你离设置成功就只有 1%的路程了, 最后在命令行中输出<code>c</code>. 如果窗口中输出了<code>Hello World</code>, 那么恭喜你, 成功配置了<code>bochs</code>.</p><p>想要退出的时候, <code>Ctrl-c</code>退出循环, 然后按<code>q</code>退出.</p><p>bochs 告此一段落.</p><h2 id="dd-命令"><a href="#dd-命令" class="headerlink" title="dd 命令"></a>dd 命令</h2><p>关于这个命令, 如果有装机的经验, 就会在处理<code>iso</code>和”启动盘”时常见到它. 对它真是既爱又恨. 它十分的强大, 能够随意的渗透到<strong>任意的二进制文件</strong>中, 然后它又是所有系统崩坏的直接推手(还不是自己菜…).</p><p>不过, 我们这里只是用到这个命令而已<code>dd if=mbr of=hd60M.img bs=512 count=1 conv=notrunc</code>. 这个就够了, 如果有别的需求, 再次补充. 这里面的<code>mbr</code>替换成之后使用<code>nasm</code>编译的 mbr 二进制文件.</p><p>这个命令的含义就是, 从<code>mbr</code>中提取数据(<code>if</code>=<code>input file</code>), 将数据写入到<code>hd60M.img</code>(<code>of</code>= <code>ouput file</code>)中, 分的区块大小是<code>512</code>字节, 总共一个区块<code>count=1</code>, 同时在写入的时候不要将目标文件截断(按照这里的例子就是<code>hd60M.img</code>汇编成<code>512</code>字节大小).</p><p>暂时介绍这么多, 其他的可以自行搜索<code>nasm</code>查询你官方手册, 或者使用<code>man nasm</code>和<code>nams --help</code>来获取更多的描述.</p><p>注意到, 在计算机上, 所有的文件都是一个<strong>二进制文件</strong>. 有意识到什么吗? 可以搜索一下<code>dd</code>的基本教程, 或者现在就想想是不是可以使用这个命令来<strong>复制</strong>一个文本文件?</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面的王爽的书是给我对于汇编的基本的感性认识， 培养对汇编代码的”亲切度”.但是对 8086 的这么一点”感性认知”对于实际的汇编开发没有任何用处. 读完书后会有一种离了书依然什么都不会的感觉. 为了摆脱这个状态, 就要继续学习真实的汇编代码与应用. 之后依然会专注于硬件上的应用, 再之后才是&lt;code&gt;elf&lt;/code&gt;格式学习.&lt;/p&gt;
&lt;p&gt;不过在继续前行之前, 还要介绍一些辅助工具, 这样在学习的过程中能够更好的理解汇编代码和事物的运行方式.&lt;/p&gt;
&lt;p&gt;以下的工具和命令都假设使用的系统平台是 64 位 linux, 发行版不限.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="nasm" scheme="https://memorytoco.github.io/Lago/tags/nasm/"/>
    
  </entry>
  
  <entry>
    <title>nasm 基础之编译器指令</title>
    <link href="https://memorytoco.github.io/Lago/2019/03/01/nasm_2/"/>
    <id>https://memorytoco.github.io/Lago/2019/03/01/nasm_2/</id>
    <published>2019-03-01T01:37:18.000Z</published>
    <updated>2019-02-28T18:14:04.580Z</updated>
    
    <content type="html"><![CDATA[<p>这个紧随之前的基本语法, 要把这个看完才能基本看懂<code>nasm</code>风格的代码. 当然也可以看不懂的时候再来看就是了. 其中有些只是列出了指令名, 这是出于强迫症考虑的. 虽然不大可能用得到, 但还是写上, 之后若要用再来补充就是了. 还有一些指令直接将原来的复制来了, 这是因为我也不明白它的作用, 不好翻译. 所以直接贴原文, 不过只有一个指令.</p><a id="more"></a><hr><p><code>nasm</code>的汇编指令分为基础指令(primitive instruction)和用户级指令(user-level instruction).</p><p>基础指令是被<strong>方括号</strong>包围的, 而用户级指令不需要.</p><p>然后对应于不同的输出格式, 可能有不同的额外的指令.</p><h2 id="指定目标处理器模式-Specifying-Target-Processor-Mode"><a href="#指定目标处理器模式-Specifying-Target-Processor-Mode" class="headerlink" title="指定目标处理器模式(Specifying Target Processor Mode)"></a>指定目标处理器模式(Specifying Target Processor Mode)</h2><p><code>BITS</code>指令指定了 nasm 是否要生成为特定处理器模式的代码. 比如处理器的<code>16位</code>,<code>32位</code>和<code>64位</code>模式. 基本格式为<code>BITS XX</code>, 里面的<code>XX</code> 是<code>16</code>, <code>32</code> 或者 <code>64</code>.</p><p>这个指令一般不常用. 同时, 为了兼容, 也有一些别名<code>USE16</code>,<code>USE32</code>分别代表<code>BITS 16</code>和<code>BITS 32</code>.</p><h2 id="改变编译器的默认值-Change-the-assembler-defaults"><a href="#改变编译器的默认值-Change-the-assembler-defaults" class="headerlink" title="改变编译器的默认值(Change the assembler defaults)"></a>改变编译器的默认值(Change the assembler defaults)</h2><p><code>DEFAULT</code> 可以设置为(<code>REL</code>或<code>ABS</code>)和(<code>BND</code>或<code>NOBND</code>).</p><h3 id="RIP-relative-addressing"><a href="#RIP-relative-addressing" class="headerlink" title="RIP-relative addressing"></a>RIP-relative addressing</h3><p><code>REL</code>或<code>ABS</code>用来设置没有用到寄存器的指令在 64 位模式下是不是<code>RIP–relative</code>的. 默认情况下都是绝对的除非用<code>REL</code>覆盖掉.</p><h3 id="BND-prefix"><a href="#BND-prefix" class="headerlink" title="BND prefix"></a>BND prefix</h3><p>If DEFAULT BND is set, all bnd-prefix available instructions following this directive are prefixed with bnd. To override it, NOBND prefix can be used.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT BND</span><br><span class="line">    call foo            ; BND will be prefixed</span><br><span class="line">    nobnd call foo      ; BND will NOT be prefixed</span><br></pre></td></tr></table></figure><p>DEFAULT NOBND can disable DEFAULT BND and then BND prefix will be added only when explicitly specified in code.</p><p>DEFAULT BND is expected to be the normal configuration for writing MPX-enabled code.</p><h2 id="改变或定义段-Changing-and-Defining-Sections"><a href="#改变或定义段-Changing-and-Defining-Sections" class="headerlink" title="改变或定义段(Changing and Defining Sections)"></a>改变或定义段(Changing and Defining Sections)</h2><p>如名, <code>SECTION</code>或者<code>SEGMENT</code>就是用来定义段的. 对于有的格式来说, 都有些什么段都是固定的, 而有的则不作限制.</p><p>对于<code>Unix object</code>和<code>bin object</code>格式来说, 它们都支持标准的段名<code>.text</code>, <code>.data</code> 和 <code>.bss</code> 分别对应 <code>code</code>, <code>data</code> 和 <code>uninitialized-data</code>段.</p><p>相反的, <code>obj</code>格式就不会特殊对待这些段, 而且可能会把段名前面的句点<code>.</code>给删掉.</p><h2 id="定义绝对的标签-Defining-Absolute-Labels"><a href="#定义绝对的标签-Defining-Absolute-Labels" class="headerlink" title="定义绝对的标签(Defining Absolute Labels)"></a>定义绝对的标签(Defining Absolute Labels)</h2><p><code>ABSOLUTE</code>指令可以用作<code>SECTION</code>等的替代品. 它让接下来的代码地址不是基于真实的段的地址, 而是基于一个给定的假设的绝对地址. 同时在这个模式下能够使用的指令只有<code>RESB</code>家族了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">absolute 0x1A</span><br><span class="line"></span><br><span class="line">    kbuf_chr    resw    1</span><br><span class="line">    kbuf_free   resw    1</span><br><span class="line">    kbuf        resw    16</span><br></pre></td></tr></table></figure><p>这个例子描述了一个 PC BIOS 的数据段在地址 <code>0x40</code> 处. 上面的代码定义了 <code>kbuf_chr</code>的值为 <code>0x1A</code>, <code>kbuf_free</code> 的值为<code>0x1C</code>, 并且 <code>kbuf</code> 的值为 <code>0x1E</code>.</p><h2 id="从其它模块导入符号-Importing-Symbols-from-Other-Modules"><a href="#从其它模块导入符号-Importing-Symbols-from-Other-Modules" class="headerlink" title="从其它模块导入符号(Importing Symbols from Other Modules)"></a>从其它模块导入符号(Importing Symbols from Other Modules)</h2><p><code>EXTERN</code>指令有点类似 c 里面的<code>extern</code>关键字. 它用来引用定义在其它模块的符号. 同时注意不是所有的格式都会支持这个指令, <code>bin</code>格式就不支持.</p><p><code>EXTERN</code>指令可以接受任意多个参数, 每个参数都是一个符号名.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern  _printf</span><br><span class="line">extern  _sscanf,_fscanf</span><br></pre></td></tr></table></figure><p><code>EXTERN</code>可以导入一个符号两次, 不过 nasm 会忽视第二次导入.</p><p>同时, 如果一个变量被同时声明为<code>GLOBAL</code>和 <code>EXTERN</code> 或者它被声明为<code>EXTERN</code>后又被定义了, 那么它会被当成<code>GLOBAL</code>来处理.如果一个变量同时被声明为<code>COMMON</code> 和<code>EXTERN</code>, 它会被当成<code>COMMON</code>来处理.</p><h2 id="将符号导出到其它模块-Exporting-Symbols-to-Other-Modules"><a href="#将符号导出到其它模块-Exporting-Symbols-to-Other-Modules" class="headerlink" title="将符号导出到其它模块(Exporting Symbols to Other Modules)"></a>将符号导出到其它模块(Exporting Symbols to Other Modules)</h2><p><code>GLOBAL</code>是<code>EXTERN</code>的另外一端: 如果一个模块将一个变量声明为<code>EXTERN</code>并且引用了它, 那么为了避免链接错误, 另外一个模块就需要使用<code>GLOBAL</code>来声明它, 并且还要明确的定义它. 其它的编译器可能使用<code>PUBLIC</code>来用作这一目的.</p><p>它的语法和<code>EXTERN</code>相同.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">global _main</span><br><span class="line">_main:</span><br><span class="line">        ; some code</span><br></pre></td></tr></table></figure><h2 id="定义通用数据区域-Defining-Common-Data-Areas"><a href="#定义通用数据区域-Defining-Common-Data-Areas" class="headerlink" title="定义通用数据区域(Defining Common Data Areas)"></a>定义通用数据区域(Defining Common Data Areas)</h2><p><code>COMMON</code>指令用于声明通用变量(common variable). 作用就是声明一个在未初始化数据段的<code>GLOBAL</code>变量.</p><p>所以这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">common  intvar  4</span><br></pre></td></tr></table></figure><p>和这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">global  intvar</span><br><span class="line">section .bss</span><br><span class="line"></span><br><span class="line">intvar  resd    1</span><br></pre></td></tr></table></figure><p>它们的含义是相同的. 除了一点: 如果有超过一个的模块定义了<code>COMMON</code>变量, 那么它们会共享同一个通用变量. 它们各自定义的变量将会被合并, 并且在实际内存中, 指向同一块内存.</p><h2 id="本地符号-Local-Symbols-within-Modules"><a href="#本地符号-Local-Symbols-within-Modules" class="headerlink" title="本地符号(Local Symbols within Modules)"></a>本地符号(Local Symbols within Modules)</h2><p><code>STATIC</code>会声明一个本地符号.</p><h2 id="修饰字符-Mangling-Symbols"><a href="#修饰字符-Mangling-Symbols" class="headerlink" title="修饰字符(Mangling Symbols)"></a>修饰字符(Mangling Symbols)</h2><p><code>(G|L)PREFIX</code>, <code>(G|L)POSTFIX</code>这里面有<code>6</code>个指令, <code>()</code>表示可选,<code>|</code>表示或.</p><h2 id="通用命名空间-Generic-Namespaces"><a href="#通用命名空间-Generic-Namespaces" class="headerlink" title="通用命名空间(Generic Namespaces)"></a>通用命名空间(Generic Namespaces)</h2><p><code>OUTPUT</code> 和 <code>DEBUG</code>指令.</p><h2 id="定义-cpu-的依赖-Defining-CPU-Dependencies"><a href="#定义-cpu-的依赖-Defining-CPU-Dependencies" class="headerlink" title="定义 cpu 的依赖(Defining CPU Dependencies)"></a>定义 cpu 的依赖(Defining CPU Dependencies)</h2><p><code>CPU</code>指令限制了指令集.</p><p>选项有:</p><ul><li>CPU 8086 Assemble only 8086 instruction set</li><li>CPU 186 Assemble instructions up to the 80186 instruction set</li><li>CPU 286 Assemble instructions up to the 286 instruction set</li><li>CPU 386 Assemble instructions up to the 386 instruction set</li><li>CPU 486 486 instruction set</li><li>CPU 586 Pentium instruction set</li><li>CPU PENTIUM Same as 586</li><li>CPU 686 P6 instruction set</li><li>CPU PPRO Same as 686</li><li>CPU P2 Same as 686</li><li>CPU P3 Pentium III (Katmai) instruction sets</li><li>CPU KATMAI Same as P3</li><li>CPU P4 Pentium 4 (Willamette) instruction set</li><li>CPU WILLAMETTE Same as P4</li><li>CPU PRESCOTT Prescott instruction set</li><li>CPU X64 x86-64 (x64/AMD64/Intel 64) instruction set</li><li>CPU IA64 IA64 CPU (in x86 mode) instruction set</li></ul><p>所有的选项都是大小写不敏感的. 默认提供所有的指令.</p><h2 id="处理浮点数常数-Handling-of-floating-point-constants"><a href="#处理浮点数常数-Handling-of-floating-point-constants" class="headerlink" title="处理浮点数常数(Handling of floating-point constants)"></a>处理浮点数常数(Handling of floating-point constants)</h2><p>默认的, 浮点常数都会近似到最接近的数字, 但是也可以使用<code>FLOAT</code>来改变这个行为.</p><p>选项如下:</p><ul><li>FLOAT DAZ Flush denormals to zero</li><li>FLOAT NODAZ Do not flush denormals to zero (default)</li><li>FLOAT NEAR Round to nearest (default)</li><li>FLOAT UP Round up (toward +Infinity)</li><li>FLOAT DOWN Round down (toward –Infinity)</li><li>FLOAT ZERO Round toward zero</li><li>FLOAT DEFAULT Restore default settings</li></ul><h2 id="打开或关闭警告-Enable-or-disable-warnings"><a href="#打开或关闭警告-Enable-or-disable-warnings" class="headerlink" title="打开或关闭警告(Enable or disable warnings)"></a>打开或关闭警告(Enable or disable warnings)</h2><p><code>[WARNING]</code>指令打开或者关闭警告级别, 同命令行<code>-w</code>参数的作用.</p><p>说明:</p><ul><li>[warning +warning-class] enables warnings for warning-class.</li><li>[warning -warning-class] disables warnings for warning-class.</li><li>[warning *warning-class] restores warning-class to the original value, either the default value or as specified on the command line.</li></ul><p>同时, <code>[WARNING]</code> 指令也接受<code>all</code>, <code>error</code>和 <code>error=warning-class</code>这些选项.<br>这个指令没有提供用户级别的指令.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个紧随之前的基本语法, 要把这个看完才能基本看懂&lt;code&gt;nasm&lt;/code&gt;风格的代码. 当然也可以看不懂的时候再来看就是了. 其中有些只是列出了指令名, 这是出于强迫症考虑的. 虽然不大可能用得到, 但还是写上, 之后若要用再来补充就是了. 还有一些指令直接将原来的复制来了, 这是因为我也不明白它的作用, 不好翻译. 所以直接贴原文, 不过只有一个指令.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="nasm" scheme="https://memorytoco.github.io/Lago/tags/nasm/"/>
    
  </entry>
  
  <entry>
    <title>nasm 基础之基本语法</title>
    <link href="https://memorytoco.github.io/Lago/2019/03/01/nasm_1/"/>
    <id>https://memorytoco.github.io/Lago/2019/03/01/nasm_1/</id>
    <published>2019-03-01T01:37:18.000Z</published>
    <updated>2019-02-28T17:55:45.065Z</updated>
    
    <content type="html"><![CDATA[<p>又赶着看了一下 <code>nasm</code> 编译器的手册, 准确的也可以说是翻译了一下手册. 快速上手<code>nasm</code>的语法. 给之后的学习铺垫一下. 同时, 这个也是我认为能够基础使用<code>nasm</code>的关键章节, 距离真正的汇编代码还有一些差距. 可以自行查阅<a href="https://www.nasm.us/doc/" target="_blank" rel="noopener">手册</a>.</p><p>这里的前提是对汇编有个基本的了解, 不然看了还是会懵的. 这个是解释在<code>nasm</code>下的汇编语法, 而不是教授汇编<code>Intel</code>语法的. 去看王爽的书, 熟悉一下汇编代码的编写吧!</p><a id="more"></a><h2 id="一个源文件行的组成"><a href="#一个源文件行的组成" class="headerlink" title="一个源文件行的组成"></a>一个源文件行的组成</h2><p>任意一行都是由 4 个域组成的, 如下所示.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label:   instruction   operands  ;comment</span><br></pre></td></tr></table></figure><p>同时, 在一行中, <code>label</code>,<code>instruction</code>和一个<code>comment</code>任意一个都是可选的. 而<code>operands</code>域是否是可选的由<code>instruction</code>决定.</p><p>也就是说,下面的形式都是可以的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;; 一个标签单独一行</span><br><span class="line">hello:</span><br><span class="line"></span><br><span class="line">;; 一个标签和一个注释</span><br><span class="line">hello: ;; this is a comment</span><br><span class="line"></span><br><span class="line">;; 一个标签和指令</span><br><span class="line">hello: ret</span><br><span class="line"></span><br><span class="line">;; 指令和注释</span><br><span class="line">mov ax, bx   ;; 将bx的值移动到ax中去</span><br></pre></td></tr></table></figure><p>等等… 以上只是一部分, 其它的可以自己列举.</p><p>同时, 源文件中对空格不做限制, 既可以出现在<code>label</code>的前面, 也可以让指令<code>instruction</code>顶格写. 这都没问题. 注意一下<code>label</code>后面的<code>:</code>也可以省去.</p><p>一个标签<code>label</code>可以由字母<code>letters</code>, 数字<code>numbers</code>, <code>_</code>, <code>$</code>, <code>#</code>, <code>@</code>, <code>~</code>, <code>.</code> 和<code>?</code>组成.</p><p>同时能用在标识符<code>identifier</code>开头的字符只能是字母<code>letters</code>, <code>.</code>, <code>_</code>和 <code>?</code>. 一个标识符也可以添加<code>$</code>前缀来表示这是一个标识符而不是保留字. 比如可以使用<code>$eax</code>表示这不是寄存器<code>eax</code>, 而是一个标识符. 标识符最大长度为<code>4095</code>个字符.</p><p><code>operands</code> 可以是寄存器 <code>registers</code>, 或者是立即地址<code>effective addresses</code>, 常量<code>constants</code> 或者表达式<code>expressions</code>.</p><h2 id="伪指令-pseudo-instructions"><a href="#伪指令-pseudo-instructions" class="headerlink" title="伪指令(pseudo-instructions)"></a>伪指令(pseudo-instructions)</h2><p>伪指令不是真正的 x86 机器指令, 而是由编译器进行解释的同样可以用在源文件中的指令. 这些指令的作用是方便程序员.</p><p>现在<code>nasm</code>中的伪指令有 <code>DB</code>, <code>DW</code>, <code>DD</code>, <code>DQ</code>, <code>DT</code>, <code>DO</code>, <code>DY</code> 和 <code>DZ</code>. their uninitialized counterparts <code>RESB</code>, <code>RESW</code>, <code>RESD</code>, <code>RESQ</code>, <code>REST</code>, <code>RESO</code>, <code>RESY</code> 和 <code>RESZ</code>. <code>INCBIN</code> 命令,<code>EQU</code> 命令,和<code>TIMES</code> 前缀.</p><h3 id="声明已初始化的变量-Declaring-Initialized-Data"><a href="#声明已初始化的变量-Declaring-Initialized-Data" class="headerlink" title="声明已初始化的变量(Declaring Initialized Data)"></a>声明已初始化的变量(Declaring Initialized Data)</h3><p><code>DB</code>, <code>DW</code>, <code>DD</code>, <code>DQ</code>, <code>DT</code>, <code>DO</code>, <code>DY</code>和 <code>DZ</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">db    0x55                ; just the byte 0x55</span><br><span class="line">db    0x55,0x56,0x57      ; three bytes in succession</span><br><span class="line">db    &apos;a&apos;,0x55            ; character constants are OK</span><br><span class="line">db    &apos;hello&apos;,13,10,&apos;$&apos;   ; so are string constants</span><br><span class="line">dw    0x1234              ; 0x34 0x12</span><br><span class="line">dw    &apos;a&apos;                 ; 0x61 0x00 (it&apos;s just a number)</span><br><span class="line">dw    &apos;ab&apos;                ; 0x61 0x62 (character constant)</span><br><span class="line">dw    &apos;abc&apos;               ; 0x61 0x62 0x63 0x00 (string)</span><br><span class="line">dd    0x12345678          ; 0x78 0x56 0x34 0x12</span><br><span class="line">dd    1.234567e20         ; floating-point constant</span><br><span class="line">dq    0x123456789abcdef0  ; eight byte constant</span><br><span class="line">dq    1.234567e20         ; double-precision float</span><br><span class="line">dt    1.234567e20         ; extended-precision float</span><br></pre></td></tr></table></figure><p><code>DT</code>, <code>DO</code>, <code>DY</code> 和 <code>DZ</code>不接受数字操作数.</p><h3 id="声明未初始化变量-Declaring-Uninitialized-Data"><a href="#声明未初始化变量-Declaring-Uninitialized-Data" class="headerlink" title="声明未初始化变量(Declaring Uninitialized Data)"></a>声明未初始化变量(Declaring Uninitialized Data)</h3><p><code>RESB</code>, <code>RESW</code>, <code>RESD</code>, <code>RESQ</code>, <code>REST</code>, <code>RESO</code>, <code>RESY</code> 和 <code>RESZ</code> 都是被设计用在<code>BSS</code>段的: 他们声明未初始化的存储空间. 每一个都接受一个操作数, 操作数是指定需要保存空间的个数. 如果是<code>RESB n</code>就是保留<code>n</code>个字节.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer:         resb    64              ; reserve 64 bytes</span><br><span class="line">wordvar:        resw    1               ; reserve a word</span><br><span class="line">realarray       resq    10              ; array of ten reals</span><br><span class="line">ymmval:         resy    1               ; one YMM register</span><br><span class="line">zmmvals:        resz    32              ; 32 ZMM registers</span><br></pre></td></tr></table></figure><h3 id="引入外部二进制文件-Including-External-Binary-Files"><a href="#引入外部二进制文件-Including-External-Binary-Files" class="headerlink" title="引入外部二进制文件(Including External Binary Files)"></a>引入外部二进制文件(Including External Binary Files)</h3><p><code>INCBIN</code>将一个外部的二进制文件<code>逐字</code>的包含到输出文件中. 一个例子就是将图片数据或者声音数据直接放到一个游戏的可执行文件中.</p><p>它以如下形式出现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;; include the whole file</span><br><span class="line">incbin  &quot;file.dat&quot;</span><br><span class="line"></span><br><span class="line">;; skip the first 1024 bytes</span><br><span class="line">incbin  &quot;file.dat&quot;,1024</span><br><span class="line"></span><br><span class="line">;; skip the first 1024, and actually include at most 512</span><br><span class="line">incbin  &quot;file.dat&quot;,1024,512</span><br></pre></td></tr></table></figure><p><code>INCBIN</code> 既是一个指令也是一个标准宏. 当被用作标准宏的时候, 它在包含的路径中搜索被包含的文件然后将这个文件加入到依赖列表中. 这个宏可以被覆盖.</p><h3 id="定义常数-Defining-Constants"><a href="#定义常数-Defining-Constants" class="headerlink" title="定义常数(Defining Constants)"></a>定义常数(Defining Constants)</h3><p><code>EQU</code>将一个符号与一个<code>常数</code>关联. 当<code>EQU</code>被使用时, 源文件的这一行必须有一个<code>标签</code>(label), <code>EQU</code>的作用就是将给它的操作数一个<code>标签名</code>. 这个定义是绝对的并且在这之后不能被改变.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message         db      &apos;hello, world&apos;</span><br><span class="line">msglen          equ     $-message</span><br></pre></td></tr></table></figure><p>上面的定义了 <code>msglen</code>为一个常数 <code>12</code>. 在这之后, <code>msglen</code> 将不能被重新定义. 这个定义不是一个<strong>预处理</strong>定义, <code>msglen</code> 的值将会是定义时的<code>$</code>的值. 而不是之后程序运行起来时对其引用时的值(有点类似于动态作用域和闭包的区别).</p><h3 id="重复指令或者数据-Repeating-Instructions-or-Data"><a href="#重复指令或者数据-Repeating-Instructions-or-Data" class="headerlink" title="重复指令或者数据(Repeating Instructions or Data)"></a>重复指令或者数据(Repeating Instructions or Data)</h3><p><code>TIMES</code> 前缀将会使指令被重复多次, 和<code>MASM</code>的<code>DUP</code>指令有点类似. 因此可以使用类似这样的语法: <code>zerobuf: times 64 db 0</code>. 不过这里的<code>TIMES</code>更加强大, 它允许给它的参数不只是一个<code>数字</code>, 也可以是一个<code>表达式</code>. 所以:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer: db      &apos;hello, world&apos;</span><br><span class="line">        times 64-$+buffer db &apos; &apos;</span><br></pre></td></tr></table></figure><p>这样的写法会保证之后的空格数会保证整个<code>buffer</code>的大小为<code>64</code>.</p><p>最后, <code>TIMES</code> 也可以被用到普通的指令上去, 所以你可以这样写一个循环<code>times 100 movsb</code></p><p>另外, 注意一点, <code>TIMES</code> 不能作用到<code>宏</code>(macros)上. 这是因为 <code>TIMES</code> 指令是在处理完宏之后再处理的(这一点也允许了上边的<code>64-$+buffer</code>能够被正确处理. 如果想要重复多行代码或者时复杂的宏, 请使用预处理命令<code>%rep</code>.</p><h3 id="立即地址-Effective-Addresses"><a href="#立即地址-Effective-Addresses" class="headerlink" title="立即地址(Effective Addresses)"></a>立即地址(Effective Addresses)</h3><p>一个立即地址是在指令中用来引用内存的. 它的形式非常简单, 就是由<code>[ ]</code>包围的表达式,其中表达式会被求值为一个值, 这个值将会被用来当成地址引用.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wordvar dw      123</span><br><span class="line">        mov     ax,[wordvar]       ;; 可以使用标签</span><br><span class="line">        mov     ax,[wordvar+1]     ;; 可以用来计算</span><br><span class="line">        mov     ax,[es:wordvar+bx] ;; 这种也行</span><br><span class="line"></span><br><span class="line">;; 这种在里面包含复杂表达式的也行</span><br><span class="line">mov     eax,[ebx*2+ecx+offset]</span><br><span class="line">mov     ax, [bp+di+8]</span><br><span class="line"></span><br><span class="line">;; 这种也行, 对, 这样也行, nasm会进行计算</span><br><span class="line">mov     eax,[ebx*5]             ; assembles as [ebx*4+ebx]</span><br><span class="line">mov     eax,[label1*2-label2]   ; ie [label1+(label1-label2)]</span><br></pre></td></tr></table></figure><p>同时, 在对表达式计算的时候, 它会被展开成不同的真正的汇编指令. 可以使用 <code>BYTE</code>, <code>WORD</code>, <code>DWORD</code> 和 <code>NOSPLIT</code> 来限定<code>nasm</code>对这些地方处理的结果. 形式为<code>[BYTE expression]</code></p><p>在 <code>64-bit</code> 模式中, <code>NASM</code> 会默认生成绝对地址. <code>REL</code> 关键字可以让它产生 <code>RIP–relative</code> 类型的地址. 这个也是默认的行为. 使用<code>ABS</code>可以覆盖<code>REL</code>的行为.</p><p>还有一种新的形式的语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[ebx+8,ecx*4]   ; ebx=base, ecx=index, 4=scale, 8=disp</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><code>NASM</code> 支持 4 中不同类型的常量: 数字<code>numeric</code>, 字符<code>character</code>, 字串<code>string</code> 和浮点数<code>floating-point</code>.</p><h3 id="数字常量-Numeric-Constants"><a href="#数字常量-Numeric-Constants" class="headerlink" title="数字常量(Numeric Constants)"></a>数字常量(Numeric Constants)</h3><p>数字常量就是一个数字, 你可以添加 <code>H</code> 或者 <code>X</code>后缀来表示十六进制数字, <code>D</code> 或者 <code>T</code>来表示一个十进制数字, <code>Q</code> 或者 <code>O</code>表示一个八进制数字, <code>B</code> 或者 <code>Y</code> 来表示一个二进制数字.</p><p>也可以添加前缀<code>0x</code>或者前缀<code>$</code>来表示十六进制数字. 不过注意<code>$</code>在<code>nasm</code>中有两个含义, 为了避免歧义, 最好之后紧跟数字而不是字母. 另外, 当前版本还支持 <code>0h</code> 前缀表示十六进制, <code>0d</code> 或者 <code>0t</code>前缀表示十进制数. <code>0o</code> 或者 <code>0q</code>前缀表示八进制. 和 <code>0b</code> 或者 <code>0y</code>前缀表示一个二进制.</p><p>同时, 数字常量允许使用<code>_</code>来分割较长的数字.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mov     ax,200          ; decimal</span><br><span class="line">mov     ax,0200         ; still decimal</span><br><span class="line">mov     ax,0200d        ; explicitly decimal</span><br><span class="line">mov     ax,0d200        ; also decimal</span><br><span class="line">mov     ax,0c8h         ; hex</span><br><span class="line">mov     ax,$0c8         ; hex again: the 0 is required</span><br><span class="line">mov     ax,0xc8         ; hex yet again</span><br><span class="line">mov     ax,0hc8         ; still hex</span><br><span class="line">mov     ax,310q         ; octal</span><br><span class="line">mov     ax,310o         ; octal again</span><br><span class="line">mov     ax,0o310        ; octal yet again</span><br><span class="line">mov     ax,0q310        ; octal yet again</span><br><span class="line">mov     ax,11001000b    ; binary</span><br><span class="line">mov     ax,1100_1000b   ; same binary constant</span><br><span class="line">mov     ax,1100_1000y   ; same binary constant once more</span><br><span class="line">mov     ax,0b1100_1000  ; same binary constant yet again</span><br><span class="line">mov     ax,0y1100_1000  ; same binary constant yet again</span><br></pre></td></tr></table></figure><h3 id="字符串常量-Character-Strings"><a href="#字符串常量-Character-Strings" class="headerlink" title="字符串常量(Character Strings)"></a>字符串常量(Character Strings)</h3><p>字符串可以使用<code>`</code>, <code>&#39;</code>, <code>&quot;</code>这三个来表示. 最多不超过<strong>八字符</strong>长. 其中如果使用<code>&#39;</code>来表示字串, 那么字串中可以包含<code>&quot;</code>, 反之亦然.</p><p>同时, 如果使用<code>`</code>来表示字符串. 字符串里面可以使用<code>c</code>风格的转移字符. 下面的都是在<code>`</code>中被解释的.</p><table><thead><tr><th>转移字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\&#39;</code></td><td>single quote (‘)</td></tr><tr><td><code>\&quot;</code></td><td>double quote (“)</td></tr><tr><td><code>\`</code></td><td>backquote (`)</td></tr><tr><td><code>\\</code></td><td>backslash ()</td></tr><tr><td><code>\?</code></td><td>question mark (?)</td></tr><tr><td><code>\a</code></td><td>BEL (ASCII 7)</td></tr><tr><td><code>\b</code></td><td>BS (ASCII 8)</td></tr><tr><td><code>\t</code></td><td>TAB (ASCII 9)</td></tr><tr><td><code>\n</code></td><td>LF (ASCII 10)</td></tr><tr><td><code>\v</code></td><td>VT (ASCII 11)</td></tr><tr><td><code>\f</code></td><td>FF (ASCII 12)</td></tr><tr><td><code>\r</code></td><td>CR (ASCII 13)</td></tr><tr><td><code>\e</code></td><td>ESC (ASCII 27)</td></tr><tr><td><code>\377</code></td><td>Up to 3 octal digits - literal byte</td></tr><tr><td><code>\xFF</code></td><td>Up to 2 hexadecimal digits - literal byte</td></tr><tr><td><code>\u1234</code></td><td>4 hexadecimal digits - Unicode character</td></tr><tr><td><code>\U12345678</code></td><td>8 hexadecimal digits - Unicode character</td></tr></tbody></table><p>其它所有的转义字符都会被保留. 注意<code>\0</code>表示一个<code>NUL</code>字符, 是一个特殊的 8 进制转义序列.<br><code>Unicode</code>字符会被转化到<code>UTF-8</code>去.</p><p>下面的都是等价的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db `\u263a`            ; UTF-8 smiley face</span><br><span class="line">db `\xe2\x98\xba`      ; UTF-8 smiley face</span><br><span class="line">db 0E2h, 098h, 0BAh    ; UTF-8 smiley face</span><br></pre></td></tr></table></figure><h3 id="字符常量-Character-Constants"><a href="#字符常量-Character-Constants" class="headerlink" title="字符常量(Character Constants)"></a>字符常量(Character Constants)</h3><p>一个字符串常量最多<strong>八字节</strong>长. 在用在一个表达式中时, 它被当作一个整数.<br>如果它多于一个字节, 会以小端字节序解释. 如果<code>mov eax,&#39;abcd&#39;</code>, <code>abcd</code>会被解释成<code>0x64636261</code> 而不是<code>0x61626364</code>. 左边高位, 右边低位.</p><h3 id="字串常量-String-Constants"><a href="#字串常量-String-Constants" class="headerlink" title="字串常量(String Constants)"></a>字串常量(String Constants)</h3><p>字串常量看起来像一个字符常量, 只是更加的长.</p><p>同时, 下面两个写法一样.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db    &apos;hello&apos;               ; string constant</span><br><span class="line">db    &apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;   ; equivalent character constants</span><br></pre></td></tr></table></figure><p>这些同样一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd    &apos;ninechars&apos;           ; doubleword string constant</span><br><span class="line">dd    &apos;nine&apos;,&apos;char&apos;,&apos;s&apos;     ; becomes three doublewords</span><br><span class="line">db    &apos;ninechars&apos;,0,0,0     ; and really looks like this</span><br></pre></td></tr></table></figure><h3 id="Unicode-字串-Unicode-Strings"><a href="#Unicode-字串-Unicode-Strings" class="headerlink" title="Unicode 字串(Unicode Strings)"></a>Unicode 字串(Unicode Strings)</h3><p>特殊操作符<code>__utf16__</code>, <code>__utf16le__</code>, <code>__utf16be__</code>, <code>__utf32__</code>, <code>__utf32le__</code> 和 <code>__utf32be__</code>允许定义 Unicode 字串. 它们将<code>UTF-8</code>格式分别转换成<code>UTF-16</code>和<code>UTF-32</code>格式.</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%define u(x) __utf16__(x)</span><br><span class="line">%define w(x) __utf32__(x)</span><br><span class="line"></span><br><span class="line">      dw u(&apos;C:\WINDOWS&apos;), 0       ; Pathname in UTF-16</span><br><span class="line">      dd w(`A + B = \u206a`), 0   ; String in UTF-32</span><br></pre></td></tr></table></figure><h3 id="浮点数常量-Floating-Point-Constants"><a href="#浮点数常量-Floating-Point-Constants" class="headerlink" title="浮点数常量(Floating-Point Constants)"></a>浮点数常量(Floating-Point Constants)</h3><p>浮点数常量只能作为 <code>DB</code>, <code>DW</code>, <code>DD</code>, <code>DQ</code>, <code>DT</code>, 和 <code>DO</code>或者特殊操作符 <code>__float8__</code>, <code>__float16__</code>, <code>__float32__</code>, <code>__float64__</code>, <code>__float80m__</code>, <code>__float80e__</code>, <code>__float128l__</code>和<code>__float128h__</code>的操作数<code>operands</code>.</p><p>它的基本格式为数字<code>digits</code>然后是一个小数点<code>a period</code>然后可选的更多的数字 <code>digits</code>然后可选的一个<code>E</code>附带一个指数. 小数点是强制的, 用来区分<code>1</code>和<code>1.0</code>这种情况. 前一个是十进制 1, 后一个是一个浮点数 1.</p><p>同时, <code>nasm</code>也支持十六进制表示, 同上, 不过将<code>E</code>换成<code>P</code>, 并且后面跟二进制数,(!不是十六进制),不过是用十进制表示. 不明白的话看下例子就明白了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db    -0.2                    ; &quot;Quarter precision&quot;</span><br><span class="line">dw    -0.5                    ; IEEE 754r/SSE5 half precision</span><br><span class="line">dd    1.2                     ; an easy one</span><br><span class="line">dd    1.222_222_222           ; underscores are permitted</span><br><span class="line">dd    0x1p+2                  ; 1.0x2^2 = 4.0</span><br><span class="line">dq    0x1p+32                 ; 1.0x2^32 = 4 294 967 296.0</span><br><span class="line">dq    1.e10                   ; 10 000 000 000.0</span><br><span class="line">dq    1.e+10                  ; synonymous with 1.e10</span><br><span class="line">dq    1.e-10                  ; 0.000 000 000 1</span><br><span class="line">dt    3.141592653589793238462 ; pi</span><br><span class="line">do    1.e+4000                ; IEEE 754r quad precision</span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式会被表示成 64 位的整数, 然后依据情况调整到合适的大小.</p><p>同时, <code>nasm</code>支持两个特殊的符号用以表示当前的位值<code>$</code>和<code>$$</code>. <code>$</code>用来表示当前行的开始位置, 而<code>$$</code>用来表示当前段的位置.</p><p><code>nasm</code>提供<code>|</code>, <code>^</code>, <code>&amp;</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>%%</code>操作符.</p><p>一元操作符(unary operator)有 <code>+</code>, <code>-</code>, <code>~</code>, <code>!</code>, <code>SEG</code>和 整数函数操作符<code>integer functions operators</code>.</p><p><code>SEG</code>返回一个符号的段地址, 这个段地址和那个符号的偏移地址结合一定能够保证正确指向那个符号.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     ax,seg symbol</span><br><span class="line">mov     es,ax</span><br><span class="line">mov     bx,symbol</span><br></pre></td></tr></table></figure><p>上面这个代码使得<code>ES:BX</code>一定指向<code>symbol</code>这个符号所在的地址.</p><p>同时, 为了避免段与段之间有交集. 可以使用<code>WRT</code>(with reference to)指令得到相对于指定的段地址的偏移量.</p><p>例子如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     ax,weird_seg        ; weird_seg is a segment base</span><br><span class="line">mov     es,ax</span><br><span class="line">mov     bx,symbol wrt weird_seg</span><br></pre></td></tr></table></figure><p>此时, <code>ES:BX</code>和使用<code>SEG</code>的那段代码有同样的效果.</p><h2 id="本地标签"><a href="#本地标签" class="headerlink" title="本地标签"></a>本地标签</h2><p>以一个句点<code>.</code>开头的标签为本地标签, 它依赖于之前的一个非本地标签.</p><p>一个例子说明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">label1  ; some code</span><br><span class="line"></span><br><span class="line">.loop</span><br><span class="line">        ; some more code</span><br><span class="line"></span><br><span class="line">        jne     .loop</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">label2  ; some code</span><br><span class="line"></span><br><span class="line">.loop</span><br><span class="line">        ; some more code</span><br><span class="line"></span><br><span class="line">        jne     .loop</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>同时, <code>nasm</code>提供了一个访问任意本地标签的功能. 使用<code>label2.loop</code>就可以访问到<code>label2</code>标签里<code>.loop</code>的位置.</p><p>同时, 记住以两个<code>.</code>开头的标签<code>..label</code>都是特殊标签, 并且和本地标签没有关系.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又赶着看了一下 &lt;code&gt;nasm&lt;/code&gt; 编译器的手册, 准确的也可以说是翻译了一下手册. 快速上手&lt;code&gt;nasm&lt;/code&gt;的语法. 给之后的学习铺垫一下. 同时, 这个也是我认为能够基础使用&lt;code&gt;nasm&lt;/code&gt;的关键章节, 距离真正的汇编代码还有一些差距. 可以自行查阅&lt;a href=&quot;https://www.nasm.us/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;手册&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;这里的前提是对汇编有个基本的了解, 不然看了还是会懵的. 这个是解释在&lt;code&gt;nasm&lt;/code&gt;下的汇编语法, 而不是教授汇编&lt;code&gt;Intel&lt;/code&gt;语法的. 去看王爽的书, 熟悉一下汇编代码的编写吧!&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="nasm" scheme="https://memorytoco.github.io/Lago/tags/nasm/"/>
    
  </entry>
  
  <entry>
    <title>x86 王爽汇编之终</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/27/wangshuang_4/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/27/wangshuang_4/</id>
    <published>2019-02-27T09:27:13.000Z</published>
    <updated>2019-02-27T16:24:52.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>现在, 王爽这本汇编语言总算是基本看完了. 总体给我的感觉就是有点意外和兴奋. 感觉确实是一本相当务实的书, 和其它学校用教学书不同, 质量非常不错. 一步一步带领读者逐层深入, 非常照顾读者的心情. 如果确实是老老实实的阅读下去的话, 基本是不会碰到什么难以理解的东西. 这本书自成一体, 似乎也并不需要其它额外的前置知识(咳咳, 我是这么觉着的, 切勿当真). 除了实验环境难以搭建(太老了)以外, 没有其它的毛病了.</p><p>可能有人会觉得都 2019 年了, 还在讲解<code>8086</code>这个处理器, 还在使用<code>dos</code>操作系统, 是不是有点太脱离时代了. 个人认为这样的想法确实不错, 我之前也是抱有这样的想法而对这本书不怎么感冒. 不过, 它依然值的一读. 具体的原因, 不由我来说, 而是请各位移步到<em>王爽汇编第三版</em>的附录 1 中. 看完那个, 然后抱着怀疑的心态再浏览一下附录一之前的综合研究, 稍稍看一下那里的内容. 或许你会改变观点呢. 我可以打包票的说, 从头读到尾, x86 汇编就是入门了. 你也不会对汇编产生畏惧感了.</p><p>我对这本书是相当满意的, 只能说, 如果有学校的汇编课上是使用的这本书的话, 那么学生是相当幸运的.</p><p>不过好话说了这么多, 它的缺点也是有的. 而且这个还是相当要命的一点. 那就是实验环境太老了. 在现在的环境下非常难搭. 而且关于搭建资料什么的也很稀少. 不过, 正在阅读的你又非常幸运了, 因为我这里正好有一个完美的解决方案, 只是需要你懂得一点 linux 知识而已.</p><h2 id="硬伤解决方案"><a href="#硬伤解决方案" class="headerlink" title="硬伤解决方案"></a>硬伤解决方案</h2><p>解决方案就是使用 virtualbox 虚拟机, 同时使用<a href="https://www.freedos.org" target="_blank" rel="noopener">FreeDos</a>. 用这个来模拟 dos 环境, 同时也提供了<code>debug</code>命令. 具体的操作我在后续会给出, 而现在, 有能力的已经可以按照思路搭建环境了. 然后跟着王爽的思路迈入汇编的世界吧.</p><h2 id="关于这个王爽汇编系列"><a href="#关于这个王爽汇编系列" class="headerlink" title="关于这个王爽汇编系列"></a>关于这个王爽汇编系列</h2><p>我原本是打算每一章一篇发布出来, 包括里面的知识点和答题. 但是, 前三章似乎还好, 按部就班的一点一点推进, 但是后面的内容和知识点, 我认为不太适合继续以一篇一篇的形式发出了. 所以直接一口气看完了全书, 跳过了一些实验. 继续做了一些笔记后, 发觉笔记真的是非常散乱, 指令的介绍也由于书的结构的原因, 断断续续, 如果直接发布出来的话会非常的杂乱.(不过不用担心书里面的安排) 所以决定在之后直接对 8086 的指令和一些细节作出总结, 将这些东西汇集到一起, 发布出来, 以供之后的阅读与查询. 同时, 答案和实验之后也会一篇一篇发布出来, 包括具体的细节和涉及的知识点以及实验的思路等. 最后的对 c 的探索非常值的一做! 也非常推荐亲手实践一下, 不管有没有看过我之后的实验过程! 大概就是这样!</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>一些以实际目的出发的人可能会意识到即使会了 8086, 也不能在实际中使用 <code>dos</code> 的工具这个问题. 我在后续会提供现代汇编编译器<code>nasm</code>的相关介绍与知识. 我除了在<code>FreeDos</code>上试着完成实验的同时, 基于情况, 我也可能在 64 位 linux 上使用<code>nasm</code>完成对 c 的那三个研究实验. 同时会介绍, 使用现代的工具<code>vim</code>(或者其它编辑器,不过我会用 <code>vim</code>)进行汇编代码的编写, 和使用现代的工具进行代码调试. 所以实用党们可以不必担心了, 汇编一定是有用的. 不过后续的可能会涉及实模式和保护模式在 linux 上的讨论, 还请想要继续深入的多多留意.</p><p>最后祝汇编学习快乐!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;感受&quot;&gt;&lt;a href=&quot;#感受&quot; class=&quot;headerlink&quot; title=&quot;感受&quot;&gt;&lt;/a&gt;感受&lt;/h2&gt;&lt;p&gt;现在, 王爽这本汇编语言总算是基本看完了. 总体给我的感觉就是有点意外和兴奋. 感觉确实是一本相当务实的书, 和其它学校用教学书不同, 质量
      
    
    </summary>
    
      <category term="Tech" scheme="https://memorytoco.github.io/Lago/categories/Tech/"/>
    
    
      <category term="asm" scheme="https://memorytoco.github.io/Lago/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>x86 王爽汇编之三</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/26/wangshuang_3/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/26/wangshuang_3/</id>
    <published>2019-02-26T09:27:13.000Z</published>
    <updated>2019-02-27T15:42:28.446Z</updated>
    
    <content type="html"><![CDATA[<p>这里需要弄明白的就是栈是由<code>SS:SP</code>控制的就行. 它本身有一个执行逻辑. 其它的关于<code>mov</code>传送的数据的类型, 还是需要个人自己探索. 毕竟那是手册上的东西. 这系列笔记还是关注与知识的理解不是具体命令的细节.</p><p>这里重点是数据段寄存器和栈段寄存器.</p><a id="more"></a><h2 id="字单元"><a href="#字单元" class="headerlink" title="字单元"></a>字单元</h2><p>由于在内存中, 一个单元的大小是一个字节, 而 cpu 是 16 位即大小为 2 字节. 那么想要从内存中向 cpu 中传送一个字的数据时, 就要使用内存中<strong>连续的两个内存单元</strong>作为<strong>一个字单元</strong>, 以此为基本单位来传送数据.</p><p>这里提出<strong>字单元</strong>的概念. 字单元是存放一个 16 位数据大小的内存单元(规定的), 由两个连续地址的内存单元组成. 在这两个内存单元中, 低位字节在低地址单元中, 高位字节在高地址单元中.</p><p>然后, 低地址为<code>N</code>时, 称这个<strong>字单元</strong>为<strong>N 地址字单元</strong>.</p><p>若是提到某个单元里的字节型数据, 就是单个内存单元中, 一个字节里的数据. 若是提到字型单元, 就要将两个相邻的内存单元连起来一起看.</p><h2 id="存放数据地址的段寄存器"><a href="#存放数据地址的段寄存器" class="headerlink" title="存放数据地址的段寄存器"></a>存放数据地址的段寄存器</h2><p>8086 里面使用<code>DS</code>段寄存器存放要访问的数据的段地址, 而使用<code>[address]</code>中的<code>address</code>表示偏移地址.</p><p>这里的作用就是使用<code>mov</code>指令直接从内存中<code>DS:address</code>取得数据. 格式为<code>mov obj, [address]</code>, 其中, <code>obj</code>是寄存器. 其中<code>address</code>的大小和<code>IP</code>的大小一样是 16 位.</p><p>这里, <code>mov</code>就有了四个作用.</p><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td><code>mov ax, 003H</code></td><td>将一个数字直接传入寄存器中</td></tr><tr><td><code>mov ax, bx</code></td><td>将一个寄存器中的内容传入寄存器中</td></tr><tr><td><code>mov ax, [address]</code></td><td>将内存中<code>DS:address</code>所指单元的内容存入寄存器中</td></tr><tr><td><code>mov [address], ax</code></td><td>将寄存器中的值传入内存中, 地址同样是<code>DS:address</code></td></tr></tbody></table><blockquote><p>注意, 在执行第三种形式时, cpu 直接默认从<code>DS</code>中取得段地址.</p></blockquote><p>当<code>mov</code>中有 16 位的寄存器时, 自动传送 16 位的数据即一个字型数据. 也就是上面列表中<code>格式</code>一栏中展示的示例都是传送的一个字型数据. 但是如果出现了<code>al</code>的话, 那就是字节型数据. 注意内存中字型数据的存放取出的规则(高对高,低对低). 同时注意所操作的寄存器的位数, 是 8 位还是 16 位.</p><p>这里面, 除了将数字直接传送到段寄存器中的行为不允许, 其它情况下段寄存器的操作和通用寄存器一样.</p><p>同时<code>add</code>,<code>sub</code>这两个命令和<code>mov</code>有一样格式. 不过, 这两个都不能对段寄存器操作(只是<code>add ds, ax</code>这类将<code>ds</code>放在第一位的不行, <code>add ax, ds</code>这个可以).</p><blockquote><p>另外一点是, <code>DS</code>不可以使用<code>mov</code>直接传入数字, 只能将一个寄存器中的值传入<code>DS</code>中. 因此需要传入数值时, 需要使用一个寄存器用作中转.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;; 错误</span><br><span class="line">mov ds, 003H</span><br><span class="line"></span><br><span class="line">;; 正确</span><br><span class="line">mov ax, 003H</span><br><span class="line">mov ds, ax   ; ds 为 003H</span><br></pre></td></tr></table></figure><h2 id="8086-的栈"><a href="#8086-的栈" class="headerlink" title="8086 的栈"></a>8086 的栈</h2><p>首先, 想象一个开口向上的瓶子. 开口处就是<strong>栈顶</strong>. 栈顶的元素总是最后入栈, 最先取出. 栈遵循<strong>先进后出</strong>原则.</p><p>8086 中提供<code>push</code>和<code>pop</code>命令来入栈和出栈. 入栈和出栈都是以<strong>字</strong>为单位的(也就是 2 个字节). <code>push ax</code>表示将<code>ax</code>中的内容入栈. 而<code>pop ax</code>表示将栈顶的元素弹出到<code>ax</code>中. 注意, 这里字在内存中的存储规则依然是高对高,低对低.</p><p>8086 使用<code>SS</code>和<code>SP</code>两个寄存器来跟踪<strong>栈顶元素</strong>. 其中<code>SS</code>存放段地址, <code>SP</code>存放偏移地址.</p><p><code>push ax</code> 操作有两步</p><ol><li><code>SP=SP-2</code>, <code>SS:SP</code>指向栈顶前面的单元(低地址方向), 以当前地址为新的栈顶.</li><li>同时, 将<code>ax</code>内容送到内存中</li></ol><blockquote><p>如此, 得到栈是从<strong>高地址</strong>向<strong>低地址</strong>方向增长的. 且当栈中无元素时, 指向栈最高地址加一的地方. 可以理解为此时栈中没有元素, 因此栈指针指向栈外一个单元(高地址处).</p></blockquote><p><code>pop ax</code> 操作同样两步</p><ol><li>将栈顶内容送入<code>ax</code>中</li><li><code>SP=SP+2</code>, <code>SS:SP</code>指向栈顶后面的单元(高地址方向), 以当前地址为新的栈顶.</li></ol><blockquote><p><code>push</code>和<code>pop</code>这两个操作对所有寄存器都可用, 同时对内存单元也可用. 不过需要注意的是操作的数据是以<strong>字</strong>为单位的.</p></blockquote><p>8086 的栈的最大值是<code>0H~FFFFH</code>, 同时, 如何确保栈不会溢出这点需要我们自己控制.</p><p>在初始化栈的时候有一个技巧来判断<code>SP</code>的值是否设置正确. 那就是求值此时的栈的大小, 用此时<code>SP</code>的值加一, 判断是否为奇数, 若是则是正确的, 若不是, 那么就是错误的.</p><h2 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h2><p>同其它的分段机制一样, 也可以对栈进行分段, 如果将<code>10000H ~ 1FFFFH</code>这段空间当作栈空间, 那么栈空时, 当<code>SS</code>为<code>1000H</code>时, <code>SP</code>的值为 <code>0</code>. 可以先考虑栈中有一个元素的情况下, <code>SP</code>的值是<code>FFFEH</code>. 那么, 此时<code>pop</code>操作可得<code>SP</code>为 <code>0</code>. 即<code>SP</code>的值应该为<code>0</code>.</p><h2 id="段的综述"><a href="#段的综述" class="headerlink" title="段的综述"></a>段的综述</h2><p>首先, 段是人为规定的, 并且由于其段地址不会改变, 无论是栈的段地址, 指令的段地址还是数据的段地址, 在初始化后主动改变的话是不会变的. 变的只有偏移地址. 而且由于偏移地址的大小, 可以确定段的最大空间为 64KB. 基于这些特性, 我们可以定义自己的<strong>代码段</strong>, <strong>数据段</strong>, <strong>栈段</strong>进行管理.</p><h1 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h1><h2 id="检测点-3-1"><a href="#检测点-3-1" class="headerlink" title="检测点 3.1"></a>检测点 3.1</h2><blockquote><p>实验跳过</p></blockquote><ol><li>写出每条指令结束后, 相关寄存器中的值. <code>AX=0</code>,<code>BX=0</code>.</li></ol><p>相关内存如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000:0000 70 80 F0 30 EF 60 30 E2-00 80 80 12 66 20 22 60  0000:000F</span><br><span class="line">0000:0010 62 26 E6 D6 CC 2E 3C 3B-AB BA 00 00 26 06 66 88  0000:001F</span><br></pre></td></tr></table></figure><table><thead><tr><th>指令</th><th><code>AX</code></th><th><code>BX</code></th><th><code>DS</code></th></tr></thead><tbody><tr><td><code>mov ax, 1</code></td><td>1</td><td></td><td></td></tr><tr><td><code>mov ds, ax</code></td><td></td><td></td><td>1</td></tr><tr><td><code>mov ax, [0000]</code></td><td>2662</td><td></td><td></td></tr><tr><td><code>mov bx, [0001]</code></td><td></td><td>E626</td><td></td></tr><tr><td><code>mov ax, bx</code></td><td>E626</td><td></td><td></td></tr><tr><td><code>mov ax, [0000]</code></td><td>2662</td><td></td><td></td></tr><tr><td><code>mov bx, [0002]</code></td><td></td><td>D6E6</td><td></td></tr><tr><td><code>add ax, bx</code></td><td>FD48</td><td></td><td></td></tr><tr><td><code>add ax, [0004]</code></td><td>2C14</td><td></td><td></td></tr><tr><td><code>mov ax, 0</code></td><td>0</td><td></td><td></td></tr><tr><td><code>mov al, [0002]</code></td><td>E6</td><td></td><td></td></tr><tr><td><code>mov bx, 0</code></td><td></td><td>0</td><td></td></tr><tr><td><code>mov bl, [000C]</code></td><td></td><td>26</td><td></td></tr><tr><td><code>add al, bl</code></td><td>C</td><td></td></tr></tbody></table><ol start="2"><li>寄存器初始值为: <code>CS=2000H</code>, <code>IP=0</code>, <code>DS=1000H</code>, <code>AX=0</code>, <code>BX=0</code></li></ol><p>内存情况如下:</p><table><thead><tr><th>地址</th><th>值</th><th>指令</th><th>地址</th><th>值</th><th>指令</th></tr></thead><tbody><tr><td>10000</td><td>B8</td><td>*</td><td>20000</td><td>B8</td><td>*</td></tr><tr><td>10001</td><td>00</td><td>*</td><td>20001</td><td>22</td><td>*</td></tr><tr><td>10002</td><td>20</td><td>mov ax, 2000H</td><td>20002</td><td>66</td><td>mov ax, 6622H</td></tr><tr><td>10003</td><td>8E</td><td>*</td><td>20003</td><td>Ea</td><td>*</td></tr><tr><td>10004</td><td>D8</td><td>mov ds, ax</td><td>20004</td><td>00</td><td>*</td></tr><tr><td>10005</td><td>A1</td><td>*</td><td>20005</td><td>01</td><td>*</td></tr><tr><td>10006</td><td>08</td><td>*</td><td>20006</td><td>F0</td><td>*</td></tr><tr><td>10007</td><td>00</td><td>mov ax, [0008]</td><td>20007</td><td>0F</td><td>jmp 0ff0:0100</td></tr><tr><td>10008</td><td>A1</td><td>*</td><td>20008</td><td>89</td><td>*</td></tr><tr><td>10009</td><td>02</td><td>*</td><td>20009</td><td>C3</td><td>mov bx, ax</td></tr><tr><td>1000a</td><td>00</td><td>mov ax, [0002]</td><td>2000a</td><td>…</td><td></td></tr><tr><td>1000b</td><td>…</td><td></td><td>2000b</td><td>…</td><td></td></tr><tr><td>1000c</td><td>…</td><td></td><td>2000c</td><td>…</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 6622H  ;; AX=6622H IP=3</span><br><span class="line">jmp 0ff0:0100  ;; CS=2000H IP=8 --&gt; CS=0FF0 IP=0100 : ff00+100 = 10000</span><br><span class="line">mov ax, 2000H  ;; AX=2000H IP=0103</span><br><span class="line">mov ds, ax     ;; DS=2000H IP=0105</span><br><span class="line">mov ax, [0008] ;; AX=C389H IP=0108</span><br><span class="line">mov ax, [0002] ;; Ax=EA66H IP=010b</span><br></pre></td></tr></table></figure><h2 id="检测点-3-2"><a href="#检测点-3-2" class="headerlink" title="检测点 3.2"></a>检测点 3.2</h2><ol><li>补全程序, 将 1000H 到 1000FH 中的 8 个字逆序复制到 2000H 到 2000FH 中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 1000H</span><br><span class="line">mov ds, ax</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 2000H</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 0010H</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">push [0]</span><br><span class="line">push [2]</span><br><span class="line">push [4]</span><br><span class="line">push [6]</span><br><span class="line">push [8]</span><br><span class="line">push [a]</span><br><span class="line">push [c]</span><br><span class="line">push [e]</span><br></pre></td></tr></table></figure><ol start="2"><li>补全程序, 将 1000H 到 1000FH 中的 8 个字逆序复制到 2000H 到 2000FH 中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 2000H</span><br><span class="line">mov ds, ax</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 1000H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov sp, 0000H</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pop [E]</span><br><span class="line">pop [C]</span><br><span class="line">pop [A]</span><br><span class="line">pop [8]</span><br><span class="line">pop [6]</span><br><span class="line">pop [4]</span><br><span class="line">pop [2]</span><br><span class="line">pop [0]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里需要弄明白的就是栈是由&lt;code&gt;SS:SP&lt;/code&gt;控制的就行. 它本身有一个执行逻辑. 其它的关于&lt;code&gt;mov&lt;/code&gt;传送的数据的类型, 还是需要个人自己探索. 毕竟那是手册上的东西. 这系列笔记还是关注与知识的理解不是具体命令的细节.&lt;/p&gt;
&lt;p&gt;这里重点是数据段寄存器和栈段寄存器.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="asm" scheme="https://memorytoco.github.io/Lago/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>x86 王爽汇编之二</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/26/wangshuang_2/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/26/wangshuang_2/</id>
    <published>2019-02-25T22:30:13.000Z</published>
    <updated>2019-02-27T15:42:24.892Z</updated>
    
    <content type="html"><![CDATA[<p>这里涉及到了一些计算机硬件层面的知识要求, 不过阅读的话问题不大.</p><p>这里的重点是通用寄存器和指令段寄存器.</p><a id="more"></a><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>8086cpu 的寄存器共有<code>AX</code>,<code>BX</code>,<code>CX</code>,<code>DX</code>,<code>SI</code>,<code>DI</code>,<code>SP</code>,<code>BP</code>,<code>IP</code>,<code>CS</code>,<code>SS</code>,<code>DS</code>,<code>ES</code>,<code>PSW</code>14 个寄存器.</p><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>这 14 个寄存器中, 有 4 个通用寄存器, 分别是<code>AX</code>,<code>BX</code>,<code>CX</code>,<code>DX</code>, 它们分别用于存放一般通用型数据.<br>同时, 8086 是 16 为寄存器, 可以存放两个字节, 为了兼容 8080 的 8 为寄存器, 通用寄存器又分为<strong>高位寄存器</strong>与<strong>低位寄存器</strong>, 分别表示为<code>AH</code>与<code>AL</code>. <code>B,C,D</code>同样.</p><p>如果进行了加法操作而且溢出的话, 进制位将会被舍弃. <strong>重点</strong>, 这里在之后的计算中是一个关键, 因为得到的数字不是<strong>精确数</strong>.</p><h2 id="字与字节"><a href="#字与字节" class="headerlink" title="字与字节"></a>字与字节</h2><p>这是 8086 作出的两种表示方法. 字节与前面的一样, 是 8bit, 但是字<code>word</code>是由两个字节组成,而这两个字节分别是高字节与低字节.</p><ul><li>字节 byte: 1 byte = 8 bit</li><li>字 word: 1 word = 2 byte</li></ul><blockquote><p>这里需要说明一下, 关于字长(也就是字)到底是多少的问题. 给出的答案是不确定. 字长跟随具体的机器以及处理器架构相关. 不过<code>8086</code>暂时可以认为是 16 位. 依着上面的描述就行.</p></blockquote><p>字长不是确定的, 但是字节(byte)是一定确定的. 以字节为主即可. 其它的参考各个具体的手册.</p><p>参考:<br><a href="https://zh.wikipedia.org/zh-hans/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="noopener">中文维基百科: 字</a>&gt;)</p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><table><thead><tr><th>指令</th><th>模式</th><th>含义</th></tr></thead><tbody><tr><td><code>mov</code></td><td><code>mov obj, src</code></td><td>将<code>src</code>的值移动到<code>obj</code>中去</td></tr><tr><td><code>add</code></td><td><code>add obj, src</code></td><td>将<code>src</code>的值加上<code>obj</code>并且将结果存到<code>ojb</code>中去</td></tr></tbody></table><h2 id="x位-cpu-中的x的意义"><a href="#x位-cpu-中的x的意义" class="headerlink" title="x位 cpu 中的x的意义"></a><code>x</code>位 cpu 中的<code>x</code>的意义</h2><p>可以暂时理解为运算器一次可以处理<code>x</code>位的数据, 寄存器的最大宽度是<code>x</code>位, 寄存器与运算器之间的通路为<code>x</code>位. 通俗的讲就是通用寄存器的<strong>最大大小</strong>.</p><blockquote><p>这里不保证绝对正确, 因为这里只是讲解汇编的, 不是计算机构造原理. 这里稍作说明也是为了方便之后的学习. 在一个”模糊的假设”下进行学习, 之后再次推翻或者确认这个假设. 这是我的做法.</p></blockquote><h2 id="物理寻址"><a href="#物理寻址" class="headerlink" title="物理寻址"></a>物理寻址</h2><p>8086 采用 <strong>物理地址 = 段地址 * 16 + 偏移地址</strong>的方法寻址. 它的 cpu 是 16 位宽, 但是地址总线是 20 位宽. 所以这种方法能够将其 cpu 的寻址能力从 64KB 扩展到 1MB. 也叫段地址<strong>左移 4 位</strong>再加上偏移地址.</p><p>它内部是用通过两个 16 位地址合成 20 位地址的方法. cpu 会传输两个地址, 一个是段地址, 一个是偏移地址. 所以, 这里段地址和偏移地址的最大都是 2 的 16 次方.</p><p>而这种寻址模式的本质含义是<em>用一个基础地址和一个相对于基础地址的的偏移地址相加, 给出内存单元的物理地址</em>. 这个基础地址在这里就是<strong>段地址 * 16</strong>.</p><p>同时, 要注意的是, 内存永远是连续分布的, 所谓的段只是寻址模式, 是一个概念. 实际上并没有什么段在内存里面. 只是 cpu 自行给自己多加了个段的设定, 这也方便内存的管理. 那么这样, 就可以有一些结论出来了.</p><blockquote><p>段的起始地址由于是由<strong>段地址 * 16</strong> 得到的, 所以一定是 16 的倍数, 不是 16 倍数的数字不能作为段的起始地址. 以 16 为倍数在 16 进制下的意义是最后一位一定是<em>0</em>. 另外, 既然分了段, 那么段的大小也就有了意义. 在这里, 是由最大的<strong>偏移地址</strong>决定的. 毕竟, 偏移地址是以段起始地址作为参考的. 在这里, 由上所述的 cpu 的具体实现方法, 知道偏移地址最大寻址 64KB. (16 位 cpu, 16 位宽, 表示的最大数字就是 64KB, 当成数据总线看就行)</p></blockquote><h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>8086 有 4 个段寄存器: <code>CS</code>, <code>DS</code>, <code>SS</code>, <code>ES</code>.</p><p>其中, <code>CS</code>为代码段寄存器, <code>IP</code>为指令指针寄存器. <code>CS</code>中存储段地址, <code>IP</code>中存储偏移地址.</p><p>在 8086cpu 中, 加电或者复位后, <code>CS</code>被设置为<code>FFFFH</code>,<code>IP</code>为<code>0000H</code>.</p><p>执行过程</p><ol><li>首先从<code>CS:IP</code>指向的地方读取指令</li><li><code>IP=IP+length</code>, 其中, <code>length</code>为指令的长度(即是根据指令长度跳转到下一条指令)</li><li>执行指令并跳转步骤 1, 一直重复</li></ol><blockquote><p>完整过程最好亲自去看下书上的图. 同时, 对于书中的指令的顺序不要太在意, 只是一个说明而以, 意思到了就行.</p></blockquote><h3 id="jmp-指令"><a href="#jmp-指令" class="headerlink" title="jmp 指令"></a>jmp 指令</h3><p>大多数寄存器中的内容都可以使用<code>mov</code>传送指令来更改. 但是<code>CS:IP</code>的内容不能通过<code>mov</code>来修改, 原因就是 cpu 不支持. 但是可以使用<code>jmp</code>转移指令来修改.</p><p>使用<code>jmp 段地址:偏移地址</code>同时改变<code>CS</code>和<code>IP</code>两个值或者使用<code>jmp 合法寄存器</code>只改变<code>IP</code>中的值.</p><h1 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h1><h2 id="检测点-2-1"><a href="#检测点-2-1" class="headerlink" title="检测点 2.1"></a>检测点 2.1</h2><ol><li>写出执行指令后相关寄存器中的值</li></ol><table><thead><tr><th>指令</th><th>AX</th><th>BX</th><th>CX</th></tr></thead><tbody><tr><td><code>mov ax, 62627</code></td><td><code>F4A3H</code></td><td><code>0</code></td><td><code>0</code></td></tr><tr><td><code>mov ah, 31H</code></td><td><code>31A3H</code></td><td><code>0</code></td><td><code>0</code></td></tr><tr><td><code>mov al, 23H</code></td><td><code>3123H</code></td><td><code>0</code></td><td><code>0</code></td></tr><tr><td><code>add ax, ax</code></td><td><code>6246H</code></td><td><code>0</code></td><td><code>0</code></td></tr><tr><td><code>mov bx, 826CH</code></td><td><code>6246H</code></td><td><code>826CH</code></td><td><code>0</code></td></tr><tr><td><code>mov cx, ax</code></td><td><code>6246H</code></td><td><code>826CH</code></td><td><code>6246H</code></td></tr><tr><td><code>mov ax, bx</code></td><td><code>826CH</code></td><td><code>826CH</code></td><td><code>6246H</code></td></tr><tr><td><code>add ax, bx</code></td><td><code>04D8H</code></td><td><code>826CH</code></td><td><code>6246H</code></td></tr><tr><td><code>mov al, bh</code></td><td><code>0482H</code></td><td><code>826CH</code></td><td><code>6246H</code></td></tr><tr><td><code>mov ah, bl</code></td><td><code>6C82H</code></td><td><code>826CH</code></td><td><code>6246H</code></td></tr><tr><td><code>add ah, ah</code></td><td><code>D882H</code></td><td><code>826CH</code></td><td><code>6246H</code></td></tr><tr><td><code>add al, 6</code></td><td><code>D888H</code></td><td><code>826CH</code></td><td><code>6246H</code></td></tr><tr><td><code>add al, al</code></td><td><code>D810H</code></td><td><code>826CH</code></td><td><code>6246H</code></td></tr><tr><td><code>mov ax, cx</code></td><td><code>6246H</code></td><td><code>826CH</code></td><td><code>6246H</code></td></tr></tbody></table><ol start="2"><li>4 条指令, 计算 2 的 4 次方</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 2  ; ax = 2</span><br><span class="line">add ax, ax ; ax = 4</span><br><span class="line">add ax, ax ; ax = 8</span><br><span class="line">add ax, ax ; ax = 16</span><br></pre></td></tr></table></figure><h2 id="检测点-2-2"><a href="#检测点-2-2" class="headerlink" title="检测点 2.2"></a>检测点 2.2</h2><ol><li>给定段地址为 0001H, 仅通过变化偏移地址寻址, cpu 的寻址范围是从<code>00010H</code>到<code>1000FH</code>.</li><li>现有一数据存放在 20000H 单元中, 给定段地址为 SA, 如果想用偏移地址寻到这个单元, 那么段地址需要满足的范围是最小<code>1001H</code>, 最大为<code>2000H</code>.</li></ol><p>这里最大应该没有疑问, 但是最小或许有点问题. 计算方式是<br><code>20000H - FFFF = 10001H</code><br>这里得到的 10001H 还需要再次左移 4 位,得到 1000H. 但是<br><code>1000H * 10H + FFFF = 1FFFFH &lt; 20000H</code><br>所以, 这里仅仅左移是不行的. 需要左移后再将段地址加上 1 才行. 也就是 1001H. 注意到段的起始地址必须是 16 的倍数, 在 16 进制下, 基础地址(注意到上面提到的本质吗)的最后一位必须是<code>0</code>, 所以能动的只有段地址(16 位的)1000H. 而不是在 10001H 的最后一位做动作.</p><p>之所以这里会出现问题, 那是因为, 在进行左移右移后, 得到的数字不是精确数字, 有一部分因为硬件原因被舍弃掉了.</p><h2 id="检测点-2-3"><a href="#检测点-2-3" class="headerlink" title="检测点 2.3"></a>检测点 2.3</h2><p>执行下面的指令后, cpu 几次修改<code>IP</code>? 都是在什么时候? 最后<code>IP</code>的值是什么?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax, bx  ;; 读取命令,一次修改, IP指向下一条指令的位置</span><br><span class="line">sub ax, ax  ;; 读取命令,二次修改, 指向 jmp ax</span><br><span class="line">jmp ax      ;; 读取命令,三次修改, 指向这个命令之外的某个相邻的位置</span><br><span class="line">;; 第四次修改, 执行jmp后的结果</span><br><span class="line">;; 注意到有一个ax-ax的命令, 所以ax为0, 那么IP最后的值为0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里涉及到了一些计算机硬件层面的知识要求, 不过阅读的话问题不大.&lt;/p&gt;
&lt;p&gt;这里的重点是通用寄存器和指令段寄存器.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="asm" scheme="https://memorytoco.github.io/Lago/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>x86 王爽汇编之一</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/26/wangshuang_1/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/26/wangshuang_1/</id>
    <published>2019-02-25T21:30:13.000Z</published>
    <updated>2019-02-27T15:42:21.742Z</updated>
    
    <content type="html"><![CDATA[<p>王爽汇编第三版, 包括课后习题答案(部分解读).</p><p>主要是每一章的知识点罗列.</p><p>王爽这一本书还是相当基础详细的, 用作汇编入门最好. 主要是我有方法模拟 8086 的机器了哈哈. 虽然老了很多, 但是还是觉得可以. 第一个微型系统就在 8086 上了. 于是这里就将这个作为<em>操作系统真象还原</em>的前导课程来学一下.</p><p>里面的实验就放在之后的 bochs 中进行. 使用 bochs 的自带调试功能.</p><a id="more"></a><h2 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h2><ul><li>cpu 的存储是以<strong>B</strong>为基本单位来进行计算的, 一个存储单元就是一个字节, 如果一个存储器有 128 个存储单元, 就可以说这个存储器 128 字节大小.</li><li>cpu 需要三种信息, 才能正确的执行一条指令<ul><li>地址信息</li><li>控制信息</li><li>数据信息</li></ul></li></ul><p>而且, cpu 是通过<strong>总线</strong>来和外部器件(芯片)交流的. 根据它所要的信息不同, 从逻辑上将总线划分成 3 个类别, 分别是</p><ul><li>地址总线</li><li>控制总线</li><li>数据总线</li></ul><p>这几个.</p><h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h3><p>一根导线只能传输高电平或者低电平, 也即<code>1</code>和<code>0</code>. 那么地址总线若有<code>10</code>根的话, 它的状态就有 2 的 10 次方个, 最大数为<code>1023</code>最小为<code>0</code>. 因此可以说, 其寻址能力是<code>1KB</code>. 这里是数字大小, 以 byte 为单位. 一根线数字上最大表示 1, 那最大一 byte, 两根最大 4, 6 根最大 64byte. 数字意义上. 这里需要和数据总线的”大小”区分开来, 依然是和之前的一样, 数字意义上和物理逻辑上.</p><h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h3><p>和地址总线一样, 总线的宽度(构成总线的线的个数)决定了一次可以传送的二进制数据量. <code>8</code>根数据线一次传送一个字节,<code>16</code>根一次<code>2</code>个字节. 这里一次所传大小的要以在内存中的计算. 8 个 bit 就是一个 byte. 几根几个 bit, 合起来 8 个算一个 byte.</p><h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h3><p>控制总线是一个总称, 但是其宽度依然能决定 cpu 对外部器件控制的能力.</p><h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><p>这里可以理解计算机内部由一个巨大的逻辑内存空间. 它在逻辑上是一整块儿的, 并且从<code>0</code>到<code>FFF..H</code>地址上分布. 而实际上, 这个巨大的内存空间是由若干个零碎的物理空间拼凑起来的. 同时, 这样我们也可以就把这个空间当作真实的物理空间, 而且不同的区段有不同的特殊功能.</p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>同时, 这里使用<code>H</code>后缀表示十六进制数字, 用<code>B</code>后缀表示二进制, 什么都不带的表示十进制.</p><p>一个十六进制位的数字可以使用 4 个二进制的<code>0</code>和<code>1</code>来替代.</p><p>比如<code>23H</code>就是<code>0010</code> <code>0011</code> <code>B</code>. <code>2</code>对应<code>0010</code>,<code>3</code>对应<code>0011</code>. 有趣的是这里面的位置意义也正好对应. 这两个数字转换成十进制的数是相同的.</p><h1 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h1><h2 id="检测点-1-1"><a href="#检测点-1-1" class="headerlink" title="检测点 1.1"></a>检测点 1.1</h2><ol><li>一颗 cpu 的寻址能力为 8KB,那么它的地址总线宽度是<code>13</code>.</li><li>1KB 的存储器有<code>1024</code>个存储单元, 编号从<code>0</code>到<code>1023</code>.</li><li>1KB 的存储器, 可以存储<code>8 * 1024</code>个 bit, <code>1024</code>个 byte.</li><li>1GB = <code>1024*1024*1024B</code>, 1MB = <code>1024*1024B</code>, 1KB = <code>1024B</code>.</li><li>8080 地址总线宽度是 16 根,寻址能力是<code>64KB</code>. 8088 宽 20 根,寻址能力是<code>1MB</code>, 80286 宽 24 根, 寻址能力是<code>16</code>MB, 80386 宽 32 根, 寻址能力是<code>4GB</code>.</li><li>数据总线</li></ol><table><thead><tr><th>处理器名称</th><th>数据总线宽度(根)</th><th>一次所传数据大小</th></tr></thead><tbody><tr><td>8080</td><td>8</td><td>1B</td></tr><tr><td>8088</td><td>8</td><td>1B</td></tr><tr><td>8086</td><td>16</td><td>2B</td></tr><tr><td>80286</td><td>16</td><td>2B</td></tr><tr><td>80386</td><td>32</td><td>4B</td></tr></tbody></table><ol start="7"><li><p>从内存中读取 1024 字节的数据, 8086 至少读<code>512</code>次, 80386 至少读<code>256</code>次.</p><blockquote><p>这个有关于数据总线. 注意物理意义上的大小和数字意义上的大小.</p></blockquote></li><li><p>在存储器中, 数据和程序以<code>二进制</code>的形式存放.</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;王爽汇编第三版, 包括课后习题答案(部分解读).&lt;/p&gt;
&lt;p&gt;主要是每一章的知识点罗列.&lt;/p&gt;
&lt;p&gt;王爽这一本书还是相当基础详细的, 用作汇编入门最好. 主要是我有方法模拟 8086 的机器了哈哈. 虽然老了很多, 但是还是觉得可以. 第一个微型系统就在 8086 上了. 于是这里就将这个作为&lt;em&gt;操作系统真象还原&lt;/em&gt;的前导课程来学一下.&lt;/p&gt;
&lt;p&gt;里面的实验就放在之后的 bochs 中进行. 使用 bochs 的自带调试功能.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="asm" scheme="https://memorytoco.github.io/Lago/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>特殊 shell 转义字符</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/20/shell-code-sequence/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/20/shell-code-sequence/</id>
    <published>2019-02-19T22:37:18.000Z</published>
    <updated>2019-02-24T10:07:36.564Z</updated>
    
    <content type="html"><![CDATA[<p>我不知道是不是这里的过程就是这样, 还是我自己的情况. 在一些情况下, 我总是会钻进某个”知识的荒原”里去.</p><p>无论我现在获得信息的能力水平如何, 这种情况总是会发生. 然后随着一夜一夜的亢奋, 也总算是能够触碰到我想要的那个 (唯一感到幸运的地方).</p><p>或许是该考虑一下信息的获取渠道了…</p><p>emmm, 说了一堆废话, 稍稍感慨了一下(主要是又钻进去了…), 还没讲主题.</p><p>主题就是题目, linux shell 里用于操作字符显示, 操作光标位置的特殊字符序列.</p><p>这篇依然是笔记里的内容, 只是记录了最粗浅的用法. 不是用法粗浅, 而是怎么用只是对此认知的最最底层, 所以粗浅.</p><p>另外, 这篇并不会完善所谓的基础知识, 只是用作对这个特殊转义字符的简要介绍. 里面会引用别人博客的内容(链接).</p><a id="more"></a><p>话不多说, 直接上.</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>继续之前, 确保先读完这篇post <a href="http://www.lihaoyi.com/post/BuildyourownCommandLinewithANSIescapecodes.html" target="_blank" rel="noopener">Build your own Command Line with ANSI escape codes</a>. 不理解也没关系, 大致有个概念就行.</p><p>然后打开这个<a href="https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_sequences" target="_blank" rel="noopener">wiki</a>网页随时查询.</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>看完上面的文章, 人家演示了具体的用法和具体在python中的做法. 如果你只是想在python中使用的话, 那么那里面的内容和wiki就足够了. 如果看了之后还想继续在shell中使用或者在其它语言中使用, 但是没有从那篇文章中得到启发, 仍然一头雾水, 那么继续阅读吧. (其实关于如何使用上面两个资料完全够了…)</p><p>ANSI转义字符, 说白了就和c里面的转义字符一样. 只不过c里面的转义字符是由<code>printf</code>负责解释, 而这个ANSI转义字符是由字符终端或者终端模拟器(terminal emulator)负责解释的.</p><p>所有包含这些特殊字符的字符序列都会被当成命令由terminal解释, 不会输出显示出来. 所以不用担心输出里面会包含什么奇怪的东西.</p><p>先上个bash的例子:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env sh</span></span><br><span class="line"></span><br><span class="line">(( number=0 ))</span><br><span class="line">arg=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>  [ <span class="variable">$number</span> != $(( arg ? arg : 100)) ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  (( number = number + 1 ))</span><br><span class="line">  <span class="built_in">echo</span> -e -n <span class="string">"\x1b[0K\x1b[100D\x1b[38;5;106m<span class="variable">$number</span>\x1b[0m%"</span> &amp;&amp; sleep 0.1s</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e -n <span class="string">"\x1b[2K"</span></span><br><span class="line"><span class="built_in">echo</span> -e -n <span class="string">"\x1b[100D"</span></span><br></pre></td></tr></table></figure></p><p>可以将其复制运行看看. 它接受一个数字参数, 试试传入<code>10</code>和<code>50</code>看看效果. 我想这个应该能勾起学习兴趣了…</p><p>这个脚本最复杂的地方就是这几个<code>echo</code>命令的参数了. 是的, 那些就是所谓的转义序列.</p><p>就像c里换行符用<code>\</code>转义一样, ANSI转义序列也有这个要求. 这个一般是<code>ESC[</code>. 然后组成上就再加上以<code>;</code>分隔的参数. <code>ESC</code>代表了键盘左上角<code>ESC</code>键的特殊不可见字符. 这个<code>ESC</code>字符是关键. 如果程序原样打印出了这些字符序列, 那么要么程序有某些设定限制( 如不加<code>-e</code>参数的<code>echo</code>), 要么就是<code>ESC</code>没被识别出来. 其实总结就是<code>ESC</code>没识别出来.</p><p>划个重点:</p><blockquote><p>基本结构是<code>ESC[arg1;arg2;...</code>, 一般来说是一到三个参数. 此外, 之后使用<code>CSI</code>代替<code>ESC[</code>. 所以直接写成 <code>CSI arg1;arg2;</code> 这个只是我作说明使用, 实际使用还是要完整的输入<code>ESC[</code>的. 具体的可以阅读下<a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Escape_sequences" target="_blank" rel="noopener">wiki</a>开头这一部分, 没看明白也没关系, 继续阅读就行.</p></blockquote><p>就是这个:<br><img src="CSI_intro.png" alt="CSI_intro"></p><h3 id="命令-动作-CSI-参数"><a href="#命令-动作-CSI-参数" class="headerlink" title="命令? 动作? CSI? 参数?"></a>命令? 动作? <code>CSI</code>? 参数?</h3><p>继续上面的例子.</p><p><code>echo</code>的<code>-e</code>选项是<code>Enable interpretation of backslash escapes</code>, 即允许<code>echo</code>对转义字符进行处理. 而<code>-n</code>选项是<code>Do not output a newline</code>, 不输出换行符, 让我们完全接管控制. 剩下的就是<code>\x1b</code>这个东西, 不用想也知道这是个转义字符, 但是这个转成了什么呢? 是<code>ESC</code>字符. 它是不可见<code>ESC</code>字符的十六进制表示, 同样的八进制表示是<code>\033</code>. 也就是说这两个你可以任意选用. 只要能将<code>ESC</code>表示出来就行. 要保证程序最终输出的是一个<code>ESC</code>字符而不是<code>\x1b</code>这个4个字符. 所以我们的<code>CSI</code>表示出来就是<code>\x1b[</code>. 那么我们开始解释上面那个例子了. 坐稳了.</p><p>第一行是一个<code>shebang</code>符号, 不多说. 第3,4行初始化变量, 将<code>number</code>赋值0,将第一个参数赋值给<code>arg</code>. 然后6到10行是一个while循环, 持续的打印出<code>number%</code>, 并且对输出进行控制. <code>number</code>周围就是一些ANSI转义序列了. 最后两行重置命令行, 执行完命令后好像什么都没发生一样, 装作没事人.</p><p>接下来解释转义序列了.<br>以防万一你们不想去翻wiki, 上个图.<br><img src="CSI_table.png" alt="CSI-table"></p><p>列表的第一列就是转义序列, 除了<code>CSI</code>要换成<code>\x1b[</code>外, 其它原样输入. 其中<code>n</code>和<code>m</code>里面都有解释, 是一个整数数字, 具体含义参看解释. 而未解释的都是要原样输入的, 是序列的一部分.</p><p>那么这里就可以解释最后两行了.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 擦除整行的内容</span></span><br><span class="line"><span class="built_in">echo</span> -e -n <span class="string">"\x1b[2K"</span></span><br><span class="line"><span class="comment"># 左移光标100个单位, 这里依据上下文可理解为将光标移动到最左边, 这也是我的目的</span></span><br><span class="line"><span class="built_in">echo</span> -e -n <span class="string">"\x1b[100D"</span></span><br></pre></td></tr></table></figure></p><p>如何实验呢, 可以命令行输入<code>echo -e -n &quot;Hello World\x1b[2K&quot;</code>看看什么反应. 是不是输出了个空行? 根据shell的不同, 新起的<code>prompt</code>可能会在同一行(默认期望行为)也可能另起了一行而且在后头可能有什么符号表示”你这没有换行符, 为了美观我先给你换了”这样. 同样的, 序列<code>CSI n D</code>会将光标左移100个单位. </p><p>多个ANSI转义序列可以同时存在, 并且同时生效. 如果两个有冲突, 那么遵循从左到右的顺序, 依次生效. 同时, 转义序列是按行生效的, 在哪一行就以哪一行为基准进行行动. (其实是和光标位置有关啦) 试试加上个<code>\n</code>会有什么效果<code>echo -e -n &quot;Hello World\n\x1b[2K&quot;</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e -n <span class="string">"Hello World\n\x1b[2K"</span></span></span><br><span class="line">Hello World</span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>好像什么效果都没有. 这是因为<code>\n</code>的缘故, 使得在输出<code>Hell World</code>后另起了一行, 然后<code>擦除行</code>的效果作用在一个什么都没有的行上面. 随后, 程序结束, shell打印提示符. 这里注意这两个序列命令不是维持一个状态, 而是执行一个动作, 所以动作执行后发生什么就和它无关了. 新出来的shell提示符<code>prompt</code>看样子是出现在了<code>擦除行</code>作用的行上, 但是因为那个动作已经先执行了, 我一个后出来的提示符和它没啥关系, 所以自然什么事都没有. 想要验证的话可以这样试试. 把<code>\n</code>放到<code>Hello World</code>的中间去怎么样.<br><img src="shell-1.png" alt="shell"></p><p>我用的是<code>fish</code>, 效果如上. 基本可以验证我的想法了. 注意到我用了另外一个序列, 起到了同样的效果, 可以自行在上边的表里查找, 当作一个小的练习. </p><h3 id="作用在行-不-是光标"><a href="#作用在行-不-是光标" class="headerlink" title="作用在行? 不, 是光标!"></a>作用在行? 不, 是光标!</h3><p>其实我提到过这个啦, 小括号里面. 我说过了, 转义序列是按行生效的, 这个从我们之前的测试结果来看似乎是对的, 但是其实不是. 如果你做了上面的小练习, 那么你应该对此有所察觉了. </p><p>“这个序列我看了, 可它不是换行啊! 为啥它的效果和换行一样啊! 这啥玩意儿啊!”</p><p>哈哈, 别急. 虽然只是我的猜测, 但是你有没有想过, 这些换行符是怎么运作的呢? 为什么这个换行符就能起到换行的作用呢? 而且我们也知道, 换行符在linux和windows上还是不一样的, 为什么会有这种差别呢?</p><p>“可这和我今天学ANSI转义序列有什么关系呢?”</p><p>额, 确实, 继续在这方面深入的话就有点偏题了, 但是这里也包含了一点点的关系, 涉及到字符解释与表示的问题. </p><p>前面提到过, ANSI转义字符是由<code>terminal</code>解释的, 就像<code>\n</code>可以由printf进行解释一样. 那么有没有可能<code>\n</code>的作用不是换行, 而是</p><ol><li>将光标下移</li><li>然后将光标左移至顶</li></ol><p>这样呢. 它实际操纵的是光标而给我们一种换了行的表面现象呢? 是不是? 这么想一下是不是开始有点意思了. 当然, 具体的我现在还没深入了解, 也只是一个猜测. 我也提到过, 这些转义都会由一个东西进行解释与执行, 就像我们的代码一样. 所以我认为这个猜测很有可能是真的. 不过, 口说无凭, 我后续也会继续求证. 所以, 目前, 我们暂时将其当作一个假设事实. 我们得到了</p><blockquote><p>ANSI转义字符操作的是光标</p></blockquote><p>这么一个重要的假设. 不管是不是真的, 先看看它是不是按照我们的预期行动就行了.</p><h3 id="颜色控制-–-给我来个RGB-带闪光的那种"><a href="#颜色控制-–-给我来个RGB-带闪光的那种" class="headerlink" title="颜色控制 – 给我来个RGB, 带闪光的那种!"></a>颜色控制 – 给我来个RGB, 带闪光的那种!</h3><p>我们稍稍探讨了ANSI序列真正操纵的东西是什么, 有点跑远了. 现在我们继续来看看上面的代码. </p><p>不过好像有点远了, 没事, 我把它拿下来了. 还对它做了点改变, 方便探讨.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(( number=0 ))</span><br><span class="line"><span class="keyword">while</span>  [ <span class="variable">$number</span> != 100 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  (( number = number + 1 ))</span><br><span class="line">  <span class="built_in">echo</span> -e -n <span class="string">"\x1b[0K\x1b[100D\x1b[37m<span class="variable">$number</span>\x1b[0m%"</span> &amp;&amp; sleep 0.1s</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这个循环将会执行100次, 并且输出<code>1%</code>到<code>100%</code>. 有了上面的经验, 我们再看这个<code>echo</code>行是不是好多了. 来, 我们依次解释</p><ul><li><code>\x1b[0K</code> 查询上边的表, 得到是擦除从光标到行尾内容的效果</li></ul><blockquote><p>看来猜测确实是对的, wiki都这么说了是不. 不过好像还是会依赖行. 嗯? 什么, 你不信wiki, 那你就任重道远了, 继续深入吧探索吧, 求证之后也一定要让我知道.</p></blockquote><p>那么, 再次看看那个表, 上面的东西都已经开放了. 在得知其作用于光标这个结论后.</p><p>表里面提到什么滚动, 上移下移. 这些都可以探索了.</p><ul><li><code>\x1b[100D</code> 左移光标100个单位</li></ul><p>然后碰到了一个<code>\x1b[37m</code> 这个东西还有<code>\x1b[0m</code>.</p><p>查询表得到几个相似的东西. 就是<code>CSI n m</code>这个. wiki让我们去找<code>SGR parameters</code>. 为了方便, 我也将它准备好了.</p><p>我们得到这个表述:<br><img src="SGR-Intro.png" alt="SGR-intro"></p><p>从中, 知道了这个序列码会一直生效, 可以接受多个参数, 以<code>;</code>分离. 而且关键的一点是除非有另外的代码生效, 否则前一个的效果会一直持续下去.</p><p>然后就是一个列表, 为了方便, 我把它分成了两个.<br><img src="SGR-table1.png" alt="SGR-table1"><br><img src="SGR-table2.png" alt="SGR-table2"></p><p>继续在表里查找<code>CSI 37 m</code>这个序列, 然而并没有得到直接的说明, 它让我们继续向下找<code>color table</code>.</p><p>不过这里我就不继续贴图了, 有了上面的经验, 要看懂应该也不是难事了. 直接解释.</p><p><code>CSI 0 m</code>或者<code>CSI m</code>会重置所有的设置和状态. 这个在你实验的时候非常重要. 然后其它的可以参考上面的引用博客. 那里面说的非常详细了, 阅读完应该就有了大致了解, 其它的继续参照wiki吧.</p><p>这里有个总结:</p><ul><li><code>CSI 30m</code> 到 <code>CSI 37m</code>是八个字体颜色, 也是8bit字符表示的颜色.</li><li><code>CSI 30;1m</code> 到 <code>CSI 37;1m</code>又是八个, 不过带了粗体.</li><li><code>CSI 38;5;nm</code> 有点厉害了, 提供256个颜色, 其中的<code>n</code>是<code>1-256</code>的范围.</li></ul><p>同时, 除了设置字体颜色, 还支持设置背景颜色. 还有额外的字体装饰等等功能. 这些就让你去自行探索吧. wiki上可以参考, 那个post也值的一读.</p><h2 id="将它应用到其它程序语言中去"><a href="#将它应用到其它程序语言中去" class="headerlink" title="将它应用到其它程序语言中去"></a>将它应用到其它程序语言中去</h2><p>以上都是使用<code>echo</code>, 也就是所谓的<code>shell</code>脚本来说明的. 那么如何在其它语言中使用呢? 答案就是该怎么用就怎么用. 只要<code>terminal</code>支持, 这些字符序列就都会起作用, 这些字符不是由shell解释的, 而是由<code>terminal</code>解释的, 所以<code>terminal</code>对它有最终解释权.</p><p>“恩, 说的不错, 但要怎么呢?”</p><p>我觉得我说的挺明白了… 好吧, 再拿shell举例, <code>echo &quot;\x1b[37mHello World\x1b[m&quot;</code>这里面发生了什么呢. </p><p>先是<code>echo</code>解释转义字符<code>\</code>, 于是得到<code>ESC[37mHello WorldESC[m</code>, 这里的<code>ESC</code>代表不可见字符<code>ESC</code>, 是计算机内存中的表示. 然后<code>echo</code>再将其输出到标准输出端口, <code>terminal</code>接收到了这个字串, 遇见<code>ESC[37m</code>将其视为命令执行, 然后输出白色的<code>Hello World</code>, 再次遇到命令, 重置. 输出结束.</p><p>就像我开头强调的那样, 重要的是不可见字符<code>ESC</code>字符的识别. 如果使用c的话, 那就是<code>printf(&quot;\x1b[37mHello World\n\x1b[m&quot;);</code>, 最最重要的依然是<code>ESC</code>的输出和对它的识别. 得要让<code>terminal</code>识别出命令. 这样就行了.</p><p>看完引用post后你应该直到了如何使用python来操作了, 这里你又会了shell和c的表示. 那么, 将这些经验带到其它的语言中去吧.</p><p>比如我在scheme中就是<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">display</span> (<span class="name">string-append</span> (<span class="name">string</span> #\<span class="number">033</span>) </span><br><span class="line">                        <span class="string">"[37mHello World\n"</span></span><br><span class="line">                        (<span class="name">string</span> #\<span class="number">033</span>)</span><br><span class="line">                        <span class="string">"[m"</span>))</span><br></pre></td></tr></table></figure></p><p>好了, 以上就是基本的介绍了. 这里面也还有东西, 比如<code>terminal</code>和我们运行的程序的关系这类以及<code>terminal</code>如何处理字符的打印这些问题. 留待后续探讨吧.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我不知道是不是这里的过程就是这样, 还是我自己的情况. 在一些情况下, 我总是会钻进某个”知识的荒原”里去.&lt;/p&gt;
&lt;p&gt;无论我现在获得信息的能力水平如何, 这种情况总是会发生. 然后随着一夜一夜的亢奋, 也总算是能够触碰到我想要的那个 (唯一感到幸运的地方).&lt;/p&gt;
&lt;p&gt;或许是该考虑一下信息的获取渠道了…&lt;/p&gt;
&lt;p&gt;emmm, 说了一堆废话, 稍稍感慨了一下(主要是又钻进去了…), 还没讲主题.&lt;/p&gt;
&lt;p&gt;主题就是题目, linux shell 里用于操作字符显示, 操作光标位置的特殊字符序列.&lt;/p&gt;
&lt;p&gt;这篇依然是笔记里的内容, 只是记录了最粗浅的用法. 不是用法粗浅, 而是怎么用只是对此认知的最最底层, 所以粗浅.&lt;/p&gt;
&lt;p&gt;另外, 这篇并不会完善所谓的基础知识, 只是用作对这个特殊转义字符的简要介绍. 里面会引用别人博客的内容(链接).&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://memorytoco.github.io/Lago/categories/Tech/"/>
    
    
      <category term="shell script" scheme="https://memorytoco.github.io/Lago/tags/shell-script/"/>
    
  </entry>
  
  <entry>
    <title>shell 工具集</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/16/shell-tools/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/16/shell-tools/</id>
    <published>2019-02-15T21:54:50.000Z</published>
    <updated>2019-02-15T14:00:50.281Z</updated>
    
    <content type="html"><![CDATA[<p>最后编辑时间: <code>2019-2-15</code> , 持续更新补充</p><p>linux shell 最常用工具介绍. 这些在你编写linux shell脚本的时候拥有非常大的用处. 你的shell脚本水平也与你对这些工具的熟练度直接挂钩.</p><a id="more"></a><h3 id="wc-工具"><a href="#wc-工具" class="headerlink" title="wc 工具"></a><code>wc</code> 工具</h3><p>用作字符统计.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc file</span><br></pre></td></tr></table></figure><p><code>wc</code> 命令会显示三个数字和文件名.<br>实例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wc .vimrc</span><br><span class="line">273  865 8549 .vimrc</span><br></pre></td></tr></table></figure><p>可以看到这里由三个数字, 第一个数字表示文件行数, 第二个数字表示单词数, 第三个表示字符数.最后一个是文件名. 所以这个例子显示了 <em>.vimrc</em> 这个文件共有 273 行, 865 个单词, 8549 个字符. 统计结果来自 <em>.vimrc</em>这个文件.</p><h3 id="使用-cat-显示文件内容"><a href="#使用-cat-显示文件内容" class="headerlink" title="使用 cat 显示文件内容"></a>使用 <code>cat</code> 显示文件内容</h3><p>显示文件内容. 是<em>concatenate</em>的缩写, 如果给了多个文件, 那么<code>cat</code>会将两个文件的内容合并起来在输出到标准输出中去.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat files</span><br></pre></td></tr></table></figure><h3 id="使用-cut-提取半结构化文件内容"><a href="#使用-cut-提取半结构化文件内容" class="headerlink" title="使用 cut 提取半结构化文件内容"></a>使用 <code>cut</code> 提取半结构化文件内容</h3><p>用于从数据文件或者命令输出中提取(切出)各种字段.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -cchars file</span><br></pre></td></tr></table></figure><p>其中<code>-cchars</code>可以是</p><table><thead><tr><th>符号</th><th>含义</th><th>总结</th></tr></thead><tbody><tr><td><code>-c1</code></td><td>提取每行的第一个字符</td><td><code>-cnum</code></td></tr><tr><td><code>-c1,3,5</code></td><td>提取每行的第一,三,五个字符</td><td><code>-cnum1,num2,num3...</code></td></tr><tr><td><code>-c1-4</code></td><td>提取每行的第一到四个字符</td><td><code>-cnum1-num2</code></td></tr><tr><td></td><td>提取从<code>num1</code>到行尾的所有字符</td><td><code>-cnum1-</code></td></tr></tbody></table><p>上面的足以应对一般需求了,但是如果一个文件不是那么规则的话或许需要一些额外的支持才行.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -ddchar -ffield file</span><br></pre></td></tr></table></figure><p>其中, <code>dchar</code>是分隔字符, <code>field</code>是由分隔字符分隔出来的一个个段, 其格式和<code>-c</code>选项一样.</p><blockquote><p>如果在没有指定<code>-d</code>选项的情况下使用<code>-f</code>, 那么分隔符就是<strong>制表符</strong>.</p></blockquote><h3 id="paste-与-cut-搭配使用"><a href="#paste-与-cut-搭配使用" class="headerlink" title="paste 与 cut 搭配使用"></a><code>paste</code> 与 cut 搭配使用</h3><p>用于合并行, 与<code>cut</code>相反.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste files</span><br></pre></td></tr></table></figure><p><code>paste</code>后面可以跟随多个文件名, 结果就是将每个文件中的对应行合并起来. 默认分隔符是<strong>制表符</strong>.如果想要更改分隔符可以使用<code>-d</code>选项. 命令格式为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste -dchars file1 file2 file3 ...</span><br></pre></td></tr></table></figure><p>其中, <code>chars</code>是多个字符, 每个字符分别分隔依次序的文件. 就是第一个字符分隔<code>file1</code>和<code>file2</code>, 第二个字符分隔<code>file2</code>和<code>file3</code>, 其余以此类推.</p><p>同时使用<code>-s</code>选项,将一个文件中的所有行合并.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste -s file</span><br></pre></td></tr></table></figure><h3 id="流编辑器-sed"><a href="#流编辑器-sed" class="headerlink" title="流编辑器 sed"></a>流编辑器 <code>sed</code></h3><p>是<strong>stream editor</strong>(流编辑器)的简称.一般用法如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed command file</span><br></pre></td></tr></table></figure><p><code>sed</code> 不会修改原始的文件, 只会把结果输出到标准输出.</p><p>具体的用法另起一个笔记.</p><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a><code>tr</code></h3><p>用作于过滤器,转换标准输入中的字符.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr fromchars tochars</span><br></pre></td></tr></table></figure><p>同样的, <code>tr</code>不会修改原始文件. 其中, 字符可以使用八进制来表示. <code>\xxx</code>.</p><table><thead><tr><th>tr 命令</th><th>含义</th></tr></thead><tbody><tr><td><code>tr &#39;[a-z]&#39; &#39; &#39;</code></td><td>将小写字母转换成空格</td></tr><tr><td><code>tr &#39;[a-z][A-Z]&#39; &#39;[A-Z][a-z]&#39;</code></td><td>将大写字母转换成小写字母, 将小写字母转换成大写字母</td></tr></tbody></table><p><code>-s</code>选项用来将连续出现的字符替换成一个单一的字符. <code>-d</code>选项用于删除输入流中的</p><h3 id="grep-文件搜索"><a href="#grep-文件搜索" class="headerlink" title="grep 文件搜索"></a><code>grep</code> 文件搜索</h3><p>神器,不解释.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep pattern files</span><br></pre></td></tr></table></figure><blockquote><p>待补充</p></blockquote><h3 id="使用-sort-对内容进行排序"><a href="#使用-sort-对内容进行排序" class="headerlink" title="使用 sort 对内容进行排序"></a>使用 <code>sort</code> 对内容进行排序</h3><p>用于给输入的内容排序.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort file</span><br></pre></td></tr></table></figure><p><code>-u</code>选项,消除重复的行. <code>-r</code>选项逆序排列. <code>-o</code>选项指定输出文件. <code>-n</code>将行中的第一个字段视为数字进行排序. <code>-knumn</code> 选项表示从第<code>num</code>个字段开始排序. <code>-t</code>选项制定各个字段的分隔符.</p><h3 id="uniq-过滤器"><a href="#uniq-过滤器" class="headerlink" title="uniq 过滤器"></a><code>uniq</code> 过滤器</h3><p>用于查找或者删除文件中的重复行.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq inputfile outputfile</span><br></pre></td></tr></table></figure><p><code>-d</code>选项用于找出重复的行. <code>-c</code>选项统计出现的次数.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后编辑时间: &lt;code&gt;2019-2-15&lt;/code&gt; , 持续更新补充&lt;/p&gt;
&lt;p&gt;linux shell 最常用工具介绍. 这些在你编写linux shell脚本的时候拥有非常大的用处. 你的shell脚本水平也与你对这些工具的熟练度直接挂钩.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="linux shell" scheme="https://memorytoco.github.io/Lago/tags/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title>vim寄存器简明介绍</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/15/vim-register/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/15/vim-register/</id>
    <published>2019-02-14T21:34:12.000Z</published>
    <updated>2019-02-14T13:56:26.828Z</updated>
    
    <content type="html"><![CDATA[<p>最后编辑时间: <code>2019-2-14</code> , 之后会添加具体的例子.</p><p>最近再次深入一下<code>vim</code>, 这次复习了一下<code>vim</code>的寄存器.</p><p><code>vim</code>寄存器属于那种没用过几乎不用但一用过就再也离不开的角色, 在<code>vim</code>里面, 寄存器不仅与插件有无限的可能, 而且就算不借助任何插件, 只是使用好这些寄存器也会使你在<code>vim</code>的编辑效率提高一个档次.</p><p>物超所值, 值的学习!</p><p>这次就将我复习的内容分享出来啦!</p><a id="more"></a><p>概览</p><p>使用<code>:dis</code>或者不带参数的<code>:reg</code>命令显示所有的寄存器以及储存的值. 使用<code>:reg</code>后跟复数个寄存器的名字来显示寄存器中的内容.</p><table><thead><tr><th>寄存器名</th><th>作用</th></tr></thead><tbody><tr><td><code>&quot;&quot;</code></td><td>无名寄存器</td></tr><tr><td><code>&quot;0 - &quot;9</code></td><td>10个数字寄存器</td></tr><tr><td><code>&quot;-</code></td><td>小型删除寄存器</td></tr><tr><td><code>&quot;a - &quot;z</code>, <code>&quot;A -&quot;Z</code></td><td>26个字母寄存器</td></tr><tr><td><code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code></td><td>三个只读寄存器</td></tr><tr><td><code>&quot;#</code></td><td>备用文件寄存器</td></tr><tr><td><code>&quot;=</code></td><td>表达式寄存器</td></tr><tr><td><code>&quot;*</code>, <code>&quot;+</code>, <code>&quot;~</code></td><td>选中丢弃寄存器</td></tr><tr><td><code>&quot;_</code></td><td>黑洞寄存器</td></tr><tr><td><code>&quot;/</code></td><td>最后的搜索的pattern</td></tr></tbody></table><h3 id="t-与-m-文本命令"><a href="#t-与-m-文本命令" class="headerlink" title=":t 与 :m 文本命令"></a><code>:t</code> 与 <code>:m</code> 文本命令</h3><p><code>:co</code>, <code>:copy</code> 命令<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[<span class="built_in">range</span>]<span class="keyword">co</span>[<span class="keyword">py</span>] &#123;address&#125;</span><br></pre></td></tr></table></figure></p><p>将<code>[range]</code>内的内容复制到<code>{address}</code>行下. <code>:t</code>与这两个同义.</p><blockquote><p><code>[range]</code>可以是<code>num1,num2</code>,表示从<code>num1</code>到<code>num2</code>的行. 也可以是特殊的表示行号的字符, 由<code>,</code>分隔. <code>{address}</code>表示一个行的地址, 初步使用可以指定一个行号. 更多的内容请看之后的<code>vim</code>系列的<strong>特殊记号</strong>说明吧. :)</p></blockquote><hr><p><code>:m</code>, <code>mo</code>, <code>move</code>命令<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[<span class="built_in">range</span>]<span class="keyword">m</span>[ove] &#123;address&#125;</span><br></pre></td></tr></table></figure></p><p>将<code>[range]</code>内的内容移动到<code>{address}</code>行下.</p><h3 id="无名寄存器-quot-quot"><a href="#无名寄存器-quot-quot" class="headerlink" title="无名寄存器 &quot;&quot;"></a>无名寄存器 <code>&quot;&quot;</code></h3><p>vim将<code>d</code>,<code>c</code>,<code>s</code>,<code>x</code>这些动作或者<code>y</code>指令操作的内容存放到无名寄存器中, 且无论在进行这些操作的时候是否指定特殊的寄存器, 无名寄存器中的内容总会这这些指令操作的内容. </p><blockquote><p>实际上, 无名寄存器总是指向一个有名寄存器, 且它的内容和这个有名寄存器中的一样.</p></blockquote><p>唯一的特例就是黑洞寄存器<code>&quot;_</code>, 如果进行动作的时候指定了黑洞寄存器, 那么操作的内容不会存到任何寄存器中.</p><p>无名寄存器中的内容用于任何的<strong>粘贴</strong>命令如<code>p</code>. 还有一个就是, 如果我们特别指定<code>&quot;&quot;</code>无名寄存器的话, 写入无名寄存器中的内容也会同时写入<code>&quot;0</code>寄存器中.</p><h3 id="数字寄存器-quot-0-quot-9"><a href="#数字寄存器-quot-0-quot-9" class="headerlink" title="数字寄存器 &quot;0 - &quot;9"></a>数字寄存器 <code>&quot;0 - &quot;9</code></h3><p><code>&quot;0</code>寄存器存储最后的<code>y</code>命令yank的内容, 如果在yank的时候指定了其他的寄存器, 那么<code>&quot;0</code>寄存器中的内容不更新.</p><p><code>&quot;1</code>寄存器存储绝大多数最后删除的内容, 除非指定了其他的寄存器. 如果删除的内容小于一行的话, 使用小型删除寄存器<code>&quot;-</code>. 一个例外就是, 如果删除的命令使用了这些<code>%</code>,<code>(</code>,<code>)</code>,<code>`</code>,<code>/</code>,<code>?</code>,<code>n</code>,<code>N</code>,<code>{</code>,<code>}</code>动作指令, 那么<code>&quot;1</code>寄存器的内容总会被更新为这些新的内容. 同时,如果删除的内容在一行之内的话, <code>&quot;-</code>也会被使用到.<br>每次的删除都会使数字寄存器的内容向后推移.  vim会将原来<code>&quot;1</code>的内容传给<code>&quot;2</code>, 再将原来<code>&quot;2</code>的内容传给<code>&quot;3</code>, 如此下去, 并且丢弃原来<code>&quot;9</code>中的内容.</p><h3 id="小型删除寄存器-small-delete-register-quot"><a href="#小型删除寄存器-small-delete-register-quot" class="headerlink" title="小型删除寄存器(small delete register) &quot;-"></a>小型删除寄存器(small delete register) <code>&quot;-</code></h3><p>这个寄存器存储所有小于一行的删除操作, 除非在删除的时候指定了寄存器.</p><h3 id="有名字母寄存器-quot-a-quot-z-quot-A-quot-Z"><a href="#有名字母寄存器-quot-a-quot-z-quot-A-quot-Z" class="headerlink" title="有名字母寄存器 &quot;a - &quot;z , &quot;A - &quot;Z"></a>有名字母寄存器 <code>&quot;a - &quot;z</code> , <code>&quot;A - &quot;Z</code></h3><p>这些寄存器只有在被指定的时候才会被用到. 小写字母寄存器<code>&quot;a - &quot;z</code>会替换原先的内容, 大写字母寄存器<code>&quot;A - &quot;Z</code>会将内容附加到原先的寄存器中. 当 <code>&gt;</code> 标志被放到 <code>cpoptions</code>时, 在附加内容之前总会插入一个换行符.</p><h3 id="只读寄存器-quot-quot-quot"><a href="#只读寄存器-quot-quot-quot" class="headerlink" title="只读寄存器 &quot;:, &quot;., &quot;%"></a>只读寄存器 <code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code></h3><p>这些寄存器只能只能通过<code>p</code>,<code>P</code>,<code>:put</code>和<code>CTRL-R</code>使用.</p><p><code>&quot;.</code>寄存器包含最后在插入模式下插入的内容.</p><p><code>&quot;%</code>寄存器包含这当前打开的文件名.</p><p><code>&quot;:</code>寄存器包含着最后输入的命令行命令. 可以使用<code>@:</code>来执行最后执行过的命令. 注意, 只有在命令行中执行的命令才会被记录, 也就是说如果是通过按键映射执行的命令将不会被记录.</p><h3 id="备用文件寄存器-quot"><a href="#备用文件寄存器-quot" class="headerlink" title="备用文件寄存器 &quot;#"></a>备用文件寄存器 <code>&quot;#</code></h3><p><code>&quot;#</code>寄存器保存当前窗口备用文件的名字, 它会影响<code>CTRL-^</code>的工作方式. 一个备用文件往往是之前编辑过的文件, 所以可以用这个<code>:e #</code>再两个文件之间快速跳转, 与之有相同功能的是<code>CTRL-^</code>组合键. 比如, 你先打开了<code>file1</code>文件, 然后发现更改了<code>file1</code>的内容后需要更改<code>file2</code>文件, 于是又通过<code>:e file2</code>来打开<code>file2</code>. 在更改的过程中突然发现原来的<code>file1</code>文件有错误, 于是此时就可以<code>CTRL-^</code>切回<code>file1</code>继续编辑. 编辑完了后再次<code>CTRL-^</code>切回<code>file2</code>继续更改.</p><blockquote><p>这个寄存器是可写的. 所以通过一些插件的支持, 或许可以维系一个特别高效的编辑模式.</p></blockquote><h3 id="表达式寄存器-quot"><a href="#表达式寄存器-quot" class="headerlink" title="表达式寄存器 &quot;="></a>表达式寄存器 <code>&quot;=</code></h3><p>当键入<code>&quot;=</code>或者<code>CTRL-R</code>时, 光标会跑到命令行中去. 在那里, 你可以键入任意的表达式, 使用<code>&lt;CR&gt;</code>键结束输入, 使用<code>&lt;ESC&gt;</code>键放弃输入, 如果留空, 那么执行上一次的命令. 然后结果会被转换成字串储存起来. 如果<code>&quot;=</code>被用到<code>p</code>命令上去, 那么其内容会被自动加上一个换行符.</p><h3 id="选中丢弃寄存器-selection-and-drop-register-quot-quot-quot"><a href="#选中丢弃寄存器-selection-and-drop-register-quot-quot-quot" class="headerlink" title="选中丢弃寄存器(selection and drop register) &quot;*,&quot;+,&quot;~"></a>选中丢弃寄存器(selection and drop register) <code>&quot;*</code>,<code>&quot;+</code>,<code>&quot;~</code></h3><p>这些寄存器是否可用还请亲自实验, 后续补全使用条件.</p><p><code>&quot;+</code>寄存器与系统剪贴板相通, 需要编译支持. 而<code>&quot;*</code>会存储选中的内容. 比如存储通过<code>v</code>选中后又<code>&lt;ESC&gt;</code>取消丢弃掉的内容. 这两个非常好用, 可以自己尝试. 剪贴板的我就不说了, <code>&quot;*</code>这个寄存器只要选中就可以将内容存储到里面去了. <code>&quot;~</code> 暂时不知晓, 有机会后续补充.</p><h3 id="黑洞寄存器-quot"><a href="#黑洞寄存器-quot" class="headerlink" title="黑洞寄存器 &quot;_"></a>黑洞寄存器 <code>&quot;_</code></h3><p>如其名, 它就像一个黑洞一样, 只进不出. 使用它不会对其它寄存器作出影响, 从这个寄存器中也取不出任何内容, 总之, 无事发生.</p><h3 id="搜索模式寄存器-quot"><a href="#搜索模式寄存器-quot" class="headerlink" title="搜索模式寄存器 &quot;/"></a>搜索模式寄存器 <code>&quot;/</code></h3><p><code>&quot;/</code>寄存器保存最后一次搜索的搜索模式(pattern). 这会影响命令<code>n</code>,<code>N</code>和选项<code>hlsearch</code>的工作方式. 它是可写的, 可以使用 <code>:let</code>来赋值, 但是无法通过删除或者yank内容到这个寄存器中.</p><blockquote><p>一个用处就是可以通过改变这个寄存器里的内容来高亮不同的内容.</p></blockquote><h3 id="let-形式"><a href="#let-形式" class="headerlink" title="let-@ 形式"></a><code>let-@</code> 形式</h3><p>使用<code>let @</code>后跟寄存器的名字来对寄存器赋值. 比如<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> @<span class="number">1</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> @/ = <span class="string">"good"</span></span><br><span class="line"><span class="keyword">let</span> @<span class="string">" = "</span><span class="keyword">next</span> value <span class="keyword">to</span> paste<span class="comment">"</span></span><br></pre></td></tr></table></figure></p><p>到此, 寄存器这一方面就差不多啦. 再花些时间琢磨出自己的一套使用方法吧.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后编辑时间: &lt;code&gt;2019-2-14&lt;/code&gt; , 之后会添加具体的例子.&lt;/p&gt;
&lt;p&gt;最近再次深入一下&lt;code&gt;vim&lt;/code&gt;, 这次复习了一下&lt;code&gt;vim&lt;/code&gt;的寄存器.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim&lt;/code&gt;寄存器属于那种没用过几乎不用但一用过就再也离不开的角色, 在&lt;code&gt;vim&lt;/code&gt;里面, 寄存器不仅与插件有无限的可能, 而且就算不借助任何插件, 只是使用好这些寄存器也会使你在&lt;code&gt;vim&lt;/code&gt;的编辑效率提高一个档次.&lt;/p&gt;
&lt;p&gt;物超所值, 值的学习!&lt;/p&gt;
&lt;p&gt;这次就将我复习的内容分享出来啦!&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="vim" scheme="https://memorytoco.github.io/Lago/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>linux 命令行</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/14/shell/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/14/shell/</id>
    <published>2019-02-13T22:50:56.000Z</published>
    <updated>2019-02-15T14:05:00.888Z</updated>
    
    <content type="html"><![CDATA[<p>最后编辑时间: <code>2019-2-15</code>, 更改结构, 继续补充完善例子</p><p>所学习的 shell 语法是<strong>bash</strong>语法. 具体的命令需要查看具体的实现.</p><p>命令行的语法罗列. 快速上手shell.</p><a id="more"></a><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>在一个 shell 脚本文件中的每一行都可以作为单独命令来执行. 换句话说就是在 shell 脚本中的每一行都可以直接在 shell 中输入. shell 就是一个解释器, 类似与 python 解释器.</p><p>shell 使用<code>#</code>来进行行注释, 所有在<code>#</code>之后的内容都会被 shell 忽视.</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>变量名可以以字母或下划线<code>_</code>开头,后面跟上零个或者多个字母数字下划线.</p><p>变量的使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable=value</span><br></pre></td></tr></table></figure><p>即变量名后直接跟<code>=</code>. 注意一点, <code>=</code>两边没有空格, 变量名和值之间直接用<code>=</code>连接. 并且, shell 变量里没有类型的概念, 其所存储的都是字符串.</p><p>要使用变量, 使用<code>$variable</code>的形式, shell 在解释时会将<code>$variable</code>替换成它的值. 然后再执行命令. 如果使用一个没有赋过值的变量, 那它的值为空. 在 shell 解析命令时, 会将为空的值从命令行中删除.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> :<span class="variable">$emptyvariable</span>:</span></span><br><span class="line">::</span><br></pre></td></tr></table></figure><p>显示的将一个变量赋空值可以用这些方法:</p><ul><li><code>variable=</code> 直接留空</li><li><code>variable=&#39;&#39;</code> 显示的赋一个空的字串</li><li><code>variable=&quot;&quot;</code> 这样也行</li></ul><p>注意, <code>varialbe=&quot; &quot;</code>这种与上面的不同, 它不是一个空值, 而是将一个空格赋值给了变量.</p><h4 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h4><p>考虑下面一个情景:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> x=*</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">file1 file2 file3</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$x</span></span></span><br><span class="line">file1 file2 file3</span><br></pre></td></tr></table></figure><p>通过这里看到的结果, 那肯定是 shell 将<code>*</code>替换成了当前工作目录的内容, 那问题是, 这个替换过程是在什么时候发生的呢? 换句话就是,<code>$x</code>变量的内容是什么?</p><p>在这个例子里, 解释一下<code>echo $x</code>这行. shell 先将<code>*</code>赋值给<code>x</code>. 第一次扫描, 将<code>$x</code>替换成<code>*</code>, 得到<code>echo *</code>, 然后第二次扫描将<code>*</code>替换成当前目录中的内容, 即是<code>echo file1 file2 file3</code>.</p><p>通过我的说明, 应该就知道, shell 在给变量赋值时, 给<code>x</code>的是<code>*</code>, 也就是不会作任何的替换. 作替换的时候发生在对<code>echo $x</code>这句的解释执行上.</p><blockquote><p>shell 在给变量赋值时, 不会作出任何变化, 但是最好将赋值的内容用单引号或者双引号包起来, 因为它的内容会在求值的时候被替换. 上面的例子里, shell 就做了两次替换.</p></blockquote><h4 id="variable-结构"><a href="#variable-结构" class="headerlink" title="${variable} 结构"></a><code>${variable}</code> 结构</h4><p>如果, 只是如果. 你想将<code>file</code>重命名为<code>filex</code>, 并且在学了变量之后, 你想出了一个办法.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> name=<span class="string">'file'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv <span class="variable">$name</span> <span class="variable">$namex</span></span></span><br></pre></td></tr></table></figure><p>因为变量的值就是一个字串麻, 这么做应该行的通, 但是这里会出现一个问题. <code>$namex</code>并不会被解释为<code>$name</code>的值再加上一个字符<code>x</code>, 而是作为一个全新的变量解释. 想要避免这种情况, 就需要<code>${variable}</code>结构.</p><p>如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> name=<span class="string">'file'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv <span class="variable">$name</span> <span class="variable">$&#123;name&#125;</span>x</span></span><br></pre></td></tr></table></figure><p>这样, 结果就对了.</p><h4 id="expr-算术表达式"><a href="#expr-算术表达式" class="headerlink" title="$((expr)) 算术表达式"></a><code>$((expr))</code> 算术表达式</h4><p>在<code>$(())</code>这个操作符中, 可以进行额外的算术操作, 包括赋值.</p><p>可用操作符:</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td><code>-</code></td><td>减号</td></tr><tr><td><code>~</code></td><td>按位取反</td></tr><tr><td><code>!</code></td><td>逻辑反</td></tr><tr><td><code>*</code>, <code>/</code>, <code>%</code></td><td>乘, 除, 取余</td></tr><tr><td><code>+</code>, <code>-</code></td><td>加, 减</td></tr><tr><td><code>&lt;&lt;</code> , <code>&gt;&gt;</code></td><td>左移, 右移</td></tr><tr><td><code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code></td><td>小于等于,大于等于,小于,大于</td></tr><tr><td><code>==</code>, <code>!=</code></td><td>等于, 不等于</td></tr><tr><td><code>&amp;</code></td><td>按位与</td></tr><tr><td><code>^</code></td><td>按位异或</td></tr><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td></tr><tr><td><code>expr1 ? expr2 : expr3</code></td><td>条件运算符</td></tr><tr><td><code>=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code></td><td></td></tr><tr><td><code>+=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code></td><td></td></tr><tr><td><code>&amp;=</code>, <code>^=</code></td></tr></tbody></table><p>还有 <code>|</code> 按位或, 和 <code>||</code> 逻辑或, 以及 <code>|=</code>.</p><p>其中, <code>++</code>,<code>--</code>与<code>sizeof</code>跟具体的 shell 实现有关. 这里面的操作可以用变量, 变量必须可以解析成数字, 两边可以有空格. 同时, 如果变量未定义, 它被解释成<code>0</code>, 变量不一定要使用<code>$</code>来修饰.</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>shell 中有四种不同的引用字符: <code>&#39;</code>, <code>&quot;</code>, <code>\</code>, <code>`</code>.</p><p>由于这些都是和字串有关的, 所以这里说明一下. 基本上, shell 里面的东西都是字符串, 即使你不加这些引用, 你所输入的依然是字符串. 如果你加入了这些引用, 那么 shell 也会进行处理, 从而保证传给程序的是一个不带引用的字符串.那么, 如何传入一个带引用的字符串呢. 问得好, 这就是这一节的作用.</p><p>一个思想, 这些引用都是为了构建某个比较特殊的字符串. 比如一个<code>&#39;Hello World&#39;</code>, 这样一个带有<code>&#39;</code>的字符串.</p><p>shell 是以空白字符作为分隔符的. 这么说的意思是要明白 shell 在进行字符替换的时候并不会因为命令的不同而不同的对待字符串的替换. 同时, shell 的执行模式依旧是<code>command args</code>, 命令名作为第一个字符串, 参数通过空白字符分隔, 分别传入命令中. 以上引用的最大作用就是, 让一个<strong>特殊字串</strong>作为一个单个参数传入命令中去.</p><p>很多的奇怪问题都是因为将字串展开后误作为多个参数传给了命令. 而这些引用的难点也就是在这里.</p><h4 id="使用-39-防止字符串展开"><a href="#使用-39-防止字符串展开" class="headerlink" title="使用 &#39; 防止字符串展开"></a>使用 <code>&#39;</code> 防止字符串展开</h4><p>所有在<code>&#39;</code>里面的东西都不会被 shell 展开, 甚至是<code>Enter</code>键.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> x=<span class="string">'Hello World'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'$x'</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">x</span></span><br></pre></td></tr></table></figure><h4 id="使用-quot-对字符串展开进行部分限制"><a href="#使用-quot-对字符串展开进行部分限制" class="headerlink" title="使用 &quot; 对字符串展开进行部分限制"></a>使用 <code>&quot;</code> 对字符串展开进行部分限制</h4><p>有三个特殊字符不会在<code>&quot;</code>被忽视: <code>$</code>, <code>`</code>, <code>\</code>.</p><p>在<code>&quot;</code>里面使用<code>$</code>能够完成变量名的替换, <code>\</code>来完成对特殊字符的转义.</p><h4 id="使用-来完成命令替换"><a href="#使用-来完成命令替换" class="headerlink" title="使用 ` 来完成命令替换"></a>使用 <code>`</code> 来完成命令替换</h4><p>在<code>`</code>中, 里面的字串会被识别为一个新的命令, 执行它之后将其的值代替这个字符串. 此方法不建议使用. 只做兼容性考虑.</p><h4 id="结构"><a href="#结构" class="headerlink" title="$() 结构"></a><code>$()</code> 结构</h4><p>和<code>`</code>一样, 这个是作为它的替代品出现. <code>$()</code>不仅比<code>`</code>更加容易识别, 也更加容易进行命令的嵌套. 同时在其中可以完整的使用命令行的力量. 比如管道.</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><h4 id="特殊变量-0-9"><a href="#特殊变量-0-9" class="headerlink" title="特殊变量$0-9"></a>特殊变量<code>$0-9</code></h4><p>如果有一个独立的 shell 脚本, 那么这个脚本可以通过一个叫做位置参数的特殊变量来接受命令行参数. 这些变量记为<code>$num</code>, <code>num</code>为<code>0-9</code>的数字. <code>$0</code> 默认为执行的脚本名称. 而<code>$1-9</code>为第一个, 第二个等等一直到第九个参数.</p><p>可以通过如下来验证:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$1</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$0</span></span></span><br><span class="line">bash</span><br></pre></td></tr></table></figure><h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量$#"></a>特殊变量<code>$#</code></h4><p><code>$#</code> 包含了命令行中输入的参数的个数.</p><h4 id="特殊变量-与"><a href="#特殊变量-与" class="headerlink" title="特殊变量$*与$@"></a>特殊变量<code>$*</code>与<code>$@</code></h4><p><code>$*</code> 包含了命令行中所有的参数. <code>$@</code> 与 <code>$*</code>类似, 但是在替换时, 对于<code>$*</code>, 直接用<code>$1 $2 ..</code>替换, 如果是<code>&quot;$*&quot;</code>的形式, 则会替换成 <code>&quot;$1 $2 $3 ...&quot;</code>这样. 但是对于<code>&quot;$@&quot;</code>来说, 会变成<code>&quot;$1&quot; &quot;$2&quot; ...</code>.</p><h4 id="n-特殊技法"><a href="#n-特殊技法" class="headerlink" title="${n} 特殊技法"></a><code>${n}</code> 特殊技法</h4><p>如果你传入的参数超过了 9 个, 那么可以使用上面的<code>${n}</code>技法来访问第<code>10</code>个及之后的参数.</p><h4 id="shift-命令"><a href="#shift-命令" class="headerlink" title="shift 命令"></a><code>shift</code> 命令</h4><p>如果执行<code>shift</code>, 那么位置变量的内容会左移. 同时<code>$1</code>中的内容被丢弃, <code>$#</code>减一.</p><p><code>shift n</code> 可以<code>shift</code> <code>n</code>次, 等价于执行<code>n</code>次<code>shift</code>命令.</p><hr><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p>一般格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if command_t</span><br><span class="line">then</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">else</span><br><span class="line">  command3</span><br><span class="line">  command4</span><br><span class="line">  ...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其中<code>else</code>可以省去. <code>command_t</code> 是测试条件命令, 返回一个状态码. 如果状态码为<code>0</code>, 那么执行<code>command1</code>等语句, 若<code>else</code>没有省去, 那么执行<code>command3</code>等语句, 若省去了, 则跳过. 状态码是命令执行后返回的一个整数数字, 如果非零则为异常状态, 具体是错误还是警告由程序自己决定. 如果是<code>0</code>, 则总是表示执行成功, 正常退出. 在管道中, 最后一个命令返回的状态码作为整个管道的状态码. 可以使用<code>$?</code>来获得最后一条命令退出的状态.</p><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if command_t1</span><br><span class="line">then</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">elif command_t2</span><br><span class="line">then</span><br><span class="line">  command3</span><br><span class="line">  command4</span><br><span class="line">  ...</span><br><span class="line">else</span><br><span class="line">  command5</span><br><span class="line">  command6</span><br><span class="line">  ...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>这里多出了<code>elif ... then ...</code>语句. 可以有任意个<code>elif then</code>. 如果<code>command_t1</code>结果为假, 继续求值<code>command_t2</code>, 结果为真则执行<code>command3</code>等语句, 如果为假且还有<code>elif then</code>语句, 重复上面的操作, 如果没有了, 则执行<code>else</code>后面的语句.</p><hr><p><code>/dev/null</code> 是一个特殊的设备, 在脚本中通常用于管道消除不想要的结果. 比如消去<code>grep</code>命令的显示结果, 只需要它的返回状态, 就使用<code>grep pattern file &gt; /dev/null</code>.</p><hr><p><code>test expression</code> , <code>test</code>命令会对<code>expression</code>求值, 如果结果为真, 返回<code>0</code>, 如果结果为假, 返回非零的退出状态码.</p><table><thead><tr><th>字符串操作符</th><th>含义</th></tr></thead><tbody><tr><td>string1 <code>=</code> string2</td><td>string1 等于 string2</td></tr><tr><td>string1 <code>!=</code> string2</td><td>string1 不等于 string2</td></tr><tr><td>string</td><td>string 不为空</td></tr><tr><td><code>-n</code> string</td><td>string 不为空</td></tr><tr><td><code>-z</code> string</td><td>string 为空</td></tr></tbody></table><blockquote><p>最好将测试的字符串用双引号来引用, 避免空字串被命令行删除的情况.</p></blockquote><p>在 shell 脚本中, 常常使用它的简写 <code>[ expression ]</code>, 这样就会使脚本更加明朗.</p><hr><p><code>test</code>也能对数字进行比较操作.</p><table><thead><tr><th>数字操作符</th><th>含义</th></tr></thead><tbody><tr><td>int1 <code>-eq</code> int2</td><td>int1 等于 int2</td></tr><tr><td>int1 <code>-ne</code> int2</td><td>int1 不等于 int2</td></tr><tr><td>int1 <code>-gt</code> int2</td><td>int1 大于 int2</td></tr><tr><td>int1 <code>-lt</code> int2</td><td>int1 小于 int2</td></tr><tr><td>int1 <code>-ge</code> int2</td><td>int1 大于等于 int2</td></tr><tr><td>int1 <code>-le</code> int2</td><td>int1 小于等于 int2</td></tr></tbody></table><hr><p><code>test</code>也能对文件进行判断操作.</p><table><thead><tr><th>文件操作符</th><th>含义</th></tr></thead><tbody><tr><td><code>-d</code> file</td><td>file 是一个目录</td></tr><tr><td><code>-e</code> file</td><td>file 存在</td></tr><tr><td><code>-f</code> file</td><td>file 是一个普通文件</td></tr><tr><td><code>-r</code> file</td><td>file 可读取</td></tr><tr><td><code>-s</code> file</td><td>file 不是空文件</td></tr><tr><td><code>-w</code> file</td><td>file 可写</td></tr><tr><td><code>-x</code> file</td><td>file 可执行</td></tr><tr><td><code>-L</code> file</td><td>file 是一个符号链接</td></tr></tbody></table><hr><p><code>test</code> 逻辑操作符.</p><table><thead><tr><th>操作符</th><th>作用</th></tr></thead><tbody><tr><td><code>!</code></td><td>逻辑否定操作符, 可以放在任意的表达式之前, 否定该表达式的结果</td></tr><tr><td><code>-a</code></td><td>逻辑与, 放在两个表达式之间, 执行逻辑与</td></tr><tr><td><code>-o</code></td><td>逻辑或, 放在两个表达式之间, 执行逻辑或</td></tr></tbody></table><p><code>test</code> 可以使用<code>()</code>来改变求值顺序, 不过需要用<code>\</code>来转义, 避免被shell解释. 括号可以放在表达式两边并且括号需要作为一个独立的参数传给<code>test</code>, 这就意味着每个括号两边需要使用空格与其它参数分离.</p><h4 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a><code>case</code> 语句</h4><p>一般格式如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">case value in</span><br><span class="line">pattern1 )</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandn;;</span><br><span class="line">pattern2 )</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandn;;</span><br><span class="line">...</span><br><span class="line">patternn )</span><br><span class="line">    ...</span><br><span class="line">    commandn;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><p>不必多说, <code>case</code>将<code>value</code>与每个<code>pattern</code>进行匹配, 如果匹配成功, 那么执行其下面的一系列命令. 如果什么都不匹配, 不做任何事情. <code>pattern</code>与<code>)</code>之间可以没有空格.</p><p>同时, <code>pattern</code>也可以使用<strong>通配符</strong>. <code>?</code>匹配任意一个字符, <code>*</code>匹配零个或多个任意字符, <code>[ ... ]</code>则匹配其中出现的字符. 这个在命令行中的一样. 同时可以使用<code>|</code>. <code>pattern1 | pattern2 )</code>, 这个表示满足<code>pattern1</code>或者满足<code>pattern2</code>都会执行这里的命令. <code>|</code>效果等同于逻辑<strong>或</strong>.</p><h4 id="空语句"><a href="#空语句" class="headerlink" title="空语句:"></a>空语句<code>:</code></h4><p>正如你所想的那样, 这是一个空语句, 相当于<code>c</code>中的单个<code>;</code>. 它可以被认为是命令的占位符, 在某些要求必须有命令的地方而你又不希望执行什么操作的时候, 可以使用<code>:</code>. 最好在<code>:</code>附近加上注释.</p><h4 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp; 和 ||"></a><code>&amp;&amp;</code> 和 <code>||</code></h4><p>这两个操作符可以通过判断之前执行命令的退出状态来决定是否执行接下来的命令, 如此往复.</p><p><code>command1 &amp;&amp; command2 &amp;&amp; ... &amp;&amp; commandn</code> 这种形式会先执行<code>command1</code>. 如果其退出的状态码为<code>0</code>, 那么执行<code>command2</code>, 如果不是<code>0</code>, 那么跳过接下来所有的命令. 对于接下来的命令, 重复之前的判断操作.</p><p><code>||</code>的效果与<code>&amp;&amp;</code>正好相反. 如果前一个命令正常退出的话, 结束. 否则执行后面的命令.</p><h4 id="exit-n-语句"><a href="#exit-n-语句" class="headerlink" title="exit n 语句"></a><code>exit n</code> 语句</h4><p>使用 <code>exit n</code>来从任意的地方退出脚本. 返回<code>n</code>状态码. 如果<code>n</code>被省去了, <code>exit</code> 相当于 <code>exit $?</code>.</p><hr><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>循环可以按照特定的次数或者终止条件执行一组命令. 有<code>for</code>, <code>while</code>, <code>until</code> 这三个命令.</p><h4 id="for命令"><a href="#for命令" class="headerlink" title="for命令"></a><code>for</code>命令</h4><p>一般形式:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for var in word1 word2 ... wordn</span><br><span class="line">do</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p><code>do</code>和<code>done</code>之间的称作<strong>循环体</strong>, 在执行时, 首先把<code>word1</code>赋值给<code>var</code>, 执行循环体, 再把<code>word2</code>赋值给<code>var</code>, 执行循环体, 如此往复一直到<code>wordn</code>.</p><p><code>for</code>也可以不带字符列表.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for var</span><br><span class="line">do</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>那么<code>for</code>会自动遍历命令行中的参数.</p><h4 id="while命令"><a href="#while命令" class="headerlink" title="while命令"></a><code>while</code>命令</h4><p>一般形式:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while command_t</span><br><span class="line">do</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>如果<code>command_t</code>返回<code>0</code>, 那么执行循环体中的内容. 执行后再次执行<code>command_t</code>, 执行循环体. 如此循环, 直到<code>command_t</code>返回了一个非<code>0</code>状态码. 如果一开始<code>command_t</code>返回非零状态码, 循环体一次都不会执行.</p><h4 id="until命令"><a href="#until命令" class="headerlink" title="until命令"></a><code>until</code>命令</h4><p>一般形式:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">until command_t</span><br><span class="line">do</span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>和<code>while</code>类似, 但是相反.  当<code>command_t</code>返回<code>0</code>时, 循环体不执行, 否则执行循环体, 执行逻辑与<code>while</code>一致.</p><h4 id="循环的后台执行-done-amp"><a href="#循环的后台执行-done-amp" class="headerlink" title="循环的后台执行 done &amp;"></a>循环的后台执行 <code>done &amp;</code></h4><p>只要在<code>done</code>后边添加一个<code>&amp;</code>就可以是循环后台运行.</p><h4 id="闭合语句fi-done-esac的管道重定向"><a href="#闭合语句fi-done-esac的管道重定向" class="headerlink" title="闭合语句fi,done,esac的管道重定向"></a>闭合语句<code>fi</code>,<code>done</code>,<code>esac</code>的管道重定向</h4><p>在闭合语句后边可以使用管道与重定向. 重定向会改变代码块中所有命令的输入输出.</p><h4 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a><code>break</code> 与 <code>continue</code></h4><p><code>break</code> 用于退出循环, <code>break n</code>用于退出<code>n</code>层循环.<br><code>continue</code>用于跳过循环, <code>continue n</code>用于跳过<code>n</code>次循环.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后编辑时间: &lt;code&gt;2019-2-15&lt;/code&gt;, 更改结构, 继续补充完善例子&lt;/p&gt;
&lt;p&gt;所学习的 shell 语法是&lt;strong&gt;bash&lt;/strong&gt;语法. 具体的命令需要查看具体的实现.&lt;/p&gt;
&lt;p&gt;命令行的语法罗列. 快速上手shell.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="linux shell" scheme="https://memorytoco.github.io/Lago/tags/linux-shell/"/>
    
  </entry>
  
  <entry>
    <title>博客功能说明</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/12/blogIntro/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/12/blogIntro/</id>
    <published>2019-02-11T23:36:26.000Z</published>
    <updated>2019-02-14T13:52:01.600Z</updated>
    
    <content type="html"><![CDATA[<p>简要的说明一下辅助博客的文章类别以及其作用吧.<br>如果使用结果不错的话, 就将它搬到<code>Lasga</code>中去.<br>最主要的也是方便阅读这个博客的人.</p><a id="more"></a><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>这篇博客的所有由文章暂分三类, 分别是<strong>笔记</strong>, <strong>漫谈</strong>, <strong>教程</strong>.</p><p>所有的笔记都是跟随一本书随阅读进度进行更新的, 内容主要是针对一些我觉得比较关键的点的罗列, 可能会附加一些个人的思考. 笔记自有一套自己的更新规则, 一般不会跟随书的目录章节更新, 而是受到自己的学习进程影响, 有时可能会针对某一个点额外的发布文章, 届时会在笔记中加入链接.</p><blockquote><p><code>笔记不一定十分准确</code>, 但会一直更新. 已发布的也会更新. 毕竟个人知识总会有差错, 随着个人经验的积累也会有进步嘛. 这个笔记是跟着我本地的笔记更新的, 一旦我有了比之前更加深刻的认识, 就会去更新笔记.</p></blockquote><blockquote><p>现在会在笔记开头部分写下更新时间. 以供参考.</p></blockquote><p>漫谈则如其名, 主题不明, 谈谈对于一些技术, 对于计算机科学理论的理解等等…</p><blockquote><p>已发布的漫谈一般不会再更新, 如有错误, 会另起一篇来说明.</p></blockquote><p>教程往往是有关一个主题的, 拥有一个唯一的<em>tag</em>, 可以在<em>tags</em>一栏中选择来进行阅读.具体的信息会在教程中进行发布.</p><blockquote><p>教程会随时间动态更新.</p></blockquote><h3 id="关于更新"><a href="#关于更新" class="headerlink" title="关于更新"></a>关于更新</h3><p>会有更新的文章或者会持续更新的文章会有一个 <strong>最后编辑时间</strong> 的标签, 一般在预览界面就能看到, 后面跟着最后的更新时间和一些简短的关于这篇文章的信息.</p><p>有的文章可能不会有这种标签但仍在更新中, 这类一般是博客的规则类内容, 比如你正在阅读的一篇.</p><p>以上…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简要的说明一下辅助博客的文章类别以及其作用吧.&lt;br&gt;如果使用结果不错的话, 就将它搬到&lt;code&gt;Lasga&lt;/code&gt;中去.&lt;br&gt;最主要的也是方便阅读这个博客的人.&lt;/p&gt;
    
    </summary>
    
    
      <category term="MISC" scheme="https://memorytoco.github.io/Lago/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>真象还原之零</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/10/truthaboutSys_0/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/10/truthaboutSys_0/</id>
    <published>2019-02-09T22:13:01.000Z</published>
    <updated>2019-02-14T13:52:18.303Z</updated>
    
    <content type="html"><![CDATA[<p>最后编辑时间: <code>2019-2-12</code></p><p>这个是阅读<strong>操作系统真象还原</strong>的笔记. 记录学习系统一些知识点.<br>同时和<strong>深入理解计算机操作系统</strong>一起. 希望学完系统能让我更加方便的学习汇编与二进制.</p><a id="more"></a><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>常见 cpu 字节序:</p><ul><li>大端字节序: <code>IBM, Sun, PowerPC</code></li><li>小端字节序: <code>x86, DEC</code><blockquote><p><code>ARM</code> 系的大小通吃<br>网络字节序是大端字节序</p></blockquote></li></ul><hr><p>指令集与微架构:</p><p>对于指令集来说有两种指令体系, 分别是<code>CISC</code>和<code>RISC</code>两个.指令集则是类似于协议的存在.AMD 和 Intel使用同一种指令集,但是他们各自对于cpu的硬件实现不同,而这个<em>硬件实现</em>就称之为<em>微架构</em>.</p><p>目前存在的指令集共有5种, 分别是 <code>x86(Intel), ARM, MIPS, Power, C6000</code>.其中只有<code>x86</code>是是属于CISC体系的.</p><hr><p>整个系统的启动过程简述(个人理解):</p><p>电源通电后, 硬件开机自检. 硬件是如何知道这时候需要自检的呢? 是<strong>BIOS</strong>通知它们的.<strong>BIOS</strong> 如上所述, 是基本的输入输出系统. 没有太多的功能, 它的目的就是为了在整个开机接力赛中传递这第一棒. 在通知个硬件自检后, 它就会将接力棒传给<strong>MBR</strong>. <strong>MBR</strong>就是主引导程序. 如果折腾过linux, 那么可以把这个<strong>GRUB</strong>想象成<strong>MBR</strong>. 这么说或许就清楚点了.随后<strong>MBR</strong>会寻找<strong>OBR</strong>, 将主导权交给对应系统的引导程序. 可以把grup上的一些系统选项想象成系统引导程序. 最后, 主导权再由<strong>OBR</strong>交接给系统内核. 至此, 系统就正常启动啦.</p><blockquote><p>如果你不仅折腾过linux, 还想过把它和windows一起装在机器里, 那么你一定会使用双启动这方案. 折腾过双系统的人一定会碰到过这种情况:</p></blockquote><blockquote><p>在把linux安装完成后, 开机就是grub, windows则消失不见了. 如果需要再次引导windows则需要配置一下grbu才行. 反之, 如果在存在linux系统的情况下安装或者重装windows系统, 则会发现开机直接进入windows了. 出现这种情况是因为windows系统在安装的时候会把自己的引导程序放到<strong>MBR</strong>中去, 这就会造成机器启动的时候直接执行此时<strong>MBR</strong>上的内容. 这时候<strong>MBR</strong>上存放的是windows的引导器, 所以windows就会直接启动, linux就被撂在一旁,可怜兮兮,无人搭理.</p></blockquote><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ul><li><code>elf</code> : <code>executable and linking format</code></li><li><code>readelf -e elf</code> 用来查询程序中段的类型. (其中 <code>elf</code> 是文件名)</li><li><code>GDT</code> : <code>Global Descriptor Table</code> 全局描述符表, 表中的每一项被称为段描述符.</li><li>描述符 : 描述某种数据的数据结构, 是元信息.</li><li>堆 : 程序运行过程中用于动态内存分配的内存空间, 由操作系统分配划分.</li><li>堆栈,栈 : 同指栈, 硬件必须.</li><li>大端字节序和小端字节序<blockquote><p>小端字节序是数值的低字节存放在内存的低地址出,高字节存放在高地址处.<br>大端字节序与小端字节序相反.</p></blockquote></li><li><code>IVT</code> : <code>Interrupt Vector Table</code> 中断向量表.</li><li><code>CISC</code> : <code>Complex Instruction Set Computer</code> 复杂指令集计算机</li><li><code>RISC</code> : <code>Reduced Instruction Set Computer</code> 精简指令集计算机</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>我原本对<strong>位,比特,字节</strong>这些东西一直记不住,现在搞清了赶紧记下来.</p><blockquote><p>一个位即是一个 bit(比特),是最最小的数据单位,没有比它更小的了.</p></blockquote><blockquote><p>一个字节是 8 位,写作 byte, 换算关系为 <em>1 byte</em> = <em>8 bits</em> .<br>而内存的分布是以 byte 为基本单位的,也就是那些内存地址的单位都是 byte.</p></blockquote><p>另外一点容易弄混的是对于数据大小的判别. 首先分清这个十六进制数是一个存在内存里的数还是一个地址. 如果是数那么计算的单位是<code>bit</code>即位. 将这个数字换成一<code>二进制</code>串,其长度就是其大小,当然单位为<code>bit</code>. </p><blockquote><p>比如 <code>0xac2</code> 这个十六进制数所占的内存大小为12位,由于字节是8位,这里采用向上取整的方法为2字节. 二进制数为 <code>b101011000010</code>.</p></blockquote><p>如果是要看这个数本身的大小,则通过进制转换成十进制数即可.</p><blockquote><p>那么还是上面的例子, <code>0xac2</code> 这个数的大小可以通过十六进制转换为十进制即可.</p></blockquote><p>于是在具体的计算一个数字的”大小”的时候最好分清这个”大小”的意义所在.</p><hr><p>另外再提一句, 计算机内存是以<code>0</code>开始计算的. 同时, 对于一个地址从 <code>0x001</code> 到<code>0x003</code> 这样的一个地址段, 它的容量是<code>3</code>. 即末地址减去起始地址再加一.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后编辑时间: &lt;code&gt;2019-2-12&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个是阅读&lt;strong&gt;操作系统真象还原&lt;/strong&gt;的笔记. 记录学习系统一些知识点.&lt;br&gt;同时和&lt;strong&gt;深入理解计算机操作系统&lt;/strong&gt;一起. 希望学完系统能让我更加方便的学习汇编与二进制.&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://memorytoco.github.io/Lago/categories/Note/"/>
    
    
      <category term="ComputerSystem Asm" scheme="https://memorytoco.github.io/Lago/tags/ComputerSystem-Asm/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://memorytoco.github.io/Lago/2019/02/10/Hello-World/"/>
    <id>https://memorytoco.github.io/Lago/2019/02/10/Hello-World/</id>
    <published>2019-02-09T21:18:39.000Z</published>
    <updated>2019-02-12T07:57:08.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不-我没有放弃flax"><a href="#不-我没有放弃flax" class="headerlink" title="不, 我没有放弃flax!"></a>不, 我没有放弃flax!</h2><p>这里做一些说明吧.<br>基于现在的情况, 暂时使用<code>hexo</code>.</p><a id="more"></a><h3 id="现在你用了hexo建了博客-原来的flax呢"><a href="#现在你用了hexo建了博客-原来的flax呢" class="headerlink" title="现在你用了hexo建了博客,原来的flax呢?"></a>现在你用了<code>hexo</code>建了博客,原来的<code>flax</code>呢?</h3><p>emmm, 首先这两者不冲突. <code>flax</code> 的开发还在继续,并没有弃坑.</p><blockquote><p>我这个寒假一半的时间都耗在上面了,怎么可能弃坑呢! 并且我相信最终的它会给你们带来惊喜!</p></blockquote><p>然后主要现在在开发<code>flax</code>上遇挫, 遭遇了一个瓶颈.<br>一来迟迟不能让整个工作流程建立起来,<br>二来我也等不及了,<br>三来看到的一些东西让我对<code>flax</code>的期望(或者说是野心)增加了,结果让这个成型日期更加的延后.</p><h3 id="这个-Lago-是干什么的"><a href="#这个-Lago-是干什么的" class="headerlink" title="这个 Lago 是干什么的?"></a>这个 <code>Lago</code> 是干什么的?</h3><p>这个博客用于</p><ul><li>记笔记, 把一些想要分享的东西及时的贴出来</li><li>学习 <code>hexo</code>, 给 <code>flax</code> 铺路</li><li>进行知识输出</li><li>摸索自己的需求</li><li>作为一个辅助博客出现, 同时兼顾 <code>flax</code>的动态信息</li></ul><p>由于 <code>flax</code> 还在开发中, 我就没法着手关于博客页面相关的研究.<br>这就让整个进度异常缓慢, 非常摧残我的小心灵!! 所以这个博客就是一个试探.</p><blockquote><p>我在写<code>flax</code>的时候也对网站没什么概念, 用上这个来学习学习.</p></blockquote><blockquote><p>我最近一直在尝试建立起个人的学习体系, 其中的一环就是博客.<br>现在这个比重还在持续上升中.</p></blockquote><h3 id="那-flax-有什么动作吗"><a href="#那-flax-有什么动作吗" class="headerlink" title="那 flax 有什么动作吗?"></a>那 <code>flax</code> 有什么动作吗?</h3><p>有, 现在 <code>flax</code> 已经有了一个伪 <strong>hook</strong> 系统. 受到 <code>chez-scheme</code> 的逼迫,我不得不改变原先的工作机理, 摆脱对 <code>guile</code> 实现的依赖, 于是绞尽脑汁捉摸出了一个基于<strong>链表</strong> 这个数据结构的的系统, 终于可以在 <strong>新的</strong> 的实现上跑起来了.</p><blockquote><p>我也深刻的意识到了基本功的重要性. (转来转去, 我依然是在用我之前接触到的东西)</p></blockquote><p>出乎意料的是我发现这个改变得到的收益比我想象中的还要多. 于是我又想在这个基础上看看能不能琢磨出一个 <code>trigger</code> 系统出来, 再给它加上一些额外的支持.</p><p>由于原来的 <code>flax</code> 是我基于 <a href="https://dthompson.us/projects/haunt.html" target="_blank" rel="noopener">guile haunt</a> 一点一点<code>抄</code> 过来的, 所以有很多的思路都受到限制( 还是我自己脑补的思路… ), 现在正在努力的一点一点突破限制.</p><p>我现在还在继续扩展<code>flax</code>, 并且边用 <code>hexo</code> 边观察它的运作方式. 希望获得启发吧.</p><h2 id="所谓的-Flax-动态在哪里"><a href="#所谓的-Flax-动态在哪里" class="headerlink" title="所谓的 Flax 动态在哪里?"></a>所谓的 <code>Flax</code> 动态在哪里?</h2><p>在这个博客的页面可以看到一栏 <code>Flax</code>, 那里有一些关于 <code>Flax</code> 的信息.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不-我没有放弃flax&quot;&gt;&lt;a href=&quot;#不-我没有放弃flax&quot; class=&quot;headerlink&quot; title=&quot;不, 我没有放弃flax!&quot;&gt;&lt;/a&gt;不, 我没有放弃flax!&lt;/h2&gt;&lt;p&gt;这里做一些说明吧.&lt;br&gt;基于现在的情况, 暂时使用&lt;code&gt;hexo&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Misc Flax Hexo" scheme="https://memorytoco.github.io/Lago/tags/Misc-Flax-Hexo/"/>
    
  </entry>
  
</feed>
