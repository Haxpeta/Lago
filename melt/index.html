<!DOCTYPE html>
<html lang="cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="melt">













  <link rel="alternate" href="/Lago/atom.xml" title="Lago">




  <link rel="shortcut icon" type="image/x-icon" href="/Lago/favicon.ico?v=2.10.2">



<link rel="canonical" href="https://memorytoco.github.io/Lago/melt/">



  <link rel="stylesheet" type="text/css" href="/Lago/lib/fancybox/jquery.fancybox.css">




  <link rel="stylesheet" type="text/css" href="/Lago/lib/nprogress/nprogress.min.css">



<link rel="stylesheet" type="text/css" href="/Lago/css/style.css?v=2.10.2">



  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> melt - Lago </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/Lago/." class="logo">Lago</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/Lago/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/Lago/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/Lago/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/Lago/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/Lago/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
      <a href="/Lago/melt">
        <li class="mobile-menu-item">
          
          
            Melt
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/Lago/." class="logo">Lago</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/Lago/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/Lago/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/Lago/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/Lago/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/Lago/about">
            
            
              关于
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/Lago/melt">
            
            
              Melt
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <article class="post">
    <div class="post-content">
      <h1 id="关于-melt-近期的信息"><a href="#关于-melt-近期的信息" class="headerlink" title="关于 melt 近期的信息"></a>关于 melt 近期的信息</h1><ul>
<li>更新时间 : <code>2019-3-24</code></li>
<li><code>melt</code> 最新开发信息: <code>v 0.0.3-1</code> 实现了scheme sxml模板的应用模式, 已经完成了一个demo页面的创建. 目前使用的函数是<code>load-source</code>, 发现可以使用这个达到更多的效果, 比如将一个命令编译成二进制的代码文件, 然后给出环境之后直接加载这个文件. 更加的灵活了. 另外markdown还是有点问题, 学了一些算法之后打算使用算法来更新这个.</li>
</ul>
<p>如果有任何好的建议, 欢迎通过邮件与我交流.</p>
<h2 id="melt-工作流程"><a href="#melt-工作流程" class="headerlink" title="melt 工作流程"></a>melt 工作流程</h2><p>首先<strong>parser</strong>读取源文件, 解析源文件, 将得到的数据返回, 然后调用refine中的函数判断是否进行额外的处理. 根据具体的设计可能对初始的原文件进行更新. 目前没有实现这个refine的功能, 之后考虑给parser加上一些配置功能, 同时给出几个成熟的refine的选项, 由使用者决定refine的行为.</p>
<p>返回的数据交由<strong>post</strong>进行封装,得到完整的 <code>post sxml</code> 数据以及相关的原始文件信息以及关于<strong>post</strong>的一些属性, 类似 <em>tag, categories</em> 这类, 还有原始文件的路径, 原始文件名字, 原始文件的修改日期. 得到<strong>post</strong>之后, 这个就算最初始的处理了. 对于后面的过程来讲, 最小的数据单元就是这个 <strong>post</strong> 了. 在进行parse的过程中, 还可以根据情况来更新全局的数据文件.</p>
<blockquote>
<p><strong>post</strong> 包含了由解析器处理后的<code>sxml</code>数据以及相关的文件属性</p>
</blockquote>
<p>在得到一系列或者单个<strong>post</strong>之后,就会根据<strong>site</strong>的设定用每个独立的<strong>page</strong>单元调用依据对应不同部分的<strong>renderer</strong>来对原始<code>sxml</code>进行渲染和组装处理.这时候可能是输入诸如 post 时间, post 分类, 生成相关的<em>url</em>这类数据的阶段. 这里的page是一个处理模板, renderer给page提供了额外的复杂处理可能. render的过程发生的时间不定.</p>
<p>最后最后, 我们可能得到了一系列或者单个<strong>page</strong>原数据.这时最小的数据单元就是一个个或者单个<strong>page</strong>了. 依据<strong>site</strong>的设定一个个的输出到对应的目标位置. 在这期间是否会有什么其他的操作不得而知, 但是基于<code>sxml</code>的特性, 依旧存在着继续处理的可能性.(因为 sxml 和一个 lisp 代码没有本质的区别,只是把它当成数据来处理了,这也是当初决定拿 scheme 来写这个东西的一个原因)</p>
<p>结尾时, 再把一些网站的资源文件搬到对应的地方去, 由<strong>asset</strong>来处理. 这个asset负责搬运文件, 可以在一开始处理post的时候就生成这个元数据文件, 最后交给一个统一的执行函数来处理这个, 比如每个markdown中引用的图片, 或者网站中某个特殊的页面所需要的资源文件等.</p>
<p>至此, 整个建站过程完成. 下面针对一些细节再次讨论一下:</p>
<ul>
<li>整个过程似乎没有提到一些特殊的页面, 比如<strong>categories</strong>和最开始的<strong>index</strong>页面, 这些怎么生成</li>
</ul>
<p>回答就是完全的由site和page的属性定义. 最后在处理的时候实际上是调用site域里面定义的一些函数来进行文件输入输出的. 但是这里的具体行为还没由确定下来, 因为不想把这个写死.所以需要再思考思考, 不过可以确定的是, 这个组合是没错的, 它能够达到想要的任何效果.</p>
<p>同样的, 对于<strong>atom</strong>格式的 RSS,可能的订阅服务等, 都可以交由那两个来处理.</p>
<p>这里面借助于chain这个结构的优势. chain允许定义一系列的执行序列, 提供它们的参数, 然后依次执行. 同时它自己还有维护一个它自带的数据域. 这个意味着, 可以定义多个执行的行为, 然后不断更新这个数据域, 方便后面的行为进行. 个人觉得这个是非常灵活的. 现阶段的chain已经能够达到这个程度了. 只是我还是项再思考思考将这个结构优化一下. </p>
<hr>
<hr>
<h2 id="melt-待定计划和功能实现"><a href="#melt-待定计划和功能实现" class="headerlink" title="melt 待定计划和功能实现"></a>melt 待定计划和功能实现</h2><ul>
<li style="list-style: none"><input type="checkbox"> 因为体验到了<code>load-source</code>的威力, 考虑建立一个小型的代码数据文件.<blockquote>
<p>为了存储一些持久性的数据, 因为每执行一次命令都要更新一些东西, 但是只有chain的数据域存储数据的话无法提供给下一次的处理. 这样对于一些更新和检测的功能就不好实现.</p>
</blockquote>
</li>
<li style="list-style: none"><input type="checkbox" checked> markdown 的支持<blockquote>
<p>19-3-12 更新: markdown完成.</p>
</blockquote>
</li>
<li style="list-style: none"><input type="checkbox"> markdown refine工作, 更新加强markdown, 将它尽量的模块化, 允许控制解析出来的sxml的具体格式</li>
<li style="list-style: none"><input type="checkbox"> sxml-&gt;html 重构 : 希望将它重新以我的思路重写.</li>
<li style="list-style: none"><input type="checkbox"> 内部的 url 连接问题, 以及在写 post 时对于其它 post 或者资源文件引用的问题</li>
<li style="list-style: none"><input type="checkbox"> 单个 post 或者单个页面的资源位置存放问题</li>
<li style="list-style: none"><input type="checkbox"> 插件系统<blockquote>
<p>现在在想是不是可以有一个切实有用的系统, 这样一个插件”安装”了, 就可以直接看到效果?</p>
</blockquote>
</li>
<li style="list-style: none"><input type="checkbox"> serve命令</li>
<li style="list-style: none"><input type="checkbox" checked> 基本的工作流程确定 3-24确定</li>
<li style="list-style: none"><input type="checkbox" checked> 配置文件布局的确定 3-24确定</li>
</ul>
<h2 id="melt-预备特性"><a href="#melt-预备特性" class="headerlink" title="melt 预备特性"></a>melt 预备特性</h2><ul>
<li>git 集成</li>
<li>shell集成(方便定义二级命令来调用外部的工具)</li>
</ul>
<hr>
<hr>
<h2 id="melt-改进计划以及详细介绍"><a href="#melt-改进计划以及详细介绍" class="headerlink" title="melt 改进计划以及详细介绍"></a>melt 改进计划以及详细介绍</h2><p>目前 melt 的目标是能够最大限度的给予用户自由并且提供充足的 api 来减轻<br>用户的负担.</p>
<h3 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h3><p>定义为一个前端处理单元, 一个处理单元就对应一个类型的文件. 它的动作和可设置的选项由它自己决定.</p>
<blockquote>
<p>用于读取原 post 并把它转化成 sxml<br>parser 是一个存有编译程序的数据, 由 parse 调用. 在整个处理过程之前存在</p>
</blockquote>
<p>定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type ==&gt; 类别,用于识别源文件.</span><br><span class="line">proc ==&gt; 用于处理源文件,提取原始信息,将其转化成 sxml.</span><br><span class="line">refp ==&gt; 精炼函数,处理源文件,更新它的信息.</span><br></pre></td></tr></table></figure>
<p>其本身可能会有多段的分析组合, 这些都由它自己决定.</p>
<h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><blockquote>
<p>现在就是代表了基本的源数据, 不只是表示一个写的文章或者什么, 由 markdown 扩展</p>
</blockquote>
<p>定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meta ==&gt; 原始处理文件的信息,不是 post 的信息. 比如修改时间,具体的路径文件名.</span><br><span class="line">attr (属性) ==&gt; 在文件头解析得到的属性, 比如文章名字</span><br><span class="line">cont ==&gt; 处理后的 post 内容</span><br></pre></td></tr></table></figure>
<p>此时 post 和 parser 组成了整个前端,完成一个源文件的分析更新工作.</p>
<h3 id="renderer"><a href="#renderer" class="headerlink" title="renderer"></a>renderer</h3><blockquote>
<p>渲染, 针对特定的 page 进行特定的处理,对 post 的数据进行封装<br>由 page 调用, 根据不同的组件进行处理.</p>
</blockquote>
<p>renderer 定义组件, page 调用.</p>
<p>定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type ==&gt; 需要处理的组件的识别符</span><br><span class="line">proc ==&gt; 具体的处理函数,由 process 组成,可能嵌套</span><br><span class="line">data ==&gt; 暂时需要的存储数据, 使用data结构</span><br></pre></td></tr></table></figure>
<h3 id="page"><a href="#page" class="headerlink" title="page"></a>page</h3><blockquote>
<p>用于将每个 post 渲染后写入目标文件</p>
</blockquote>
<p>定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meta ==&gt; 包括识别名和可能的page属性</span><br><span class="line">cont ==&gt; 页面模板</span><br><span class="line">comt ==&gt; 页面的组件, 在使用前需要在这里注册它的行为, 也就是说这是一个函数</span><br></pre></td></tr></table></figure>
<p>页面渲染首先是渲染部件,然后再组合,comt 由 render 来渲染,最后写进模板中</p>
<h3 id="site-对博客的整体配置"><a href="#site-对博客的整体配置" class="headerlink" title="site 对博客的整体配置"></a>site 对博客的整体配置</h3><p>可能的域:</p>
<ul>
<li>layout ==&gt; 网站布局, 是具体的文件集对网站组成部分的对应关系.</li>
<li>comt ==&gt; 组件,比如个人介绍页, 资源页等.</li>
<li>attr ==&gt; 网站的相关属性, 比如域名, 托管工具等等</li>
</ul>
<h3 id="hook-系统和-trigger-系统"><a href="#hook-系统和-trigger-系统" class="headerlink" title="hook 系统和 trigger 系统"></a>hook 系统和 trigger 系统</h3><p>这个似乎可以使用<code>call/cc</code>来实现, 同时也在试着实现一个try throw系统.</p>
<h3 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h3><p>目前已经想到了实现的方案, 但是现阶段追求melt的稳定性和完善程度, 会在plugin分支中进行开发, 至于会不会推上线上的仓库, 看情况.</p>
<h3 id="melt-文件夹"><a href="#melt-文件夹" class="headerlink" title=".melt 文件夹"></a>.melt 文件夹</h3><p>这里面就是整个的真身. 在使用 init 命令时, 会生成这个文件. 里面的有<code>settings.scm</code>定义 melt 配置, 然后由这个定义工作文件夹的布局, 提供命令什么的. 现在这个已经落实下来了, 之后会给出更多的说明和定义.</p>

    </div>
  </article>

          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:memorytoco@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/memorytoco" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      <a href="/Lago/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Memorytoco</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    
  



  
  





  
    <script type="text/javascript" src="/Lago/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/Lago/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/Lago/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/Lago/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/Lago/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/Lago/js/src/even.js?v=2.10.2"></script>

  </body>
</html>
